<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: jsdoc-db-procedures.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: jsdoc-db-procedures.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @function set_function_owners
 * @memberof utils
 * @description Set function owners
 * @param {text} owner_name
 * @returns {void}
 */
function set_function_owners() {
/*
CREATE OR REPLACE FUNCTION utils.set_function_owners(owner_name text)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE
    procedure_record RECORD;
BEGIN

    -- Loop through all procedures in the current database
    FOR procedure_record IN
        SELECT routine_schema, routine_name
        FROM information_schema.routines
        WHERE routine_schema IN ('auth', 'data', 'general', 'log', 'meta', 'osm', 'utils', 'zzglc', 'zzgll', 'zzhistory')
          AND routine_type = 'FUNCTION'
    LOOP
        -- Build and execute dynamic SQL to set procedure owner
        RAISE NOTICE '% % %', procedure_record.routine_schema, procedure_record.routine_name, owner_name;
        EXECUTE format('ALTER FUNCTION %I.%I OWNER TO %I', procedure_record.routine_schema, procedure_record.routine_name, owner_name);
    END LOOP;
END $function$

*/
 }
/**
 * @function get_context_user_id
 * @memberof auth
 * @description Get context user id
 * @returns {uuid}
 */
function get_context_user_id() {
/*
CREATE OR REPLACE FUNCTION auth.get_context_user_id()
 RETURNS uuid
 LANGUAGE plpgsql
AS $function$ BEGIN

	
	RETURN current_setting('context.user_id', true)::UUID;

END $function$

*/
 }
/**
 * @function general_nuts_u
 * @memberof zzglc
 * @description General nuts u
 * @param {character_varying} Json
 * @returns {void}
 */
function general_nuts_u() {
/*
CREATE OR REPLACE FUNCTION zzglc.general_nuts_u("Json" character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE v_row_count INTEGER;
BEGIN

    UPDATE general.nuts t
    SET nuts_id = U.nuts_id,
        levl_code = U.levl_code,
        cntr_code = U.cntr_code,
        name_latn = U.name_latn,
        nuts_name = U.nuts_name,
        mount_type = U.mount_type,
        urbn_type = U.urbn_type,
        coast_type = U.coast_type,
        fid = U.fid,
        geom = U.geom 
    FROM json_to_record("Json"::json) AS U (
        id integer,
            nuts_id character varying,
            levl_code integer,
            cntr_code character(2),
            name_latn character varying(255),
            nuts_name character varying(255),
            mount_type integer,
            urbn_type integer,
            coast_type integer,
            fid character varying,
            geom geometry
    ) 
    WHERE U.id = t.id
;

END $function$

*/
 }
/**
 * @function auth_log_c
 * @memberof zzglc
 * @description Auth log c
 * @param {character_varying} Json
 * @returns {void}
 */
function auth_log_c() {
/*
CREATE OR REPLACE FUNCTION zzglc.auth_log_c("Json" character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

    INSERT INTO auth.log (
        person_id,
        ip
    )
    SELECT
        U.person_id,
        U.ip
    FROM
        json_to_record("Json"::json) U (
person_id integer,
            ip character varying
        ) 
;
END $function$

*/
 }
/**
 * @function create_public_context
 * @memberof auth
 * @description Create public context
 * @param {integer} PersonId
 * @param {integer} LangId
 * @returns {void}
 */
function create_public_context() {
/*
CREATE OR REPLACE FUNCTION auth.create_public_context("PersonId" integer, "LangId" integer)
 RETURNS void
 LANGUAGE plpgsql
AS $function$ BEGIN

  PERFORM set_config('context.person_id', "PersonId"::text, false);
	PERFORM set_config('context.lang_id', "LangId"::text, false);
END $function$

*/
 }
/**
 * @function data_shape_u
 * @memberof zzglc
 * @description Data shape u
 * @param {character_varying} Json
 * @returns {void}
 */
function data_shape_u() {
/*
CREATE OR REPLACE FUNCTION zzglc.data_shape_u("Json" character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE v_row_count INTEGER;
BEGIN

    UPDATE data.shape t
    SET data_source_id = U.data_source_id,
        name = U.name 
    FROM json_to_record("Json"::json) AS U (
        id integer,
            data_source_id integer,
            name character varying(255)
    ) 
    WHERE U.id = t.id
;

END $function$

*/
 }
/**
 * @function data_depth_d
 * @memberof zzglc
 * @description Data depth d
 * @param {integer} Key
 * @returns {void}
 */
function data_depth_d() {
/*
CREATE OR REPLACE FUNCTION zzglc.data_depth_d("Key" integer)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

    DELETE FROM data.depth
    WHERE id = "Key";

END $function$

*/
 }
/**
 * @function data_date_unit_c
 * @memberof zzglc
 * @description Data date unit c
 * @param {character_varying} Json
 * @returns {void}
 */
function data_date_unit_c() {
/*
CREATE OR REPLACE FUNCTION zzglc.data_date_unit_c("Json" character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

    INSERT INTO data.date_unit (
        name,
        format
    )
    SELECT
        U.name,
        U.format
    FROM
        json_to_record("Json"::json) U (
name character varying,
            format character varying
        ) 
;
END $function$

*/
 }
/**
 * @function general_nuts_l
 * @memberof zzgll
 * @description General nuts l
 * @param {character_varying} SearchValue
 * @param {integer} Key
 * @returns {Object}
 * @property {integer} id
 * @property {character_varying} nuts_id
 */
function general_nuts_l() {
/*
CREATE OR REPLACE FUNCTION zzgll.general_nuts_l("SearchValue" character varying, "Key" integer DEFAULT NULL::integer)
 RETURNS TABLE(id integer, nuts_id character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

        IF "Key" IS NOT NULL THEN
            RETURN QUERY
            SELECT t.id, t.nuts_id
            FROM general.nuts t
            WHERE t.id = "Key"::integer;
        ELSE
            RETURN QUERY
           SELECT t.id, t.nuts_id
            FROM general.nuts t
            WHERE t.nuts_id LIKE "SearchValue"
            ORDER BY t.nuts_id
           LIMIT 1000;
       END IF;
END $function$

*/
 }
/**
 * @function data_point_r
 * @memberof zzglc
 * @description Data point r
 * @returns {Object}
 * @property {integer} id
 * @property {character_varying} point_key
 * @property {double_precision} lat
 * @property {double_precision} lon
 * @property {integer} data_source_id
 * @property {integer} sample
 * @property {character_varying} notes
 * @property {integer} l3_id
 * @property {integer} elev
 * @property {character_varying} name
 * @property {double_precision} x
 * @property {double_precision} y
 * @property {character_varying} data_source_id_val
 * @property {character_varying} l3_id_val
 */
function data_point_r() {
/*
CREATE OR REPLACE FUNCTION zzglc.data_point_r()
 RETURNS TABLE(id integer, point_key character varying, lat double precision, lon double precision, data_source_id integer, sample integer, notes character varying, l3_id integer, elev integer, name character varying, x double precision, y double precision, data_source_id_val character varying, l3_id_val character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

    RETURN QUERY
    SELECT
    t.id, t.point_key, t.lat, t.lon, t.data_source_id, t.sample, t.notes, t.l3_id, t.elev, t.name, t.x, t.y
    , data_source_id_t.name::VARCHAR AS data_source_id_val, l3_id_t.nuts_id::VARCHAR AS l3_id_val
    FROM data.point t

    LEFT JOIN data.data_source data_source_id_t ON data_source_id_t.id = t.data_source_id
    LEFT JOIN general.nuts l3_id_t ON l3_id_t.id = t.l3_id
    
    ORDER BY t.point_key
;
END $function$

*/
 }
/**
 * @function meta_i18n_lang_u
 * @memberof zzglc
 * @description Meta i18n lang u
 * @param {character_varying} Json
 * @returns {void}
 */
function meta_i18n_lang_u() {
/*
CREATE OR REPLACE FUNCTION zzglc.meta_i18n_lang_u("Json" character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

	CREATE TEMP TABLE j AS 
	SELECT * FROM json_to_record("Json"::json) AS U (
        id integer,
            i18n_id integer,
            lang_id integer,
            value character varying(255)
	);

    UPDATE meta.i18n_lang t
    SET i18n_id = U.i18n_id,
        lang_id = U.lang_id,
        value = U.value 
    FROM json_to_record("Json"::json) AS U (
        id integer,
            i18n_id integer,
            lang_id integer,
            value character varying(255)
    ) 
    WHERE U.id = t.id;
		
    INSERT INTO meta.i18n_lang (i18n_id, lang_id, value)	
	SELECT i18n_id, lang_id, value FROM j WHERE id &lt; 0;
	
	DROP TABLE j;

END 
$function$

*/
 }
/**
 * @function get_indicators_table
 * @memberof data
 * @description Get indicators table
 * @param {text} Params
 * @param {integer} PersonId
 * @param {integer} LangId
 * @returns {json}
 */
function get_indicators_table() {
/*
CREATE OR REPLACE FUNCTION data.get_indicators_table("Params" text, "PersonId" integer, "LangId" integer)
 RETURNS json
 LANGUAGE plpgsql
AS $function$
BEGIN

	RETURN (
		SELECT json_agg(t.*) FROM (
			SELECT l.value Indicator, u.name unit, i.*
			FROM data.indicator i
			LEFT JOIN data.unit u ON u.id = i.unit_id
			LEFT JOIN data.indicator_lang l ON l.indicator_id = i.id AND l.lang_id = "LangId"
			ORDER BY name
		) t
	);
END $function$

*/
 }
/**
 * @function get_all_assets
 * @memberof data
 * @description Get all assets
 * @returns {Object}
 * @property {character_varying} id
 * @property {boolean} ignore
 * @property {integer} asset_catalog_id
 * @property {character_varying} title
 * @property {character_varying} description
 * @property {integer} asset_theme_id
 * @property {character_varying} keywords_list
 * @property {integer} asset_version_id
 * @property {character_varying} doi
 * @property {integer} unit_id
 * @property {character_varying} scale_factor
 * @property {integer} person_id
 * @property {character_varying} providers_list
 * @property {integer} license_id
 * @property {character_varying} constellation_list
 * @property {character_varying} platform
 * @property {character_varying} instruments_list
 * @property {character_varying} gsd
 * @property {date} start_date
 * @property {date} end_date
 * @property {integer} date_step
 * @property {character_varying} date_offset
 * @property {integer} date_unit_id
 * @property {integer} date_style_id
 * @property {boolean} ignore_29feb
 * @property {character_varying} depth_list
 * @property {character_varying} main_sld_url
 * @property {character_varying} sld_1_url
 * @property {character_varying} main_qml_url
 * @property {character_varying} main_url
 * @property {character_varying} asset_catalog_id_val
 * @property {character_varying} asset_theme_id_val
 * @property {character_varying} asset_version_id_val
 * @property {character_varying} unit_id_val
 * @property {character_varying} person_id_val
 * @property {character_varying} license_id_val
 * @property {character_varying} date_unit_id_val
 * @property {character_varying} date_style_id_val
 */
function get_all_assets() {
/*
CREATE OR REPLACE FUNCTION data.get_all_assets()
 RETURNS TABLE(id character varying, ignore boolean, asset_catalog_id integer, title character varying, description character varying, asset_theme_id integer, keywords_list character varying, asset_version_id integer, doi character varying, unit_id integer, scale_factor character varying, person_id integer, providers_list character varying, license_id integer, constellation_list character varying, platform character varying, instruments_list character varying, gsd character varying, start_date date, end_date date, date_step integer, date_offset character varying, date_unit_id integer, date_style_id integer, ignore_29feb boolean, depth_list character varying, main_sld_url character varying, sld_1_url character varying, main_qml_url character varying, main_url character varying, asset_catalog_id_val character varying, asset_theme_id_val character varying, asset_version_id_val character varying, unit_id_val character varying, person_id_val character varying, license_id_val character varying, date_unit_id_val character varying, date_style_id_val character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

    RETURN QUERY
    SELECT
    t.orig_id, t.ignore, t.asset_catalog_id, t.title, t.description, t.asset_theme_id, t.keywords_list, t.asset_version_id, t.doi, t.unit_id, t.scale_factor, t.person_id, t.providers_list, t.license_id, t.constellation_list, t.platform, t.instruments_list, t.gsd, t.start_date, t.end_date, t.date_step, t.date_offset, t.date_unit_id, t.date_style_id, t.ignore_29feb, t.depth_list, t.main_sld_url, t.sld_1_url, t.main_qml_url, t.main_url
    , asset_catalog_id_t.name::VARCHAR AS asset_catalog_id_val, asset_theme_id_t.name::VARCHAR AS asset_theme_id_val, asset_version_id_t.name::VARCHAR AS asset_version_id_val, unit_id_t.name::VARCHAR AS unit_id_val, person_id_t.name::VARCHAR AS person_id_val, license_id_t.name::VARCHAR AS license_id_val, date_unit_id_t.name::VARCHAR AS date_unit_id_val, date_style_id_t.name::VARCHAR AS date_style_id_val
    FROM data.asset t
    LEFT JOIN data.asset_catalog asset_catalog_id_t ON asset_catalog_id_t.id = t.asset_catalog_id
    LEFT JOIN data.asset_theme asset_theme_id_t ON asset_theme_id_t.id = t.asset_theme_id
    LEFT JOIN data.asset_version asset_version_id_t ON asset_version_id_t.id = t.asset_version_id
    LEFT JOIN data.unit unit_id_t ON unit_id_t.id = t.unit_id
    LEFT JOIN general.person person_id_t ON person_id_t.id = t.person_id
    LEFT JOIN data.license license_id_t ON license_id_t.id = t.license_id
    LEFT JOIN data.date_unit date_unit_id_t ON date_unit_id_t.id = t.date_unit_id
    LEFT JOIN data.date_style date_style_id_t ON date_style_id_t.id = t.date_style_id
;
END $function$

*/
 }
/**
 * @function meta_lang_c
 * @memberof zzglc
 * @description Meta lang c
 * @param {character_varying} Json
 * @returns {integer}
 */
function meta_lang_c() {
/*
CREATE OR REPLACE FUNCTION zzglc.meta_lang_c("Json" character varying)
 RETURNS integer
 LANGUAGE plpgsql
AS $function$
   DECLARE v_id integer;
BEGIN

    INSERT INTO meta.lang (
        id,
        name,
        tag,
        short_tag
    )
    SELECT
        U.id,
        U.name,
        U.tag,
        U.short_tag
    FROM
        json_to_record("Json"::json) U (
id integer,
            name character varying(255),
            tag character varying(15),
            short_tag character(2)
        ) 
    RETURNING id INTO v_id;

    RETURN v_id;
END $function$

*/
 }
/**
 * @function get_lang
 * @memberof meta
 * @description Get lang
 * @param {character_varying} SearchValue
 * @param {integer} Key
 * @returns {Object}
 * @property {integer} id
 * @property {character_varying} name
 * @property {character_varying} short_tag
 */
function get_lang() {
/*
CREATE OR REPLACE FUNCTION meta.get_lang("SearchValue" character varying, "Key" integer)
 RETURNS TABLE(id integer, name character varying, short_tag character varying)
 LANGUAGE plpgsql
AS $function$

	BEGIN

	-- Routine body goes here...
	RETURN QUERY 
		SELECT l.id, l.name, l.short_tag::VARCHAR
		FROM meta.lang l
		WHERE l.name like "SearchValue"
		ORDER BY l.name;
END
$function$

*/
 }
/**
 * @function data_license_l
 * @memberof zzgll
 * @description Data license l
 * @param {character_varying} SearchValue
 * @param {integer} Key
 * @returns {Object}
 * @property {integer} id
 * @property {character_varying} name
 */
function data_license_l() {
/*
CREATE OR REPLACE FUNCTION zzgll.data_license_l("SearchValue" character varying, "Key" integer DEFAULT NULL::integer)
 RETURNS TABLE(id integer, name character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

        IF "Key" IS NOT NULL THEN
            RETURN QUERY
            SELECT t.id, t.name
            FROM data.license t
            WHERE t.id = "Key"::integer;
        ELSE
            RETURN QUERY
           SELECT t.id, t.name
            FROM data.license t
            WHERE t.name LIKE "SearchValue"
            ORDER BY t.name
           LIMIT 1000;
       END IF;
END $function$

*/
 }
/**
 * @function data_lu_detail_l
 * @memberof zzgll
 * @description Data lu detail l
 * @param {character_varying} SearchValue
 * @param {integer} Key
 * @returns {Object}
 * @property {integer} id
 * @property {character_varying} name
 */
function data_lu_detail_l() {
/*
CREATE OR REPLACE FUNCTION zzgll.data_lu_detail_l("SearchValue" character varying, "Key" integer DEFAULT NULL::integer)
 RETURNS TABLE(id integer, name character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

        IF "Key" IS NOT NULL THEN
            RETURN QUERY
            SELECT t.id, t.name
            FROM data.lu_detail t
            WHERE t.id = "Key"::integer;
        ELSE
            RETURN QUERY
           SELECT t.id, t.name
            FROM data.lu_detail t
            WHERE t.name LIKE "SearchValue"
            ORDER BY t.name
           LIMIT 1000;
       END IF;
END $function$

*/
 }
/**
 * @function function_exists
 * @memberof meta
 * @description Function exists
 * @param {character_varying} schema_name
 * @param {character_varying} func_name
 * @returns {boolean}
 */
function function_exists() {
/*
CREATE OR REPLACE FUNCTION meta.function_exists(schema_name character varying, func_name character varying)
 RETURNS boolean
 LANGUAGE plpgsql
AS $function$
DECLARE
    result BOOLEAN;
BEGIN

    SELECT EXISTS (
        SELECT 1 
        FROM pg_proc 
        JOIN pg_namespace ns ON pg_proc.pronamespace = ns.oid
        WHERE ns.nspname = schema_name
        AND proname = func_name
    ) INTO result;
    
    RETURN result;
END;
$function$

*/
 }
/**
 * @function data_shape_geometry_u
 * @memberof zzglc
 * @description Data shape geometry u
 * @param {character_varying} Json
 * @returns {void}
 */
function data_shape_geometry_u() {
/*
CREATE OR REPLACE FUNCTION zzglc.data_shape_geometry_u("Json" character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE v_row_count INTEGER;
BEGIN

    UPDATE data.shape_geometry t
    SET shape_id = U.shape_id,
        properties = U.properties,
        geom = U.geom 
    FROM json_to_record("Json"::json) AS U (
        id integer,
            shape_id integer,
            properties json,
            geom geometry
    ) 
    WHERE U.id = t.id
;

END $function$

*/
 }
/**
 * @function data_geometry_type_l
 * @memberof zzgll
 * @description Data geometry type l
 * @param {character_varying} SearchValue
 * @param {integer} Key
 * @returns {Object}
 * @property {integer} id
 * @property {character_varying} name
 */
function data_geometry_type_l() {
/*
CREATE OR REPLACE FUNCTION zzgll.data_geometry_type_l("SearchValue" character varying, "Key" integer DEFAULT NULL::integer)
 RETURNS TABLE(id integer, name character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

        IF "Key" IS NOT NULL THEN
            RETURN QUERY
            SELECT t.id, t.name
            FROM data.geometry_type t
            WHERE t.id = "Key"::integer;
        ELSE
            RETURN QUERY
           SELECT t.id, t.name
            FROM data.geometry_type t
            WHERE t.name LIKE "SearchValue"
            ORDER BY t.name
           LIMIT 1000;
       END IF;
END $function$

*/
 }
/**
 * @function add_update_time_modified_trigger
 * @memberof meta
 * @description Add update time modified trigger
 * @param {character_varying} SchemaName
 * @param {character_varying} TableName
 * @returns {void}
 */
function add_update_time_modified_trigger() {
/*
CREATE OR REPLACE FUNCTION meta.add_update_time_modified_trigger("SchemaName" character varying, "TableName" character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

	EXECUTE '
	CREATE OR REPLACE TRIGGER ' || "TableName" || '_ttrig
	BEFORE INSERT OR UPDATE
	ON ' || "SchemaName" || '.' || "TableName" || '
	FOR EACH ROW
		EXECUTE PROCEDURE meta.update_time_modified()
	';
END $function$

*/
 }
/**
 * @function save_message
 * @memberof general
 * @description Save message
 * @param {integer} PersonId
 * @param {text} Message
 * @param {integer} ParentId
 * @returns {integer}
 */
function save_message() {
/*
CREATE OR REPLACE FUNCTION general.save_message("PersonId" integer, "Message" text, "ParentId" integer)
 RETURNS integer
 LANGUAGE plpgsql
AS $function$
	DECLARE v_id INT;
BEGIN

	-- Routine body goes here...
  INSERT INTO general.message (person_id, message, parent_id)
	VALUES ("PersonId", "Message", "ParentId")
	RETURNING id INTO v_id
	;
	RETURN v_id;
END$function$

*/
 }
/**
 * @function import_croatia
 * @memberof data
 * @description Import croatia
 * @param {text} jsonCV
 * @param {text} jsonData
 * @returns {void}
 */
function import_croatia() {
/*
CREATE OR REPLACE FUNCTION data.import_croatia("jsonCV" text, "jsonData" text)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

DROP TABLE IF EXISTS t;
CREATE TEMP TABLE t AS
SELECT * FROM json_to_recordset("jsonData"::json) AS J(
"Year" varchar, "Datex" varchar, "depth" varchar, "pH" varchar, "EC (mS/m)" varchar, "point_key" varchar, "y" varchar, "x" varchar, "date" varchar);

WITH x AS (SELECT DISTINCT t."depth" FROM  t)
INSERT INTO data.depth(name)
SELECT meta.clean_value(x."depth", 'varchar')::varchar FROM x
LEFT JOIN data.depth depth ON depth.name= x."depth"
WHERE depth.id IS NULL;

WITH x AS (SELECT DISTINCT t."point_key", t."y", t."x" FROM  t)
INSERT INTO data.point(point_key, x, y, name, data_source_id)
SELECT meta.clean_value(x."point_key", 'varchar')::varchar, meta.clean_value(x."y", 'double precision')::double precision, meta.clean_value(x."x", 'double precision')::double precision, 'Glog', 4 FROM x
LEFT JOIN data.point point ON point.point_key= x."point_key"
WHERE point.id IS NULL;

INSERT INTO data.measurement(point_id, indicator_id, depth_id, value, date, data_source_id)
SELECT x.id, i.id, d.id, meta.clean_value(t."pH", 'double precision')::double precision, meta.clean_value(t.date, 'date')::date, 4 FROM t
LEFT JOIN data.point x ON x.point_key = t."point_key"
 left join data.indicator i on i.name_match = 'pHe' left join data.measurement y on y.point_id = x.id and y.indicator_id = i.id and y.date = meta.clean_value(t.date, 'date')::date left join data.depth d on d.name = t.depth
WHERE y.id IS NULL AND meta.clean_value(t."pH", 'double precision')::double precision IS NOT NULL ;

INSERT INTO data.measurement(point_id, indicator_id, depth_id, value, date, data_source_id)
SELECT x.id, i.id, d.id, meta.clean_value(t."EC (mS/m)", 'double precision')::double precision, meta.clean_value(t.date, 'date')::date, 4 FROM t
LEFT JOIN data.point x ON x.point_key = t."point_key"
 left join data.indicator i on i.name_match = 'ECe' left join data.measurement y on y.point_id = x.id and y.indicator_id = i.id and y.date = meta.clean_value(t.date, 'date')::date left join data.depth d on d.name = t.depth
WHERE y.id IS NULL AND meta.clean_value(t."EC (mS/m)", 'double precision')::double precision IS NOT NULL ;

END $function$

*/
 }
/**
 * @function get_catalogs
 * @memberof data
 * @description Get catalogs
 * @param {integer} LangId
 * @returns {json}
 */
function get_catalogs() {
/*
CREATE OR REPLACE FUNCTION data.get_catalogs("LangId" integer)
 RETURNS json
 LANGUAGE plpgsql
AS $function$
BEGIN

RETURN (
	SELECT json_build_object(
	'aiModels', (SELECT json_agg(t.*) FROM (SELECT id value, name label FROM general.ai_model ORDER BY 2) t),
	'srids' , (SELECT '[3857, 3035]'::json),
	'dataSources', (SELECT json_agg(t.*) FROM (SELECT id value, name label FROM data.data_source) t),
	'descriptions', (SELECT json_agg(t.*) 
		 FROM (SELECT indicator_id, description_id value, name label 
			FROM data.attribute_description ORDER by 1, 3)
		 t),
	'properties', (SELECT json_agg(t.*) 
		 FROM (SELECT p.id, p.name, p.indicator_id, u.name unit, p.data_type_id, i.numerical
			FROM data.property p
			LEFT JOIN data.indicator i on i.id = p.indicator_id
			LEFT JOIN data.unit u ON u.id = p.unit_id)
		 t)
	)
);
END $function$

*/
 }
/**
 * @function meta_table_ref_col_d
 * @memberof zzglc
 * @description Meta table ref col d
 * @param {integer} Key
 * @returns {void}
 */
function meta_table_ref_col_d() {
/*
CREATE OR REPLACE FUNCTION zzglc.meta_table_ref_col_d("Key" integer)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

    DELETE FROM meta.table_ref_col
    WHERE id = "Key";

END $function$

*/
 }
/**
 * @function general_nuts_r
 * @memberof zzglc
 * @description General nuts r
 * @returns {Object}
 * @property {integer} id
 * @property {character_varying} nuts_id
 * @property {integer} levl_code
 * @property {character} cntr_code
 * @property {character_varying} name_latn
 * @property {character_varying} nuts_name
 * @property {integer} mount_type
 * @property {integer} urbn_type
 * @property {integer} coast_type
 * @property {character_varying} fid
 */
function general_nuts_r() {
/*
CREATE OR REPLACE FUNCTION zzglc.general_nuts_r()
 RETURNS TABLE(id integer, nuts_id character varying, levl_code integer, cntr_code character, name_latn character varying, nuts_name character varying, mount_type integer, urbn_type integer, coast_type integer, fid character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

    RETURN QUERY
    SELECT
    t.id, t.nuts_id, t.levl_code, t.cntr_code, t.name_latn, t.nuts_name, t.mount_type, t.urbn_type, t.coast_type, t.fid
    FROM general.nuts t
;
END $function$

*/
 }
/**
 * @function crud
 * @memberof meta
 * @description Crud
 * @param {character_varying} schema_name
 * @param {character_varying} table_name
 * @returns {void}
 */
function crud() {
/*
CREATE OR REPLACE FUNCTION meta.crud(schema_name character varying, table_name character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE
    col_name VARCHAR;
		col_type VARCHAR;
		table_list VARCHAR := '';
    column_list VARCHAR := '';
		select_column_list VARCHAR := '';
    column_value_list VARCHAR := '';
		update_list VARCHAR := '';
		ref_col_list VARCHAR := '';
		ref_val_list VARCHAR := '';
		join_list VARCHAR := '';
		ref_schema_name VARCHAR;
		ref_table_name VARCHAR;
		ref_col_name VARCHAR;
		ref_disp_col_name VARCHAR := '';
    pk_column VARCHAR;
		pk_type VARCHAR;
    json_keys VARCHAR;
    json_values VARCHAR;
		sql VARCHAR;
BEGIN

		DROP TABLE IF EXISTS x;
		CREATE TEMP TABLE x AS
		SELECT * FROM meta.get_table_cols(schema_name, table_name);
		
		SELECT column_name, data_type INTO pk_column, pk_type
		FROM x WHERE ordinal_number = 1;

    -- Construct column list for INSERT and UPDATE statements
    FOR col_name, col_type IN
        SELECT column_name, data_type FROM x
    LOOP
				select_column_list := select_column_list || 't.' || col_name || ', ';
				table_list := table_list || col_name || ' ' || col_type || ', ';
        IF col_name != pk_column THEN
            column_list := column_list || col_name || ', ';
            column_value_list := column_value_list || '(json_data->>' || QUOTE_LITERAL(col_name) || ')::' || col_type || ', ';
						update_list :=  update_list || E'\n        ' || col_name || ' = (json_data->>' || QUOTE_LITERAL(col_name) || ')::' || col_type || ', ';
        END IF;
    END LOOP;
		
		FOR ref_schema_name, ref_table_name, ref_col_name, col_name, ref_disp_col_name, col_type IN
    SELECT referenced_schema_name, referenced_table_name, referenced_column_name, column_name, referenced_display_column_name, data_type
		FROM x WHERE x.referenced_column_name IS NOT NULL
    LOOP
			ref_col_list := ref_col_list || ', ' || col_name || '_val VARCHAR';
			ref_val_list := ref_val_list || ', ' || col_name || '.' || ref_disp_col_name;
			join_list := join_list || E'\n        LEFT JOIN ' 
			|| ref_schema_name || '.' || ref_table_name || ' ' || col_name 
			|| ' ON ' || col_name || '.' || ref_col_name || ' = t.' || col_name;
			RAISE NOTICE '% % % % %', 'Creating lookup', ref_schema_name, ref_table_name, ref_disp_col_name, col_type;
			PERFORM meta.lookup(ref_schema_name, ref_table_name, ref_disp_col_name, col_type);
    END LOOP;

		-- Remove trailing commas
		select_column_list := SUBSTRING(select_column_list FROM 1 FOR LENGTH(select_column_list) - 2);
		table_list := SUBSTRING(table_list FROM 1 FOR LENGTH(table_list) - 2);
    column_list := SUBSTRING(column_list FROM 1 FOR LENGTH(column_list) - 2);
    column_value_list := SUBSTRING(column_value_list FROM 1 FOR LENGTH(column_value_list) - 2);
		update_list := SUBSTRING(update_list FROM 1 FOR LENGTH(update_list) - 2);
		
		-- Create SELECT function
    sql := '
		DROP FUNCTION IF EXISTS zzglc.' || schema_name || '_' || table_name || '_r;
		CREATE OR REPLACE FUNCTION zzglc.' || schema_name || '_' || table_name || '_r ()
    RETURNS TABLE (' || table_list || ref_col_list || ') AS $F$
    BEGIN
				RETURN QUERY (
        SELECT ' || select_column_list || ref_val_list || '
        FROM ' || schema_name || '.' || table_name || ' t ' || join_list || '
				);
    END $F$ LANGUAGE plpgsql;';
		
		--RAISE NOTICE '%', sql;
		EXECUTE sql;
		
		-- Create INSERT function
    sql := '
		DROP FUNCTION IF EXISTS zzglc.' || schema_name || '_' || table_name || '_c;
		CREATE OR REPLACE FUNCTION zzglc.' || schema_name || '_' || table_name || '_c ("Json" varchar)
    RETURNS ' || pk_type || ' AS $F$
		DECLARE v_id ' || pk_type || ';
    DECLARE json_data json;
    BEGIN
			  json_data := "Json";
        INSERT INTO ' || schema_name || '.' || table_name || ' (' || column_list || ') 
        VALUES (' || column_value_list || ')
        RETURNING id INTO v_id;
        RETURN v_id;
    END $F$ LANGUAGE plpgsql;';
		
		--RAISE NOTICE '%', sql;
		EXECUTE sql;
				
		-- Create UPDATE function
    sql := '
    DROP FUNCTION IF EXISTS zzglc.' || schema_name || '_' || table_name || '_u;
    CREATE OR REPLACE FUNCTION zzglc.' || schema_name || '_' || table_name || '_u ("Json" varchar)
    RETURNS VOID AS $F$
    DECLARE json_data json;
    BEGIN
			 json_data := "Json";
        UPDATE ' || schema_name || '.' || table_name || ' SET' || update_list || '
        WHERE ' || pk_column || ' = (json_data->>' || QUOTE_LITERAL(pk_column) || ')::' || pk_type || '; 
    END $F$ LANGUAGE plpgsql;';
		
		--RAISE NOTICE '%', sql;	
		EXECUTE sql;
		
    -- Create DELETE function
    sql := '
		DROP FUNCTION IF EXISTS zzglc.' || schema_name || '_' || table_name || '_d;
		CREATE OR REPLACE FUNCTION zzglc.' || schema_name || '_' || table_name || '_d 
		( "Key" ' || pk_type || ')
    RETURNS VOID AS $F$
    BEGIN
        DELETE FROM ' || schema_name || '.' || table_name || ' WHERE ' || pk_column || ' = "Key"; 
    END;
    $F$ LANGUAGE plpgsql;';
		
		RAISE NOTICE '%', sql;
		EXECUTE sql;
		
END $function$

*/
 }
/**
 * @function general_boundary_u
 * @memberof zzglc
 * @description General boundary u
 * @param {character_varying} Json
 * @returns {void}
 */
function general_boundary_u() {
/*
CREATE OR REPLACE FUNCTION zzglc.general_boundary_u("Json" character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE v_row_count INTEGER;
BEGIN

    UPDATE general.boundary t
    SET osm_id = U.osm_id,
        admin_level = U.admin_level,
        name = U.name,
        local_name = U.local_name,
        geom = U.geom 
    FROM json_to_record("Json"::json) AS U (
        id integer,
            osm_id integer,
            admin_level integer,
            name character varying(255),
            local_name character varying(255),
            geom geometry(MultiPolygon,3035)
    ) 
    WHERE U.id = t.id
;

END $function$

*/
 }
/**
 * @function auth_route_role_public_c
 * @memberof zzglc
 * @description Auth route role public c
 * @param {character_varying} Json
 * @returns {integer}
 */
function auth_route_role_public_c() {
/*
CREATE OR REPLACE FUNCTION zzglc.auth_route_role_public_c("Json" character varying)
 RETURNS integer
 LANGUAGE plpgsql
AS $function$
   DECLARE v_id integer;
BEGIN

    INSERT INTO auth.route_role_public (
        route_id,
        role_public_id
    )
    SELECT
        U.route_id,
        U.role_public_id
    FROM
        json_to_record("Json"::json) U (
route_id integer,
            role_public_id integer
        ) 
    RETURNING id INTO v_id;

    RETURN v_id;
END $function$

*/
 }
/**
 * @function data_indicator_color_u
 * @memberof zzglc
 * @description Data indicator color u
 * @param {character_varying} Json
 * @returns {void}
 */
function data_indicator_color_u() {
/*
CREATE OR REPLACE FUNCTION zzglc.data_indicator_color_u("Json" character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE v_row_count INTEGER;
BEGIN

    UPDATE data.indicator_color t
    SET indicator_id = U.indicator_id,
        value_to = U.value_to,
        color_id = U.color_id 
    FROM json_to_record("Json"::json) AS U (
        id integer,
            indicator_id integer,
            value_to real,
            color_id integer
    ) 
    WHERE U.id = t.id
;

END $function$

*/
 }
/**
 * @function meta_lang_l
 * @memberof zzgll
 * @description Meta lang l
 * @param {character_varying} SearchValue
 * @param {integer} Key
 * @returns {Object}
 * @property {integer} id
 * @property {character_varying} name
 */
function meta_lang_l() {
/*
CREATE OR REPLACE FUNCTION zzgll.meta_lang_l("SearchValue" character varying, "Key" integer DEFAULT NULL::integer)
 RETURNS TABLE(id integer, name character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

        IF "Key" IS NOT NULL THEN
            RETURN QUERY
            SELECT t.id, t.name
            FROM meta.lang t
            WHERE t.id = "Key"::integer;
        ELSE
            RETURN QUERY
           SELECT t.id, t.name
            FROM meta.lang t
            WHERE t.name LIKE "SearchValue"
            ORDER BY t.name
           LIMIT 1000;
       END IF;
END $function$

*/
 }
/**
 * @function log_errors_r
 * @memberof zzglc
 * @description Log errors r
 * @returns {Object}
 * @property {integer} id
 * @property {character_varying} message
 * @property {character_varying} level
 * @property {timestamp_without_time_zone} time_stamp
 * @property {character_varying} exception
 * @property {character_varying} log_event
 * @property {integer} tenant_id
 * @property {uuid} user_id
 * @property {integer} app_id
 * @property {timestamp_without_time_zone} time_modified
 */
function log_errors_r() {
/*
CREATE OR REPLACE FUNCTION zzglc.log_errors_r()
 RETURNS TABLE(id integer, message character varying, level character varying, time_stamp timestamp without time zone, exception character varying, log_event character varying, tenant_id integer, user_id uuid, app_id integer, time_modified timestamp without time zone)
 LANGUAGE plpgsql
AS $function$
BEGIN

    RETURN QUERY
    SELECT
    t.id, t.message, t.level, t.time_stamp, t.exception, t.log_event, t.tenant_id, t.user_id, t.app_id, t.time_modified
    FROM log.errors t
;
END $function$

*/
 }
/**
 * @function data_lc_detail_d
 * @memberof zzglc
 * @description Data lc detail d
 * @param {integer} Key
 * @returns {void}
 */
function data_lc_detail_d() {
/*
CREATE OR REPLACE FUNCTION zzglc.data_lc_detail_d("Key" integer)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

    DELETE FROM data.lc_detail
    WHERE id = "Key";

END $function$

*/
 }
/**
 * @function data_point_u
 * @memberof zzglc
 * @description Data point u
 * @param {character_varying} Json
 * @returns {void}
 */
function data_point_u() {
/*
CREATE OR REPLACE FUNCTION zzglc.data_point_u("Json" character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE v_row_count INTEGER;
BEGIN

    UPDATE data.point t
    SET point_key = U.point_key,
        lat = U.lat,
        lon = U.lon,
        data_source_id = U.data_source_id,
        sample = U.sample,
        notes = U.notes,
        l3_id = U.l3_id,
        elev = U.elev,
        name = U.name,
        x = U.x,
        y = U.y 
    FROM json_to_record("Json"::json) AS U (
        id integer,
            point_key character varying(255),
            lat double precision,
            lon double precision,
            data_source_id integer,
            sample integer,
            notes character varying(255),
            l3_id integer,
            elev integer,
            name character varying(255),
            x double precision,
            y double precision
    ) 
    WHERE U.id = t.id
;

END $function$

*/
 }
/**
 * @function meta_import_master_d
 * @memberof zzglc
 * @description Meta import master d
 * @param {integer} Key
 * @returns {void}
 */
function meta_import_master_d() {
/*
CREATE OR REPLACE FUNCTION zzglc.meta_import_master_d("Key" integer)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

    DELETE FROM meta.import_master
    WHERE id = "Key";

END $function$

*/
 }
/**
 * @function import_temp
 * @memberof data
 * @description Import temp
 * @param {text} jsonCV
 * @param {text} jsonData
 * @returns {void}
 */
function import_temp() {
/*
CREATE OR REPLACE FUNCTION data.import_temp("jsonCV" text, "jsonData" text)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

DROP TABLE IF EXISTS t;
CREATE TEMP TABLE t AS
SELECT * FROM json_to_recordset("jsonData"::json) AS J(
"Point_ID" varchar, "Revisited_point" varchar, "Coarse" varchar, "Clay" varchar, "Sand" varchar, "Silt" varchar, "pH_CaCl2" varchar, "pH_H2O" varchar, "EC" varchar, "OC" varchar, "CaCO3" varchar, "P" varchar, "N" varchar, "K" varchar, "Elevation" varchar, "LC1" varchar, "LU1" varchar, "Soil_Stones" varchar, "NUTS_0" varchar, "NUTS_1" varchar, "NUTS_2" varchar, "NUTS_3" varchar, "LC1_Desc" varchar, "LU1_Desc" varchar);

WITH x AS (SELECT DISTINCT t."Point_ID", t."Revisited_point", t."Coarse", t."Clay", t."Sand", t."Silt", t."pH_CaCl2", t."pH_H2O", t."EC", t."OC", t."CaCO3", t."P", t."N", t."K", t."Elevation", t."LC1", t."LU1", t."Soil_Stones", t."NUTS_0", t."NUTS_1", t."NUTS_2", t."NUTS_3", t."LC1_Desc", t."LU1_Desc" FROM  t)
INSERT INTO data.temp(point_id, revisited_point, coarse, clay, sand, silt, p_h_ca_cl_2, p_h_h2o, ec, oc, ca_co3, p, n, k, elevation, lc1, lu1, soil_stones, nuts_0, nuts_1, nuts_2, nuts_3, lc1_desc, lu1_desc)
SELECT meta.clean_value(x."Point_ID", 'varchar')::varchar, meta.clean_value(x."Revisited_point", 'varchar')::varchar, meta.clean_value(x."Coarse", 'varchar')::varchar, meta.clean_value(x."Clay", 'varchar')::varchar, meta.clean_value(x."Sand", 'varchar')::varchar, meta.clean_value(x."Silt", 'varchar')::varchar, meta.clean_value(x."pH_CaCl2", 'varchar')::varchar, meta.clean_value(x."pH_H2O", 'varchar')::varchar, meta.clean_value(x."EC", 'varchar')::varchar, meta.clean_value(x."OC", 'varchar')::varchar, meta.clean_value(x."CaCO3", 'varchar')::varchar, meta.clean_value(x."P", 'varchar')::varchar, meta.clean_value(x."N", 'varchar')::varchar, meta.clean_value(x."K", 'varchar')::varchar, meta.clean_value(x."Elevation", 'varchar')::varchar, meta.clean_value(x."LC1", 'varchar')::varchar, meta.clean_value(x."LU1", 'varchar')::varchar, meta.clean_value(x."Soil_Stones", 'varchar')::varchar, meta.clean_value(x."NUTS_0", 'varchar')::varchar, meta.clean_value(x."NUTS_1", 'varchar')::varchar, meta.clean_value(x."NUTS_2", 'varchar')::varchar, meta.clean_value(x."NUTS_3", 'varchar')::varchar, meta.clean_value(x."LC1_Desc", 'varchar')::varchar, meta.clean_value(x."LU1_Desc", 'varchar')::varchar FROM x
LEFT JOIN data.temp temp ON temp.point_id= x."Point_ID"
WHERE temp.id IS NULL;

END $function$

*/
 }
/**
 * @function meta_table_ref_col_r
 * @memberof zzglc
 * @description Meta table ref col r
 * @returns {Object}
 * @property {integer} id
 * @property {character_varying} schema_name
 * @property {character_varying} table_name
 * @property {character_varying} ref_col
 */
function meta_table_ref_col_r() {
/*
CREATE OR REPLACE FUNCTION zzglc.meta_table_ref_col_r()
 RETURNS TABLE(id integer, schema_name character varying, table_name character varying, ref_col character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

    RETURN QUERY
    SELECT
    t.id, t.schema_name, t.table_name, t.ref_col
     FROM meta.table_ref_col t
;
END $function$

*/
 }
/**
 * @function data_asset_r
 * @memberof zzglc
 * @description Data asset r
 * @returns {Object}
 * @property {integer} id
 * @property {character_varying} orig_id
 * @property {boolean} ignore
 * @property {integer} asset_catalog_id
 * @property {character_varying} title
 * @property {character_varying} description
 * @property {integer} asset_theme_id
 * @property {character_varying} keywords_list
 * @property {integer} asset_version_id
 * @property {character_varying} doi
 * @property {integer} unit_id
 * @property {character_varying} scale_factor
 * @property {integer} person_id
 * @property {character_varying} providers_list
 * @property {integer} license_id
 * @property {character_varying} constellation_list
 * @property {character_varying} platform
 * @property {character_varying} instruments_list
 * @property {character_varying} gsd
 * @property {date} start_date
 * @property {date} end_date
 * @property {integer} date_step
 * @property {character_varying} date_offset
 * @property {integer} date_unit_id
 * @property {integer} date_style_id
 * @property {boolean} ignore_29feb
 * @property {character_varying} depth_list
 * @property {character_varying} main_sld_url
 * @property {character_varying} sld_1_url
 * @property {character_varying} main_qml_url
 * @property {character_varying} main_url
 * @property {character_varying} color_map
 * @property {integer} no_data
 * @property {integer} decimals
 * @property {integer} indicator_id
 * @property {character_varying} asset_catalog_id_val
 * @property {character_varying} asset_theme_id_val
 * @property {character_varying} asset_version_id_val
 * @property {character_varying} unit_id_val
 * @property {character_varying} person_id_val
 * @property {character_varying} license_id_val
 * @property {character_varying} date_unit_id_val
 * @property {character_varying} date_style_id_val
 * @property {character_varying} indicator_id_val
 */
function data_asset_r() {
/*
CREATE OR REPLACE FUNCTION zzglc.data_asset_r()
 RETURNS TABLE(id integer, orig_id character varying, ignore boolean, asset_catalog_id integer, title character varying, description character varying, asset_theme_id integer, keywords_list character varying, asset_version_id integer, doi character varying, unit_id integer, scale_factor character varying, person_id integer, providers_list character varying, license_id integer, constellation_list character varying, platform character varying, instruments_list character varying, gsd character varying, start_date date, end_date date, date_step integer, date_offset character varying, date_unit_id integer, date_style_id integer, ignore_29feb boolean, depth_list character varying, main_sld_url character varying, sld_1_url character varying, main_qml_url character varying, main_url character varying, color_map character varying, no_data integer, decimals integer, indicator_id integer, asset_catalog_id_val character varying, asset_theme_id_val character varying, asset_version_id_val character varying, unit_id_val character varying, person_id_val character varying, license_id_val character varying, date_unit_id_val character varying, date_style_id_val character varying, indicator_id_val character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

    RETURN QUERY
    SELECT
    t.id, t.orig_id, t.ignore, t.asset_catalog_id, t.title, t.description, t.asset_theme_id, t.keywords_list, t.asset_version_id, t.doi, t.unit_id, t.scale_factor, t.person_id, t.providers_list, t.license_id, t.constellation_list, t.platform, t.instruments_list, t.gsd, t.start_date, t.end_date, t.date_step, t.date_offset, t.date_unit_id, t.date_style_id, t.ignore_29feb, t.depth_list, t.main_sld_url, t.sld_1_url, t.main_qml_url, t.main_url, t.color_map, t.no_data, t.decimals, t.indicator_id
    , asset_catalog_id_t.name::VARCHAR AS asset_catalog_id_val, asset_theme_id_t.name::VARCHAR AS asset_theme_id_val, asset_version_id_t.name::VARCHAR AS asset_version_id_val, unit_id_t.name::VARCHAR AS unit_id_val, person_id_t.name::VARCHAR AS person_id_val, license_id_t.name::VARCHAR AS license_id_val, date_unit_id_t.name::VARCHAR AS date_unit_id_val, date_style_id_t.name::VARCHAR AS date_style_id_val, indicator_id_t.name::VARCHAR AS indicator_id_val
    FROM data.asset t

    LEFT JOIN data.asset_catalog asset_catalog_id_t ON asset_catalog_id_t.id = t.asset_catalog_id
    LEFT JOIN data.asset_theme asset_theme_id_t ON asset_theme_id_t.id = t.asset_theme_id
    LEFT JOIN data.asset_version asset_version_id_t ON asset_version_id_t.id = t.asset_version_id
    LEFT JOIN data.unit unit_id_t ON unit_id_t.id = t.unit_id
    LEFT JOIN general.person person_id_t ON person_id_t.id = t.person_id
    LEFT JOIN data.license license_id_t ON license_id_t.id = t.license_id
    LEFT JOIN data.date_unit date_unit_id_t ON date_unit_id_t.id = t.date_unit_id
    LEFT JOIN data.date_style date_style_id_t ON date_style_id_t.id = t.date_style_id
    LEFT JOIN data.indicator indicator_id_t ON indicator_id_t.id = t.indicator_id
    
    ORDER BY t.orig_id
;
END $function$

*/
 }
/**
 * @function general_country_c
 * @memberof zzglc
 * @description General country c
 * @param {character_varying} Json
 * @returns {void}
 */
function general_country_c() {
/*
CREATE OR REPLACE FUNCTION zzglc.general_country_c("Json" character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

    INSERT INTO general.country (
        name,
        code,
        region_id,
        sub_region_id,
        osm_id
    )
    SELECT
        U.name,
        U.code,
        U.region_id,
        U.sub_region_id,
        U.osm_id
    FROM
        json_to_record("Json"::json) U (
            name character varying,
            code character,
            region_id integer,
            sub_region_id integer,
            osm_id integer
        ) 
;
END $function$

*/
 }
/**
 * @function data_data_source_c
 * @memberof zzglc
 * @description Data data source c
 * @param {character_varying} Json
 * @returns {void}
 */
function data_data_source_c() {
/*
CREATE OR REPLACE FUNCTION zzglc.data_data_source_c("Json" character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

    INSERT INTO data.data_source (
        name,
        srid
    )
    SELECT
        U.name,
        U.srid
    FROM
        json_to_record("Json"::json) U (
name character varying(255),
            srid integer
        ) 
;
END $function$

*/
 }
/**
 * @function data_asset_theme_l
 * @memberof zzgll
 * @description Data asset theme l
 * @param {character_varying} SearchValue
 * @param {integer} Key
 * @returns {Object}
 * @property {integer} id
 * @property {character_varying} name
 */
function data_asset_theme_l() {
/*
CREATE OR REPLACE FUNCTION zzgll.data_asset_theme_l("SearchValue" character varying, "Key" integer DEFAULT NULL::integer)
 RETURNS TABLE(id integer, name character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

        IF "Key" IS NOT NULL THEN
            RETURN QUERY
            SELECT t.id, t.name
            FROM data.asset_theme t
            WHERE t.id = "Key"::integer;
        ELSE
            RETURN QUERY
           SELECT t.id, t.name
            FROM data.asset_theme t
            WHERE t.name LIKE "SearchValue"
            ORDER BY t.name
           LIMIT 1000;
       END IF;
END $function$

*/
 }
/**
 * @function add_timestamp_column
 * @memberof meta
 * @description Add timestamp column
 * @param {character_varying} SchemaName
 * @param {character_varying} TableName
 * @returns {void}
 */
function add_timestamp_column() {
/*
CREATE OR REPLACE FUNCTION meta.add_timestamp_column("SchemaName" character varying, "TableName" character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
	DECLARE
	  sql VARCHAR;
BEGIN

	IF NOT EXISTS (SELECT 1
		FROM   pg_attribute
		WHERE  attrelid = ("SchemaName" || '.' || "TableName")::regclass  -- table name optionally schema-qualified
		AND    attnum > 0
		AND    NOT attisdropped
		AND    attname = 'time_modified') THEN
		EXECUTE format ('ALTER TABLE %s.%s ADD column time_modified timestamp', "SchemaName", "TableName");
	END IF;
	
	EXECUTE format ('UPDATE %s.%s SET time_modified=CURRENT_TIMESTAMP WHERE time_modified IS NULL', "SchemaName", "TableName");	

	PERFORM meta.add_update_time_modified_trigger("SchemaName", "TableName");
	
END $function$

*/
 }
/**
 * @function clean_table
 * @memberof meta
 * @description Clean table
 * @param {text} v_schema_name
 * @param {text} v_table_name
 * @returns {void}
 */
function clean_table() {
/*
CREATE OR REPLACE FUNCTION meta.clean_table(v_schema_name text, v_table_name text)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE
    column_names text[];
    new_table_name text;
    inbound_foreign_keys pg_constraint[];
    outbound_foreign_keys pg_constraint[];
    fk record;
		tid oid;
		cmd text;
BEGIN

    -- Create a new table with the same structure as the original table
    EXECUTE format('CREATE TABLE %I.new_%I (LIKE %I.%I INCLUDING ALL)', v_schema_name, v_table_name, v_schema_name, v_table_name);

    -- Get the list of columns that are not dropped
    SELECT ARRAY(SELECT column_name
                 FROM information_schema.columns
                 WHERE table_schema = v_schema_name
                   AND table_name = v_table_name)
    INTO column_names;

    -- Generate a list of column names for the new table
    new_table_name := 'new_' || v_table_name;
		
		tid := (v_schema_name || '.' || v_table_name)::regclass;
		
    -- Copy data from the original table to the new table
		cmd := format('INSERT INTO %I.%I OVERRIDING SYSTEM VALUE SELECT %s FROM %I.%I', v_schema_name, new_table_name, array_to_string(column_names, ', '), v_schema_name, v_table_name);
		
		RAISE NOTICE '%', cmd;
		EXECUTE cmd;
		
    -- Memorize existing inbound foreign keys
		CREATE TEMP TABLE inbound_foreign_keys AS
		SELECT
				conname,
				conrelid::regclass::text AS t,
				confrelid::regclass::text AS ft,
				string_agg(a.attname, ', ' ORDER BY conkey) AS fkey,
				string_agg(b.attname, ', ' ORDER BY confkey) AS rkey,
				CASE WHEN confupdtype = 'c' THEN ' ON UPDATE CASCADE' ELSE '' END AS updaction,
				CASE WHEN confdeltype = 'c' THEN ' ON DELETE CASCADE' ELSE '' END AS delaction			
		FROM
				pg_constraint
		JOIN
				pg_attribute a ON a.attrelid = conrelid AND a.attnum = ANY(conkey)
		JOIN
				pg_attribute b ON b.attrelid = conrelid AND b.attnum = ANY(confkey)		
		WHERE confrelid = tid
		GROUP BY conname, conrelid, confrelid, updaction, delaction;
		
    -- Memorize existing outbound foreign keys
		CREATE TEMP TABLE outbound_foreign_keys AS
		SELECT
				conname,
				conrelid::regclass::text AS t,
				confrelid::regclass::text AS ft,
				string_agg(a.attname, ', ' ORDER BY conkey) AS fkey,
				string_agg(b.attname, ', ' ORDER BY confkey) AS rkey,
				CASE WHEN confupdtype = 'c' THEN ' ON UPDATE CASCADE' ELSE '' END AS updaction,
				CASE WHEN confdeltype = 'c' THEN ' ON DELETE CASCADE' ELSE '' END AS delaction					
		FROM
				pg_constraint
		JOIN
				pg_attribute a ON a.attrelid = conrelid AND a.attnum = ANY(conkey)
		JOIN
				pg_attribute b ON b.attrelid = conrelid AND b.attnum = ANY(confkey)		
    WHERE conrelid = tid
		GROUP BY conname, conrelid, confrelid, updaction, delaction;		
		
		-- Delete fk's
		FOR fk IN SELECT * FROM outbound_foreign_keys
    LOOP
        EXECUTE format('ALTER TABLE %I.%I DROP CONSTRAINT %s',
            v_schema_name, v_table_name, fk.conname);
    END LOOP;
		FOR fk IN SELECT * FROM inbound_foreign_keys
    LOOP
        EXECUTE format('ALTER TABLE %I.%I DROP CONSTRAINT %s',
            v_schema_name, v_table_name, fk.conname);
    END LOOP;		
		
    -- Drop the original table
    EXECUTE format('DROP TABLE %I.%I CASCADE', v_schema_name, v_table_name);

    -- Rename the new table to the original table's name
    EXECUTE format('ALTER TABLE %I.%I RENAME TO %I', v_schema_name, new_table_name, v_table_name);

    EXECUTE format('ALTER TABLE %I.%I OWNER TO gl', v_schema_name, v_table_name);
		
    -- Recreate outbound foreign keys on the new table
    FOR fk IN SELECT * FROM outbound_foreign_keys
    LOOP
        cmd := format('ALTER TABLE %I.%I ADD CONSTRAINT %s FOREIGN KEY (%s) REFERENCES %s.%s (%s)%s%s',
            v_schema_name, fk.t, fk.conname,
            fk.fkey,
						v_schema_name,
            fk.ft,
            fk.rkey,
						fk.delaction,
						fk.updaction);
				RAISE NOTICE '%', cmd;
				EXECUTE cmd;
    END LOOP;
		
    -- Recreate the saved inbound foreign keys
    FOR fk IN SELECT * FROM inbound_foreign_keys
    LOOP
				cmd := format('ALTER TABLE %I.%I ADD CONSTRAINT %s FOREIGN KEY (%s) REFERENCES %s.%s (%s)%s%s',
            v_schema_name, fk.t, fk.conname,
            fk.fkey,
            v_schema_name,
            fk.ft,
            fk.rkey,
						fk.delaction,
						fk.updaction);
				RAISE NOTICE '%', cmd;
				EXECUTE cmd;
    END LOOP;
		
		DROP TABLE inbound_foreign_keys;
		DROP TABLE outbound_foreign_keys;
END;
$function$

*/
 }
/**
 * @function data_asset_d
 * @memberof zzglc
 * @description Data asset d
 * @param {integer} Key
 * @returns {void}
 */
function data_asset_d() {
/*
CREATE OR REPLACE FUNCTION zzglc.data_asset_d("Key" integer)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

    DELETE FROM data.asset
    WHERE id = "Key";

END $function$

*/
 }
/**
 * @function auth_role_public_c
 * @memberof zzglc
 * @description Auth role public c
 * @param {character_varying} Json
 * @returns {integer}
 */
function auth_role_public_c() {
/*
CREATE OR REPLACE FUNCTION zzglc.auth_role_public_c("Json" character varying)
 RETURNS integer
 LANGUAGE plpgsql
AS $function$
   DECLARE v_id integer;
BEGIN

    INSERT INTO auth.role_public (
        name
    )
    SELECT
        U.name
    FROM
        json_to_record("Json"::json) U (
name character varying(255)
        ) 
    RETURNING id INTO v_id;

    RETURN v_id;
END $function$

*/
 }
/**
 * @function general_message_r
 * @memberof zzglc
 * @description General message r
 * @returns {Object}
 * @property {integer} id
 * @property {integer} person_id
 * @property {text} message
 * @property {timestamp_without_time_zone} time_modified
 * @property {integer} parent_id
 * @property {character_varying} person_id_val
 */
function general_message_r() {
/*
CREATE OR REPLACE FUNCTION zzglc.general_message_r()
 RETURNS TABLE(id integer, person_id integer, message text, time_modified timestamp without time zone, parent_id integer, person_id_val character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

    RETURN QUERY
    SELECT
    t.id, t.person_id, t.message, t.time_modified, t.parent_id
    , person_id_t.name::VARCHAR AS person_id_val
    FROM general.message t

    LEFT JOIN general.person person_id_t ON person_id_t.id = t.person_id
    
    ORDER BY t.person_id
;
END $function$

*/
 }
/**
 * @function data_shape_geometry_c
 * @memberof zzglc
 * @description Data shape geometry c
 * @param {character_varying} Json
 * @returns {void}
 */
function data_shape_geometry_c() {
/*
CREATE OR REPLACE FUNCTION zzglc.data_shape_geometry_c("Json" character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

    INSERT INTO data.shape_geometry (
        shape_id,
        properties,
        geom
    )
    SELECT
        U.shape_id,
        U.properties,
        U.geom
    FROM
        json_to_record("Json"::json) U (
shape_id integer,
            properties json,
            geom geometry
        ) 
;
END $function$

*/
 }
/**
 * @function import_spain
 * @memberof data
 * @description Import spain
 * @param {text} jsonCV
 * @param {text} jsonData
 * @returns {void}
 */
function import_spain() {
/*
CREATE OR REPLACE FUNCTION data.import_spain("jsonCV" text, "jsonData" text)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

DROP TABLE IF EXISTS t;
CREATE TEMP TABLE t AS
SELECT * FROM json_to_recordset("jsonData"::json) AS J(
"Year" varchar, "date" varchar, "point_key" varchar, "depth" varchar, "Elevation (m)" varchar, "Coord X" varchar, "Coord Y" varchar, "Springtime grass production (kg ha-1)" varchar, "Topsoil carbon storage (t C ha-1)" varchar, "Carbonates (g/kg)" varchar, "Organic carbon (g/kg)" varchar, "Silt (%)" varchar, "Clay (%)" varchar);

WITH x AS (SELECT DISTINCT t."depth" FROM  t)
INSERT INTO data.depth(name)
SELECT meta.clean_value(x."depth", 'varchar')::varchar FROM x
LEFT JOIN data.depth depth ON depth.name= x."depth"
WHERE depth.id IS NULL;

WITH x AS (SELECT DISTINCT t."point_key", t."Elevation (m)", t."Coord X", t."Coord Y" FROM  t)
INSERT INTO data.point(point_key, elev, lon, lat, data_source_id)
SELECT meta.clean_value(x."point_key", 'varchar')::varchar, meta.clean_value(x."Elevation (m)", 'float')::float, meta.clean_value(x."Coord X", 'double precision')::double precision, meta.clean_value(x."Coord Y", 'double precision')::double precision, 6 FROM x
LEFT JOIN data.point point ON point.point_key= x."point_key"
WHERE point.id IS NULL;

INSERT INTO data.measurement(point_id, indicator_id, depth_id, value, date, data_source_id)
SELECT x.id, i.id, d.id, meta.clean_value(t."Springtime grass production (kg ha-1)", 'double precision')::double precision, meta.clean_value(t.date, 'date')::date, 6 FROM t
LEFT JOIN data.point x ON x.point_key = t."point_key"
 left join data.indicator i on i.name_match = 'Springtime grass production' left join data.measurement y on y.point_id = x.id and y.indicator_id = i.id and y.date = meta.clean_value(t.date, 'date')::date left join data.depth d on d.name = t.depth
WHERE y.id IS NULL AND meta.clean_value(t."Springtime grass production (kg ha-1)", 'double precision')::double precision IS NOT NULL ;

INSERT INTO data.measurement(point_id, indicator_id, depth_id, value, date, data_source_id)
SELECT x.id, i.id, d.id, meta.clean_value(t."Topsoil carbon storage (t C ha-1)", 'double precision')::double precision, meta.clean_value(t.date, 'date')::date, 6 FROM t
LEFT JOIN data.point x ON x.point_key = t."point_key"
 left join data.indicator i on i.name_match = 'Topsoil carbon storage' left join data.measurement y on y.point_id = x.id and y.indicator_id = i.id and y.date = meta.clean_value(t.date, 'date')::date left join data.depth d on d.name = t.depth
WHERE y.id IS NULL AND meta.clean_value(t."Topsoil carbon storage (t C ha-1)", 'double precision')::double precision IS NOT NULL ;

INSERT INTO data.measurement(point_id, indicator_id, depth_id, value, date, data_source_id)
SELECT x.id, i.id, d.id, meta.clean_value(t."Carbonates (g/kg)", 'double precision')::double precision, meta.clean_value(t.date, 'date')::date, 6 FROM t
LEFT JOIN data.point x ON x.point_key = t."point_key"
 left join data.indicator i on i.name_match = 'CaCO3' left join data.measurement y on y.point_id = x.id and y.indicator_id = i.id and y.date = meta.clean_value(t.date, 'date')::date left join data.depth d on d.name = t.depth
WHERE y.id IS NULL AND meta.clean_value(t."Carbonates (g/kg)", 'double precision')::double precision IS NOT NULL ;

INSERT INTO data.measurement(point_id, indicator_id, depth_id, value, date, data_source_id)
SELECT x.id, i.id, d.id, meta.clean_value(t."Organic carbon (g/kg)", 'double precision')::double precision, meta.clean_value(t.date, 'date')::date, 6 FROM t
LEFT JOIN data.point x ON x.point_key = t."point_key"
 left join data.indicator i on i.name_match = 'OC' left join data.measurement y on y.point_id = x.id and y.indicator_id = i.id and y.date = meta.clean_value(t.date, 'date')::date left join data.depth d on d.name = t.depth
WHERE y.id IS NULL AND meta.clean_value(t."Organic carbon (g/kg)", 'double precision')::double precision IS NOT NULL ;

INSERT INTO data.measurement(point_id, indicator_id, depth_id, value, date, data_source_id)
SELECT x.id, i.id, d.id, meta.clean_value(t."Silt (%)", 'double precision')::double precision, meta.clean_value(t.date, 'date')::date, 6 FROM t
LEFT JOIN data.point x ON x.point_key = t."point_key"
 left join data.indicator i on i.name_match = 'Silt' left join data.measurement y on y.point_id = x.id and y.indicator_id = i.id and y.date = meta.clean_value(t.date, 'date')::date left join data.depth d on d.name = t.depth
WHERE y.id IS NULL AND meta.clean_value(t."Silt (%)", 'double precision')::double precision IS NOT NULL ;

INSERT INTO data.measurement(point_id, indicator_id, depth_id, value, date, data_source_id)
SELECT x.id, i.id, d.id, meta.clean_value(t."Clay (%)", 'double precision')::double precision, meta.clean_value(t.date, 'date')::date, 6 FROM t
LEFT JOIN data.point x ON x.point_key = t."point_key"
 left join data.indicator i on i.name_match = 'Clay' left join data.measurement y on y.point_id = x.id and y.indicator_id = i.id and y.date = meta.clean_value(t.date, 'date')::date left join data.depth d on d.name = t.depth
WHERE y.id IS NULL AND meta.clean_value(t."Clay (%)", 'double precision')::double precision IS NOT NULL ;

END $function$

*/
 }
/**
 * @function meta_help_u
 * @memberof zzglc
 * @description Meta help u
 * @param {character_varying} Json
 * @returns {void}
 */
function meta_help_u() {
/*
CREATE OR REPLACE FUNCTION zzglc.meta_help_u("Json" character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE v_row_count INTEGER;
BEGIN

    UPDATE meta.help t
    SET name = U.name 
    FROM json_to_record("Json"::json) AS U (
        id integer,
            name character varying(255)
    ) 
    WHERE U.id = t.id
;

END $function$

*/
 }
/**
 * @function import_master_clone
 * @memberof meta
 * @description Import master clone
 * @param {character_varying} Id
 * @returns {void}
 */
function import_master_clone() {
/*
CREATE OR REPLACE FUNCTION meta.import_master_clone("Id" character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
	DECLARE v_new_id INT;
BEGIN

	-- Routine body goes here...
	INSERT INTO meta.import_master (schema_name, table_name, file_name, sheet, import_name)
	SELECT schema_name, table_name, file_name, sheet, import_name || '_cloned'
	FROM meta.import_master 
	WHERE id = "Id"::int
	RETURNING id INTO v_new_id;
	
	INSERT INTO meta.import_detail (import_master_id, col_name, target_schema, target_table, target_column, col_type, is_key, is_fk, as_row, target_column_list, source_column_list, joins, split, ignore)
	SELECT v_new_id, col_name, target_schema, target_table, target_column, col_type, is_key, is_fk, as_row, target_column_list, source_column_list, joins, split, ignore
	FROM meta.import_detail
	WHERE import_master_id = "Id"::int;
	

	RETURN;
END$function$

*/
 }
/**
 * @function set_table_owners
 * @memberof utils
 * @description Set table owners
 * @param {text} owner_name
 * @returns {void}
 */
function set_table_owners() {
/*
CREATE OR REPLACE FUNCTION utils.set_table_owners(owner_name text)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE
    table_record RECORD;
BEGIN

    -- Loop through all tables in the current database
    FOR table_record IN
        SELECT table_schema, table_name
        FROM information_schema.tables
        WHERE table_schema in ('auth', 'data', 'general', 'log', 'meta', 'osm', 'utils', 'zzglc', 'zzgll', 'zzhistory')
          AND table_type = 'BASE TABLE'
    LOOP
        -- Build and execute dynamic SQL to set table owner
        EXECUTE format('ALTER TABLE %I.%I OWNER TO %I', table_record.table_schema, table_record.table_name, owner_name);
    END LOOP;
END;
$function$

*/
 }
/**
 * @function set_custom_geometry_time
 * @memberof data
 * @description Set custom geometry time
 * @param {integer} PersonId
 * @param {integer} CustomGeometryId
 * @param {integer} Id
 * @param {timestamp_with_time_zone} ObservationTime
 * @param {text} Props
 * @returns {integer}
 */
function set_custom_geometry_time() {
/*
CREATE OR REPLACE FUNCTION data.set_custom_geometry_time("PersonId" integer, "CustomGeometryId" integer, "Id" integer, "ObservationTime" timestamp with time zone, "Props" text)
 RETURNS integer
 LANGUAGE plpgsql
AS $function$

DECLARE v_id INT;
				properties json;		
BEGIN

	properties := "Props"::json;
	v_id := "Id";
	
	IF NOT EXISTS (
		SELECT 1 FROM data.custom_geometry WHERE id = "CustomGeometryId" AND person_id = "PersonId"
	) THEN
		SELECT meta.raise_error(4, 'Not allowed');
	END IF;
	
	IF v_id IS NULL THEN
		INSERT INTO data.custom_geometry_time (custom_geometry_id, observation_time)
		VALUES ("CustomGeometryId", "ObservationTime")
		RETURNING id INTO v_id;
	ELSE
		UPDATE data.custom_geometry_time SET observation_time = "ObservationTime" 
		WHERE id = "Id";
	END IF;

	DROP TABLE IF EXISTS p;
	CREATE TEMP TABLE p AS
	SELECT * FROM json_to_recordset(properties) AS t(property_id int, name VARCHAR, value VARCHAR);
	
	INSERT INTO data.custom_geometry_property (custom_geometry_time_id, property_id, value)
	SELECT v_id, property_id, value FROM p WHERE value IS NOT NULL
	ON CONFLICT(custom_geometry_time_id, property_id)
	DO UPDATE SET value = EXCLUDED.value;
	
	DELETE FROM data.custom_geometry_property d
	WHERE d.custom_geometry_time_id = v_id AND d.property_id NOT IN (
	  SELECT p.property_id FROM p WHERE value IS NOT NULL
	);
	
	RETURN v_id;
	
END 
$function$

*/
 }
/**
 * @function data_property_c
 * @memberof zzglc
 * @description Data property c
 * @param {character_varying} Json
 * @returns {integer}
 */
function data_property_c() {
/*
CREATE OR REPLACE FUNCTION zzglc.data_property_c("Json" character varying)
 RETURNS integer
 LANGUAGE plpgsql
AS $function$
   DECLARE v_id integer;
BEGIN

    INSERT INTO data.property (
        name,
        indicator_id,
        unit_id,
        data_type_id,
        numerical,
        mask
    )
    SELECT
        U.name,
        U.indicator_id,
        U.unit_id,
        U.data_type_id,
        U.numerical,
        U.mask
    FROM
        json_to_record("Json"::json) U (
name character varying(255),
            indicator_id integer,
            unit_id integer,
            data_type_id integer,
            numerical boolean,
            mask character varying(255)
        ) 
    RETURNING id INTO v_id;

    RETURN v_id;
END $function$

*/
 }
/**
 * @function analyze_file
 * @memberof meta
 * @description Analyze file
 * @param {integer} Id
 * @param {text} JsonData
 * @returns {void}
 */
function analyze_file() {
/*
CREATE OR REPLACE FUNCTION meta.analyze_file("Id" integer, "JsonData" text)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE debug VARCHAR;
BEGIN

	
	DROP TABLE IF EXISTS t;
	
	CREATE TEMP TABLE t AS
	SELECT * FROM json_to_recordset("JsonData"::json) AS J(col_name VARCHAR, col_type VARCHAR);
	
	DELETE FROM meta.import_detail WHERE import_master_id = "Id";
	
	INSERT INTO meta.import_detail (import_master_id, col_name, col_type, target_schema, target_table, target_column, is_fk, is_key, order_no)
	
	--SELECT json_agg(x.*) FROM (
	SELECT "Id", t.col_name, dt.name, m.schema_name, m.table_name, meta.camel_to_snake(t.col_name), false, false, ROW_NUMBER() OVER ()
	FROM t 
	INNER JOIN meta.import_master m ON m.id = "Id"
	LEFT JOIN meta.data_type dt ON dt.server_data_type = REPLACE(t.col_type, 'System.', '') AND dt.default_type
	--) x;
	;
	RAISE NOTICE '%', debug;
	RETURN;
END$function$

*/
 }
/**
 * @function get_news
 * @memberof meta
 * @description Get news
 * @param {integer} LangId
 * @returns {Object}
 * @property {integer} id
 * @property {character_varying} title
 * @property {character_varying} text
 * @property {character_varying} extended_text
 * @property {timestamp_without_time_zone} time_modified
 * @property {timestamp_without_time_zone} time_created
 * @property {character_varying} user_modified
 */
function get_news() {
/*
CREATE OR REPLACE FUNCTION meta.get_news("LangId" integer)
 RETURNS TABLE(id integer, title character varying, text character varying, extended_text character varying, time_modified timestamp without time zone, time_created timestamp without time zone, user_modified character varying)
 LANGUAGE plpgsql
AS $function$
	BEGIN

		RETURN QUERY
		SELECT n.id, 
			COALESCE(l.title, e.title) title,
			COALESCE(l.text, e.text) text, 
			COALESCE(l.extended_text, e.extended_text) extended_text, 
			COALESCE(l.time_modified, e.time_modified) time_modified,
			COALESCE(l.time_created,  e.time_created) time_created,
			NULL::varchar --(p.last_name || p.first_name)::VARCHAR
		FROM meta.news n
		LEFT JOIN meta.news_lang l ON l.news_id = n.id and l.lang_id = "LangId"
		LEFT JOIN meta.news_lang e ON e.news_id = n.id and e.lang_id = 1
		--LEFT JOIN general.person p ON p.id = n.user_modified
		WHERE n.active = true
		ORDER BY time_modified DESC;
		
END$function$

*/
 }
/**
 * @function data_lc_detail_c
 * @memberof zzglc
 * @description Data lc detail c
 * @param {character_varying} Json
 * @returns {void}
 */
function data_lc_detail_c() {
/*
CREATE OR REPLACE FUNCTION zzglc.data_lc_detail_c("Json" character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

    INSERT INTO data.lc_detail (
        name,
        color_id,
        code
    )
    SELECT
        U.name,
        U.color_id,
        U.code
    FROM
        json_to_record("Json"::json) U (
name character varying,
            color_id integer,
            code character(3)
        ) 
;
END $function$

*/
 }
/**
 * @function get_lucas_obsolete
 * @memberof data
 * @description Get lucas obsolete
 * @param {integer} DataSourceId
 * @param {integer} LangId
 * @returns {Object}
 * @property {character_varying} Point
 * @property {character_varying} Depth
 * @property {double_precision} OxAl
 * @property {double_precision} N
 * @property {double_precision} P
 * @property {double_precision} OxFe
 * @property {double_precision} pH_(CaCl&lt;sub>2&lt;/sub>)
 * @property {double_precision} EC
 * @property {double_precision} K
 * @property {double_precision} OC
 * @property {double_precision} pH_(H&lt;sub>2&lt;/sub>O)
 * @property {double_precision} CaCO&lt;sub>3&lt;/sub>
 * @property {character_varying} Nuts_0
 * @property {character_varying} Nuts_1
 * @property {character_varying} Nuts_2
 * @property {character_varying} Nuts_3
 * @property {double_precision} Lat
 * @property {double_precision} Lon
 * @property {date} Date
 * @property {integer} Elevation
 * @property {character_varying} Land_cover
 * @property {character_varying} Land_usage
 * @property {character_varying} Main_land_cover
 * @property {character_varying} Detailed_land_cover
 * @property {character_varying} Detailed_land_use
 */
function get_lucas_obsolete() {
/*
CREATE OR REPLACE FUNCTION data.get_lucas_obsolete("DataSourceId" integer, "LangId" integer)
 RETURNS TABLE("Point" character varying, "Depth" character varying, "OxAl" double precision, "N" double precision, "P" double precision, "OxFe" double precision, "pH (CaCl&lt;sub>2&lt;/sub>)" double precision, "EC" double precision, "K" double precision, "OC" double precision, "pH (H&lt;sub>2&lt;/sub>O)" double precision, "CaCO&lt;sub>3&lt;/sub>" double precision, "Nuts_0" character varying, "Nuts_1" character varying, "Nuts_2" character varying, "Nuts_3" character varying, "Lat" double precision, "Lon" double precision, "Date" date, "Elevation" integer, "Land cover" character varying, "Land usage" character varying, "Main land cover" character varying, "Detailed land cover" character varying, "Detailed land use" character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

	RETURN QUERY (
			SELECT p.point_key, d.name depth 
			  , t."Ox_Al", t."N", t."P", t."Ox_Fe", t."pH (CaCl2)", t."EC", t."K", t."OC", t."pH (H2O)", t."CaCO3"
			  , n0.nuts_id nuts_0, n1.nuts_id nuts_1, n2.nuts_id nuts_2, n3.nuts_id nuts_3, p.lat, p.lon, t.date, pa.elev
				, lcd.code::VARCHAR lc, lud.code::VARCHAR lu, lcm.name lc0_desc, lcd.name lc1_desc, lud.name lu1_desc
			FROM (
				SELECT * FROM crosstab (
					'SELECT p.id, m.date, i.name, m.value
					from data.measurement m
					INNER JOIN data.indicator i on i.id = m.indicator_id 
					INNER JOIN data.point p on p.id = m.point_id WHERE m.data_source_id = ' || "DataSourceId" || ' ORDER BY 1, 2',
					'SELECT DISTINCT i.name FROM data.indicator i inner join data.measurement m on m.indicator_id = i.id AND m.data_source_id = ' || "DataSourceId"::VARCHAR

				) AS ct (id int, date date, "Ox_Al" float, "N" float, "P" float, "Ox_Fe" float, "pH (CaCl2)" float, "EC" float, "K" float, "OC" float, "pH (H2O)" float, "CaCO3" float)
			) t
			INNER JOIN data.point p on p.id = t.id
			LEFT JOIN data.vw_nuts v ON v.l3_id = p.l3_id
			LEFT JOIN data.nuts n0 ON n0.id = v.l0_id
			LEFT JOIN data.nuts n1 ON n1.id = v.l1_id
			LEFT JOIN data.nuts n2 ON n2.id = v.l2_id
			LEFT JOIN data.nuts n3 ON n3.id = v.l3_id	
			--LEFT JOIN data.nuts_0 n0 ON n0.id = p.nuts_0_id
			--LEFT JOIN data.nuts_1 n1 ON n1.id = p.nuts_1_id
			--LEFT JOIN data.nuts_2 n2 ON n2.id = p.nuts_2_id
			--LEFT JOIN data.nuts_3 n3 ON n3.id = p.nuts_3_id
			LEFT JOIN data.point_att pa ON pa.point_id = p.id AND pa.data_source_id = "DataSourceId"
			LEFT JOIN data.depth d ON d.id = pa.depth_id
			LEFT JOIN data.lc_main lcm ON lcm.id = pa.lc_main_id
			LEFT JOIN data.lc_detail lcd ON lcd.id = pa.lc_detail_id
			LEFT JOIN data.lu_detail lud ON lud.id = pa.lu_detail_id
			ORDER BY 2
--		) t
	);
		
END $function$

*/
 }
/**
 * @function data_attribute_d
 * @memberof zzglc
 * @description Data attribute d
 * @param {integer} Key
 * @returns {void}
 */
function data_attribute_d() {
/*
CREATE OR REPLACE FUNCTION zzglc.data_attribute_d("Key" integer)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

    DELETE FROM data.attribute
    WHERE id = "Key";

END $function$

*/
 }
/**
 * @function meta_safe_function_c
 * @memberof zzglc
 * @description Meta safe function c
 * @param {character_varying} Json
 * @returns {void}
 */
function meta_safe_function_c() {
/*
CREATE OR REPLACE FUNCTION zzglc.meta_safe_function_c("Json" character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

    INSERT INTO meta.safe_function (
        name
    )
    SELECT
        U.name
    FROM
        json_to_record("Json"::json) U (
name character varying(255)
        ) 
;
END $function$

*/
 }
/**
 * @function data_data_source_d
 * @memberof zzglc
 * @description Data data source d
 * @param {integer} Key
 * @returns {void}
 */
function data_data_source_d() {
/*
CREATE OR REPLACE FUNCTION zzglc.data_data_source_d("Key" integer)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

    DELETE FROM data.data_source
    WHERE id = "Key";

END $function$

*/
 }
/**
 * @function general_sub_region_d
 * @memberof zzglc
 * @description General sub region d
 * @param {smallint} Key
 * @returns {void}
 */
function general_sub_region_d() {
/*
CREATE OR REPLACE FUNCTION zzglc.general_sub_region_d("Key" smallint)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

    DELETE FROM general.sub_region
    WHERE id = "Key";

END $function$

*/
 }
/**
 * @function meta_help_lang_d
 * @memberof zzglc
 * @description Meta help lang d
 * @param {integer} Key
 * @returns {void}
 */
function meta_help_lang_d() {
/*
CREATE OR REPLACE FUNCTION zzglc.meta_help_lang_d("Key" integer)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

    DELETE FROM meta.help_lang
    WHERE id = "Key";

END $function$

*/
 }
/**
 * @function get_person_id
 * @memberof auth
 * @description Get person id
 * @param {character_varying} Email
 * @returns {integer}
 */
function get_person_id() {
/*
CREATE OR REPLACE FUNCTION auth.get_person_id("Email" character varying)
 RETURNS integer
 LANGUAGE plpgsql
AS $function$
	DECLARE v_id INT;
BEGIN

	-- Routine body goes here...
	RETURN (
		SELECT p.id 
		FROM general.person p 
		WHERE p.user_email = "Email"
	);

END $function$

*/
 }
/**
 * @function auth_role_l
 * @memberof zzgll
 * @description Auth role l
 * @param {character_varying} SearchValue
 * @param {uuid} Key
 * @returns {Object}
 * @property {uuid} id
 * @property {character_varying} name
 */
function auth_role_l() {
/*
CREATE OR REPLACE FUNCTION zzgll.auth_role_l("SearchValue" character varying, "Key" uuid DEFAULT NULL::uuid)
 RETURNS TABLE(id uuid, name character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

        IF "Key" IS NOT NULL THEN
            RETURN QUERY
            SELECT t.id, t.name
            FROM auth.role t
            WHERE t.id = "Key"::uuid;
        ELSE
            RETURN QUERY
            SELECT t.id, t.name
            FROM auth.role t
            WHERE t.name LIKE "SearchValue" AND t.tenant_id = 1
            ORDER BY t.name
           LIMIT 1000;
       END IF;
END $function$

*/
 }
/**
 * @function data_custom_geometry_l
 * @memberof zzgll
 * @description Data custom geometry l
 * @param {character_varying} SearchValue
 * @param {integer} Key
 * @returns {Object}
 * @property {integer} id
 * @property {integer} geometry_type_id
 */
function data_custom_geometry_l() {
/*
CREATE OR REPLACE FUNCTION zzgll.data_custom_geometry_l("SearchValue" character varying, "Key" integer DEFAULT NULL::integer)
 RETURNS TABLE(id integer, geometry_type_id integer)
 LANGUAGE plpgsql
AS $function$
BEGIN

        IF "Key" IS NOT NULL THEN
            RETURN QUERY
            SELECT t.id, t.geometry_type_id
            FROM data.custom_geometry t
            WHERE t.id = "Key"::integer;
        ELSE
            RETURN QUERY
           SELECT t.id, t.geometry_type_id
            FROM data.custom_geometry t
            WHERE t.geometry_type_id LIKE "SearchValue"
            ORDER BY t.geometry_type_id
           LIMIT 1000;
       END IF;
END $function$

*/
 }
/**
 * @function meta_news_u
 * @memberof zzglc
 * @description Meta news u
 * @param {character_varying} Json
 * @returns {void}
 */
function meta_news_u() {
/*
CREATE OR REPLACE FUNCTION zzglc.meta_news_u("Json" character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE v_row_count INTEGER;
BEGIN

    UPDATE meta.news t
    SET name = U.name,
        active = U.active,
        user_modified = U.user_modified,
        time_created = U.time_created 
    FROM json_to_record("Json"::json) AS U (
        id integer,
            name character varying(255),
            active boolean,
            time_modified timestamp without time zone,
            user_modified integer,
            time_created timestamp without time zone
    ) 
    WHERE U.id = t.id
    AND t.time_modified = U.time_modified;
    GET DIAGNOSTICS v_row_count = ROW_COUNT;
    IF v_row_count = 0 THEN
      SELECT meta.raise_error(2);
    END IF
;

END $function$

*/
 }
/**
 * @function general_region_l
 * @memberof zzgll
 * @description General region l
 * @param {character_varying} SearchValue
 * @param {smallint} Key
 * @returns {Object}
 * @property {smallint} id
 * @property {character_varying} name
 */
function general_region_l() {
/*
CREATE OR REPLACE FUNCTION zzgll.general_region_l("SearchValue" character varying, "Key" smallint DEFAULT NULL::smallint)
 RETURNS TABLE(id smallint, name character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

        IF "Key" IS NOT NULL THEN
            RETURN QUERY
            SELECT t.id, t.name
            FROM general.region t
            WHERE t.id = "Key"::smallint;
        ELSE
            RETURN QUERY
           SELECT t.id, t.name
            FROM general.region t
            WHERE t.name LIKE "SearchValue"
            ORDER BY t.name
           LIMIT 1000;
       END IF;
END $function$

*/
 }
/**
 * @function get_table_cols
 * @memberof meta
 * @description Get table cols
 * @param {character_varying} SchemaName
 * @param {character_varying} TableName
 * @returns {Object}
 * @property {character_varying} table_schema
 * @property {character_varying} table_name
 * @property {character_varying} column_name
 * @property {character_varying} referenced_schema_name
 * @property {character_varying} referenced_table_name
 * @property {character_varying} referenced_column_name
 * @property {character_varying} data_type
 * @property {character_varying} data_type_full
 * @property {integer} ordinal_number
 * @property {integer} max_length
 * @property {integer} numeric_precision
 * @property {integer} numeric_scale
 * @property {boolean} is_identity
 * @property {boolean} is_fk
 * @property {boolean} is_computed
 * @property {character_varying} default_value
 * @property {character_varying} referenced_display_column_name
 * @property {boolean} allow_dbnull
 * @property {boolean} referenced_column_language_dependent
 */
function get_table_cols() {
/*
CREATE OR REPLACE FUNCTION meta.get_table_cols("SchemaName" character varying, "TableName" character varying)
 RETURNS TABLE(table_schema character varying, table_name character varying, column_name character varying, referenced_schema_name character varying, referenced_table_name character varying, referenced_column_name character varying, data_type character varying, data_type_full character varying, ordinal_number integer, max_length integer, numeric_precision integer, numeric_scale integer, is_identity boolean, is_fk boolean, is_computed boolean, default_value character varying, referenced_display_column_name character varying, allow_dbnull boolean, referenced_column_language_dependent boolean)
 LANGUAGE plpgsql
AS $function$
	BEGIN

	
	BEGIN
	DROP TABLE IF EXISTS t;
	CREATE TEMP TABLE t AS
	SELECT
	  "SchemaName" AS table_schema,
    "TableName" AS table_name,
    a.attname AS column_name,
		n.nspname AS referenced_schema_name,
		t.relname::VARCHAR AS referenced_table_name,
    af.attname AS referenced_column_name
  FROM
    pg_constraint c
    JOIN pg_attribute a ON c.conrelid = a.attrelid AND a.attnum = c.conkey[1]
    JOIN pg_attribute af ON c.confrelid = af.attrelid AND af.attnum = c.confkey[1]
		JOIN pg_class t ON t.oid = c.confrelid
		JOIN pg_namespace n ON n.oid = t.relnamespace
  WHERE c.contype = 'f' 
	AND c.conrelid = ("SchemaName" || '.' || "TableName")::regclass;
	
	RETURN QUERY
	SELECT 
		  "SchemaName" AS table_schema,
      "TableName" AS table_name,
			a.attname::VARCHAR column_name, 
			t.referenced_schema_name::VARCHAR,
			
			--COALESCE(l.relname, t.referenced_table_name)::VARCHAR referenced_table_name,
			--COALESCE(rcl.attname,t.referenced_column_name)::VARCHAR referenced_column_name,
			t.referenced_table_name::VARCHAR,
			t.referenced_column_name::VARCHAR,			
			
			format_type(a.atttypid, null)::VARCHAR data_type,
  		format_type(a.atttypid, a.atttypmod)::VARCHAR data_type_full,
			a.attnum::INT ordinal_number,
			a.attlen::INT max_lengthT,
			((a.atttypmod - 4) &amp; 65535)::INT numeric_precision,
			null::INT numeric_scale,
			(a.attidentity != '' OR a.attnum = 1 AND a.atthasdef)::BOOLEAN is_identity,
		  (t.referenced_column_name IS NOT NULL)::BOOLEAN is_fk,
		  (a.attgenerated != '')::BOOLEAN is_computed,
			pg_get_expr(d.adbin, d.adrelid)::VARCHAR default_value,
			--COALESCE(rc.ref_col, rl.attname, r.attname)::VARCHAR referenced_display_columnName,
			COALESCE(rc.ref_col, r.attname)::VARCHAR referenced_display_columnName,
			(NOT a.attnotnull)::BOOLEAN allow_db_null,
			--(l.relname IS NOT NULL)::BOOLEAN referenced_column_language_dependent
			false referenced_column_language_dependent
	FROM pg_attribute a
	LEFT JOIN t 
	  ON t.column_name = a.attname
	LEFT JOIN pg_attrdef d 
	  ON a.attrelid = d.adrelid AND a.attnum = d.adnum 
	LEFT JOIN pg_attribute r
	  ON r.attrelid = (t.referenced_schema_name || '.' || t.referenced_table_name)::regclass AND r.attnum = 2 AND NOT r.attisdropped

--  LEFT JOIN pg_statio_user_tables l 
--	  ON l.schemaname = t.referenced_schema_name 
--		AND l.relname = t.referenced_table_name || '_lang' 
--		AND "TableName" NOT LIKE '%_lang'
--	LEFT JOIN pg_attribute rl
--	  ON rl.attrelid = l.relid AND rl.attnum = 4 AND NOT rl.attisdropped
--	LEFT JOIN pg_attribute rcl
--	  ON rcl.attrelid = l.relid AND rcl.attnum = 2 AND NOT rcl.attisdropped

	LEFT JOIN meta.table_ref_col rc ON rc.schema_name = t.referenced_schema_name AND rc.table_name = t.referenced_table_name
	WHERE a.attrelid = ("SchemaName" || '.' || "TableName")::regclass
	AND NOT a.attisdropped
  AND a.attnum > 0
	ORDER BY a.attnum;

	EXCEPTION
	WHEN  undefined_table THEN
		RAISE NOTICE '%', 'EXCEPTION';
	END;
	
END $function$

*/
 }
/**
 * @function general_person_l
 * @memberof zzgll
 * @description General person l
 * @param {character_varying} SearchValue
 * @param {integer} Key
 * @returns {Object}
 * @property {integer} id
 * @property {character_varying} name
 */
function general_person_l() {
/*
CREATE OR REPLACE FUNCTION zzgll.general_person_l("SearchValue" character varying, "Key" integer DEFAULT NULL::integer)
 RETURNS TABLE(id integer, name character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

        IF "Key" IS NOT NULL THEN
            RETURN QUERY
            SELECT t.id, t.name
            FROM general.person t
            WHERE t.id = "Key"::integer;
        ELSE
            RETURN QUERY
            SELECT t.id, t.name
            FROM general.person t
            WHERE t.name LIKE "SearchValue"
            ORDER BY t.name
            LIMIT 1000;
       END IF;
END $function$

*/
 }
/**
 * @function data_shape_geometry_r
 * @memberof zzglc
 * @description Data shape geometry r
 * @param {integer} ShapeId
 * @returns {Object}
 * @property {integer} id
 * @property {integer} shape_id
 * @property {json} properties
 * @property {character_varying} shape_id_val
 */
function data_shape_geometry_r() {
/*
CREATE OR REPLACE FUNCTION zzglc.data_shape_geometry_r("ShapeId" integer)
 RETURNS TABLE(id integer, shape_id integer, properties json, shape_id_val character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

    RETURN QUERY
    SELECT
    t.id, t.shape_id, t.properties
    , shape_id_t.name::VARCHAR AS shape_id_val
    FROM data.shape_geometry t

    LEFT JOIN data.shape shape_id_t ON shape_id_t.id = t.shape_id
    
    WHERE t.shape_id = "ShapeId"
    
    ORDER BY t.shape_id
;
END $function$

*/
 }
/**
 * @function meta_trace_r
 * @memberof zzglc
 * @description Meta trace r
 * @returns {Object}
 * @property {integer} id
 * @property {character_varying} text
 * @property {timestamp_without_time_zone} time_modified
 */
function meta_trace_r() {
/*
CREATE OR REPLACE FUNCTION zzglc.meta_trace_r()
 RETURNS TABLE(id integer, text character varying, time_modified timestamp without time zone)
 LANGUAGE plpgsql
AS $function$
BEGIN

    RETURN QUERY
    SELECT
    t.id, t.text, t.time_modified
    FROM meta.trace t
    
    ORDER BY t.time_modified DESC
;
END $function$

*/
 }
/**
 * @function data_lu_detail_u
 * @memberof zzglc
 * @description Data lu detail u
 * @param {character_varying} Json
 * @returns {void}
 */
function data_lu_detail_u() {
/*
CREATE OR REPLACE FUNCTION zzglc.data_lu_detail_u("Json" character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE v_row_count INTEGER;
BEGIN

    UPDATE data.lu_detail t
    SET name = U.name,
        color_id = U.color_id,
        code = U.code 
    FROM json_to_record("Json"::json) AS U (
        id integer,
            name character varying,
            color_id integer,
            code character(4)
    ) 
    WHERE U.id = t.id
;

END $function$

*/
 }
/**
 * @function data_asset_import_excel
 * @memberof data
 * @description Data asset import excel
 * @param {text} jsonCV
 * @param {text} jsonData
 * @returns {void}
 */
function data_asset_import_excel() {
/*
CREATE OR REPLACE FUNCTION data.data_asset_import_excel("jsonCV" text, "jsonData" text)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

DROP TABLE IF EXISTS t;
CREATE TEMP TABLE t AS
SELECT * FROM json_to_recordset("jsonData"::json) AS J(
"id" varchar, "ignore" varchar, "catalog" varchar, "title" varchar, "description" varchar, "Theme" varchar, "keywords_list" varchar, "version" varchar, "doi" varchar, "layer_unit" varchar, "scale_factor" varchar, "contact_name" varchar, "contact_email" varchar, "providers_list" varchar, "license" varchar, "constellation_list" varchar, "platform" varchar, "instruments_list" varchar, "gsd" varchar, "start_date" varchar, "end_date" varchar, "date_step" varchar, "date_offset" varchar, "date_unit" varchar, "date_style" varchar, "ignore_29feb" varchar, "depth_list" varchar, "main_sld_url" varchar, "sld_1_url" varchar, "main_qml_url" varchar, "main_url" varchar, "url_1" varchar, "url_2" varchar, "url_3" varchar, "url_4" varchar, "url_5" varchar, "url_6" varchar, "url_7" varchar, "url_8" varchar, "url_9" varchar, "url_10" varchar, "url_11" varchar, "url_12" varchar, "url_13" varchar, "url_14" varchar, "url_15" varchar, "url_16" varchar, "url_17" varchar, "url_18" varchar, "url_19" varchar, "url_20" varchar, "url_21" varchar, "url_22" varchar, "url_23" varchar, "url_24" varchar);

WITH x AS (SELECT DISTINCT t."catalog" FROM  t)
INSERT INTO data.asset_catalog(name)
SELECT meta.clean_value(x."catalog", 'varchar')::varchar FROM x
LEFT JOIN data.asset_catalog asset_catalog ON asset_catalog.name= x."catalog"
WHERE asset_catalog.id IS NULL;

WITH x AS (SELECT DISTINCT t."Theme" FROM  t)
INSERT INTO data.asset_theme(name)
SELECT meta.clean_value(x."Theme", 'varchar')::varchar FROM x
LEFT JOIN data.asset_theme asset_theme ON asset_theme.name= x."Theme"
WHERE asset_theme.id IS NULL;

WITH x AS (SELECT DISTINCT t."version" FROM  t)
INSERT INTO data.asset_version(name)
SELECT meta.clean_value(x."version", 'varchar')::varchar FROM x
LEFT JOIN data.asset_version asset_version ON asset_version.name= x."version"
WHERE asset_version.id IS NULL;

WITH x AS (SELECT DISTINCT t."date_style" FROM  t)
INSERT INTO data.date_style(name)
SELECT meta.clean_value(x."date_style", 'varchar')::varchar FROM x
LEFT JOIN data.date_style date_style ON date_style.name= x."date_style"
WHERE date_style.id IS NULL;

WITH x AS (SELECT DISTINCT t."date_unit" FROM  t)
INSERT INTO data.date_unit(name)
SELECT meta.clean_value(x."date_unit", 'varchar')::varchar FROM x
LEFT JOIN data.date_unit date_unit ON date_unit.name= x."date_unit"
WHERE date_unit.id IS NULL;

WITH x AS (SELECT DISTINCT t."license" FROM  t)
INSERT INTO data.license(name)
SELECT meta.clean_value(x."license", 'varchar')::varchar FROM x
LEFT JOIN data.license license ON license.name= x."license"
WHERE license.id IS NULL;

WITH x AS (SELECT DISTINCT t."layer_unit" FROM  t)
INSERT INTO data.unit(name)
SELECT meta.clean_value(x."layer_unit", 'varchar')::varchar FROM x
LEFT JOIN data.unit unit ON unit.name= x."layer_unit"
WHERE unit.id IS NULL;

WITH x AS (SELECT DISTINCT t."contact_name" FROM  t)
INSERT INTO general.person(name1)
SELECT meta.clean_value(x."contact_name", 'varchar')::varchar FROM x
LEFT JOIN general.person person ON person.name1= x."contact_name"
WHERE person.id IS NULL;

WITH x AS (SELECT DISTINCT t."id", t."ignore", t."catalog", t."title", t."description", t."Theme", t."keywords_list", t."version", t."doi", t."layer_unit", t."scale_factor", t."contact_name", t."providers_list", t."license", t."constellation_list", t."platform", t."instruments_list", t."gsd", t."start_date", t."end_date", t."date_step", t."date_offset", t."date_unit", t."date_style", t."ignore_29feb", t."depth_list", t."main_sld_url", t."sld_1_url", t."main_qml_url", t."main_url" FROM  t)
INSERT INTO data.asset(orig_id, ignore, asset_catalog_id, title, description, asset_theme_id, keywords_list, asset_version_id, doi, unit_id, scale_factor, person_id, providers_list, license_id, constellation_list, platform, instruments_list, gsd, start_date, end_date, date_step, date_offset, date_unit_id, date_style_id, ignore_29feb, depth_list, main_sld_url, sld_1_url, main_qml_url, main_url)
SELECT meta.clean_value(x."id", 'varchar')::varchar, meta.clean_value(x."ignore", 'boolean')::boolean, asset_catalog.id, meta.clean_value(x."title", 'varchar')::varchar, meta.clean_value(x."description", 'varchar')::varchar, asset_theme.id, meta.clean_value(x."keywords_list", 'varchar')::varchar, asset_version.id, meta.clean_value(x."doi", 'varchar')::varchar, unit.id, meta.clean_value(x."scale_factor", 'varchar')::varchar, person.id, meta.clean_value(x."providers_list", 'varchar')::varchar, license.id, meta.clean_value(x."constellation_list", 'varchar')::varchar, meta.clean_value(x."platform", 'varchar')::varchar, meta.clean_value(x."instruments_list", 'varchar')::varchar, meta.clean_value(x."gsd", 'varchar')::varchar, meta.clean_value(x."start_date", 'date')::date, meta.clean_value(x."end_date", 'date')::date, meta.clean_value(x."date_step", 'int')::int, meta.clean_value(x."date_offset", 'varchar')::varchar, date_unit.id, date_style.id, meta.clean_value(x."ignore_29feb", 'boolean')::boolean, meta.clean_value(x."depth_list", 'varchar')::varchar, meta.clean_value(x."main_sld_url", 'varchar')::varchar, meta.clean_value(x."sld_1_url", 'varchar')::varchar, meta.clean_value(x."main_qml_url", 'varchar')::varchar, meta.clean_value(x."main_url", 'varchar')::varchar FROM x
LEFT JOIN data.asset asset ON asset.orig_id= x."id"
LEFT JOIN data.asset_catalog asset_catalog ON asset_catalog.name = x."catalog"
LEFT JOIN data.asset_theme asset_theme ON asset_theme.name = x."Theme"
LEFT JOIN data.asset_version asset_version ON asset_version.name = x."version"
LEFT JOIN data.unit unit ON unit.name = x."layer_unit"
LEFT JOIN general.person person ON person.name1 = x."contact_name"
LEFT JOIN data.license license ON license.name = x."license"
LEFT JOIN data.date_unit date_unit ON date_unit.name = x."date_unit"
LEFT JOIN data.date_style date_style ON date_style.name = x."date_style"
WHERE asset.id IS NULL;

END $function$

*/
 }
/**
 * @function data_file_metadata_l
 * @memberof zzgll
 * @description Data file metadata l
 * @param {character_varying} SearchValue
 * @param {integer} Key
 * @returns {Object}
 * @property {integer} id
 * @property {character_varying} orig_id
 */
function data_file_metadata_l() {
/*
CREATE OR REPLACE FUNCTION zzgll.data_file_metadata_l("SearchValue" character varying, "Key" integer DEFAULT NULL::integer)
 RETURNS TABLE(id integer, orig_id character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

        IF "Key" IS NOT NULL THEN
            RETURN QUERY
            SELECT t.id, t.orig_id
            FROM data.file_metadata t
            WHERE t.id = "Key"::integer;
        ELSE
            RETURN QUERY
           SELECT t.id, t.orig_id
            FROM data.file_metadata t
            WHERE t.orig_id LIKE "SearchValue"
            ORDER BY t.orig_id
           LIMIT 1000;
       END IF;
END $function$

*/
 }
/**
 * @function data_lc_detail_l
 * @memberof zzgll
 * @description Data lc detail l
 * @param {character_varying} SearchValue
 * @param {integer} Key
 * @returns {Object}
 * @property {integer} id
 * @property {character_varying} name
 */
function data_lc_detail_l() {
/*
CREATE OR REPLACE FUNCTION zzgll.data_lc_detail_l("SearchValue" character varying, "Key" integer DEFAULT NULL::integer)
 RETURNS TABLE(id integer, name character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

        IF "Key" IS NOT NULL THEN
            RETURN QUERY
            SELECT t.id, t.name
            FROM data.lc_detail t
            WHERE t.id = "Key"::integer;
        ELSE
            RETURN QUERY
           SELECT t.id, t.name
            FROM data.lc_detail t
            WHERE t.name LIKE "SearchValue"
            ORDER BY t.name
           LIMIT 1000;
       END IF;
END $function$

*/
 }

/**
 * @function import_osm_boundaries
 * @memberof general
 * @description Import osm boundaries
 * @returns {void}
 */
function import_osm_boundaries() {
/*
CREATE OR REPLACE PROCEDURE general.import_osm_boundaries()
 LANGUAGE plpgsql
AS $procedure$
BEGIN

	delete from general.boundary;
	delete from general.boundary_hierarchy;
	
	insert into general.boundary (osm_id, admin_level, name, local_name, geom)
	SELECT r.id, ((r.tags::hstore)->'admin_level')::int, COALESCE((r.tags::hstore)->'name:en', p.name), p.name, p.way
	FROM osm.planet_osm_rels r
	INNER JOIN osm.planet_osm_polygon p ON ABS(p.osm_id) = r.id
	WHERE textregexeq((r.tags::hstore)->'admin_level','^\d+$');

	INSERT INTO general.boundary_hierarchy(parent_id, child_id)
	WITH T AS (
		SELECT r.id, unnest(r.parts) cid
		from osm.planet_osm_rels r
		WHERE textregexeq((r.tags::hstore)->'admin_level','^\d+$')
	) 
	SELECT T.* 
	FROM T 
	INNER JOIN osm.planet_osm_rels r ON R.id = cid;

  -- CALL general.update_parent_distance();
	SELECT general.calculate_levels();
	
END $procedure$

*/
 }
/**
 * @function copy_color_scheme
 * @memberof data
 * @description Copy color scheme
 * @param {integer} IndicatorIdFrom
 * @param {integer} IndicatorIdTo
 * @returns {void}
 */
function copy_color_scheme() {
/*
CREATE OR REPLACE FUNCTION data.copy_color_scheme("IndicatorIdFrom" integer, "IndicatorIdTo" integer)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

	INSERT INTO data.indicator_color (indicator_id, value_to, color_id)
	SELECT "IndicatorIdTo", value_to, color_id
	FROM data.indicator_color c
	WHERE indicator_id = "IndicatorIdFrom";
END $function$

*/
 }
/**
 * @function data_asset_theme_d
 * @memberof zzglc
 * @description Data asset theme d
 * @param {integer} Key
 * @returns {void}
 */
function data_asset_theme_d() {
/*
CREATE OR REPLACE FUNCTION zzglc.data_asset_theme_d("Key" integer)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

    DELETE FROM data.asset_theme
    WHERE id = "Key";

END $function$

*/
 }
/**
 * @function data_indicator_u
 * @memberof zzglc
 * @description Data indicator u
 * @param {character_varying} Json
 * @returns {void}
 */
function data_indicator_u() {
/*
CREATE OR REPLACE FUNCTION zzglc.data_indicator_u("Json" character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE v_row_count INTEGER;
BEGIN

    UPDATE data.indicator t
    SET name = U.name,
        unit_id = U.unit_id,
        lod = U.lod,
        name_match = U.name_match,
        decimals_for_stats = U.decimals_for_stats,
        decimals_for_display = U.decimals_for_display,
        numerical = U.numerical,
        value_from = U.value_from,
        value_to = U.value_to 
    FROM json_to_record("Json"::json) AS U (
        id integer,
            name character varying(255),
            unit_id integer,
            lod character varying(255),
            name_match character varying(255),
            decimals_for_stats integer,
            decimals_for_display integer,
            numerical boolean,
            value_from real,
            value_to real
    ) 
    WHERE U.id = t.id
;

END $function$

*/
 }
/**
 * @function data_custom_geometry_r
 * @memberof zzglc
 * @description Data custom geometry r
 * @returns {Object}
 * @property {integer} id
 * @property {integer} geometry_type_id
 * @property {integer} person_id
 * @property {character_varying} route_key
 * @property {character_varying} name
 * @property {boolean} public
 * @property {timestamp_with_time_zone} time_modified
 * @property {timestamp_with_time_zone} time_created
 * @property {character_varying} geometry_type_id_val
 * @property {character_varying} person_id_val
 */
function data_custom_geometry_r() {
/*
CREATE OR REPLACE FUNCTION zzglc.data_custom_geometry_r()
 RETURNS TABLE(id integer, geometry_type_id integer, person_id integer, route_key character varying, name character varying, public boolean, time_modified timestamp with time zone, time_created timestamp with time zone, geometry_type_id_val character varying, person_id_val character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

    RETURN QUERY
    SELECT
    t.id, t.geometry_type_id, t.person_id, t.route_key, t.name, t.public, t.time_modified, t.time_created
    , geometry_type_id_t.name::VARCHAR AS geometry_type_id_val, person_id_t.name::VARCHAR AS person_id_val
    FROM data.custom_geometry t

    LEFT JOIN data.geometry_type geometry_type_id_t ON geometry_type_id_t.id = t.geometry_type_id
    LEFT JOIN general.person person_id_t ON person_id_t.id = t.person_id
    
    ORDER BY t.geometry_type_id
;
END $function$

*/
 }
/**
 * @function meta_route_c
 * @memberof zzglc
 * @description Meta route c
 * @param {character_varying} Json
 * @returns {integer}
 */
function meta_route_c() {
/*
CREATE OR REPLACE FUNCTION zzglc.meta_route_c("Json" character varying)
 RETURNS integer
 LANGUAGE plpgsql
AS $function$
   DECLARE v_id integer;
BEGIN

    INSERT INTO meta.route (
        name,
        order_no,
        path,
        component_name,
        icon,
        parent,
        props,
        offline,
        public,
        active
    )
    SELECT
        U.name,
        U.order_no,
        U.path,
        U.component_name,
        U.icon,
        U.parent,
        U.props,
        U.offline,
        U.public,
        U.active
    FROM
        json_to_record("Json"::json) U (
name character varying(255),
            order_no integer,
            path character varying(255),
            component_name character varying(255),
            icon character varying(255),
            parent character varying(255),
            props json,
            offline boolean,
            public boolean,
            active boolean
        ) 
    RETURNING id INTO v_id;

    RETURN v_id;
END $function$

*/
 }
/**
 * @function meta_import_master_c
 * @memberof zzglc
 * @description Meta import master c
 * @param {character_varying} Json
 * @returns {void}
 */
function meta_import_master_c() {
/*
CREATE OR REPLACE FUNCTION zzglc.meta_import_master_c("Json" character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

    INSERT INTO meta.import_master (
        schema_name,
        table_name,
        file_name,
        sheet,
        import_name,
        data_date,
        constant_value
    )
    SELECT
        U.schema_name,
        U.table_name,
        U.file_name,
        U.sheet,
        U.import_name,
        U.data_date,
        U.constant_value
    FROM
        json_to_record("Json"::json) U (
schema_name character varying(255),
            table_name character varying(255),
            file_name character varying(1024),
            sheet character varying(255),
            import_name character varying(255),
            data_date character varying,
            constant_value character varying(255)
        ) 
;
END $function$

*/
 }
/**
 * @function data_oedce_r
 * @memberof zzglc
 * @description Data oedce r
 * @returns {Object}
 * @property {integer} fid
 * @property {character_varying} start_datetime
 * @property {character_varying} end_datetime
 * @property {character_varying} gsd
 * @property {character_varying} instruments
 * @property {character_varying} datetime
 * @property {character_varying} item_id
 * @property {character_varying} item_bbox
 * @property {character_varying} href
 * @property {character_varying} type
 * @property {character_varying} main
 * @property {character_varying} roles
 * @property {character_varying} asset_id
 * @property {character_varying} collection_id
 * @property {character_varying} collection_title
 * @property {character_varying} collection_description
 * @property {character_varying} collection_providers
 * @property {character_varying} collection_keywords
 * @property {character_varying} collection_license
 * @property {character_varying} platform
 */
function data_oedce_r() {
/*
CREATE OR REPLACE FUNCTION zzglc.data_oedce_r()
 RETURNS TABLE(fid integer, start_datetime character varying, end_datetime character varying, gsd character varying, instruments character varying, datetime character varying, item_id character varying, item_bbox character varying, href character varying, type character varying, main character varying, roles character varying, asset_id character varying, collection_id character varying, collection_title character varying, collection_description character varying, collection_providers character varying, collection_keywords character varying, collection_license character varying, platform character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

    RETURN QUERY
    SELECT
    t.fid, t.start_datetime, t.end_datetime, t.gsd, t.instruments, t.datetime, t.item_id, t.item_bbox, t.href, t.type, t.main, t.roles, t.asset_id, t.collection_id, t.collection_title, t.collection_description, t.collection_providers, t.collection_keywords, t.collection_license, t.platform
    FROM data.oedce t
;
END $function$

*/
 }
/**
 * @function general_country_r
 * @memberof zzglc
 * @description General country r
 * @returns {Object}
 * @property {smallint} id
 * @property {character_varying} name
 * @property {character} code
 * @property {integer} region_id
 * @property {integer} sub_region_id
 * @property {integer} osm_id
 * @property {character_varying} region_id_val
 * @property {character_varying} sub_region_id_val
 * @property {boolean} has_boundary
 */
function general_country_r() {
/*
CREATE OR REPLACE FUNCTION zzglc.general_country_r()
 RETURNS TABLE(id smallint, name character varying, code character, region_id integer, sub_region_id integer, osm_id integer, region_id_val character varying, sub_region_id_val character varying, has_boundary boolean)
 LANGUAGE plpgsql
AS $function$
BEGIN

    RETURN QUERY
    SELECT
    t.id, t.name, t.code, t.region_id, t.sub_region_id, t.osm_id
    , region_id_t.name::VARCHAR AS region_id_val, sub_region_id_t.name::VARCHAR AS sub_region_id_val
		, CASE WHEN b.id is not null THEN true ELSE false END has_boundary
    FROM general.country t

    LEFT JOIN general.region region_id_t ON region_id_t.id = t.region_id
    LEFT JOIN general.sub_region sub_region_id_t ON sub_region_id_t.id = t.sub_region_id
		LEFT JOIN general.boundary b ON b.osm_id = t.osm_id
    
    ORDER BY t.name
;
END $function$

*/
 }
/**
 * @function meta_import_detail_c
 * @memberof zzglc
 * @description Meta import detail c
 * @param {character_varying} Json
 * @returns {void}
 */
function meta_import_detail_c() {
/*
CREATE OR REPLACE FUNCTION zzglc.meta_import_detail_c("Json" character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

    INSERT INTO meta.import_detail (
        import_master_id,
        col_name,
        target_schema,
        target_table,
        target_column,
        col_type,
        is_key,
        is_fk,
        as_row,
        target_column_list,
        source_column_list,
        joins,
        split,
        ignore,
        name_match,
        order_no,
        ignore_in_master,
        constant_value
    )
    SELECT
        U.import_master_id,
        U.col_name,
        U.target_schema,
        U.target_table,
        U.target_column,
        U.col_type,
        U.is_key,
        U.is_fk,
        U.as_row,
        U.target_column_list,
        U.source_column_list,
        U.joins,
        U.split,
        U.ignore,
        U.name_match,
        U.order_no,
        U.ignore_in_master,
        U.constant_value
    FROM
        json_to_record("Json"::json) U (
import_master_id integer,
            col_name character varying(255),
            target_schema character varying(255),
            target_table character varying(255),
            target_column character varying(255),
            col_type character varying(255),
            is_key boolean,
            is_fk boolean,
            as_row boolean,
            target_column_list character varying(1024),
            source_column_list character varying(1024),
            joins character varying(8192),
            split boolean,
            ignore boolean,
            name_match character varying(255),
            order_no integer,
            ignore_in_master boolean,
            constant_value character varying(255)
        ) 
;
END $function$

*/
 }
/**
 * @function auth_log_u
 * @memberof zzglc
 * @description Auth log u
 * @param {character_varying} Json
 * @returns {void}
 */
function auth_log_u() {
/*
CREATE OR REPLACE FUNCTION zzglc.auth_log_u("Json" character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE v_row_count INTEGER;
BEGIN

    UPDATE auth.log t
    SET person_id = U.person_id,
        ip = U.ip 
    FROM json_to_record("Json"::json) AS U (
        id integer,
            person_id integer,
            ip character varying,
            time_modified timestamp without time zone
    ) 
    WHERE U.id = t.id
    AND t.time_modified = U.time_modified;
    GET DIAGNOSTICS v_row_count = ROW_COUNT;
    IF v_row_count = 0 THEN
      SELECT meta.raise_error(2);
    END IF
;

END $function$

*/
 }
/**
 * @function data_asset_version_u
 * @memberof zzglc
 * @description Data asset version u
 * @param {character_varying} Json
 * @returns {void}
 */
function data_asset_version_u() {
/*
CREATE OR REPLACE FUNCTION zzglc.data_asset_version_u("Json" character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE v_row_count INTEGER;
BEGIN

    UPDATE data.asset_version t
    SET name = U.name,
        srid = U.srid 
    FROM json_to_record("Json"::json) AS U (
        id integer,
            name character varying,
            srid character varying
    ) 
    WHERE U.id = t.id
;

END $function$

*/
 }
/**
 * @function update_compass
 * @memberof data
 * @description Update compass
 * @param {integer} PersonId
 * @param {integer} Id
 * @param {integer} Value
 * @returns {void}
 */
function update_compass() {
/*
CREATE OR REPLACE FUNCTION data.update_compass("PersonId" integer, "Id" integer, "Value" integer)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE
DECLARE v_RowCountInt INT;
BEGIN

		UPDATE data.custom_geometry_file f
		SET compass = "Value"
		WHERE id = "Id" 
		AND EXISTS (SELECT 1 FROM data.custom_geometry g WHERE g.id = f.custom_geometry_id AND g.person_id = "PersonId");
		GET DIAGNOSTICS v_RowCountInt = ROW_COUNT;
		IF v_RowCountInt = 0 THEN
			SELECT meta.raise_error(4);
		END IF;
END;
$function$

*/
 }
/**
 * @function data_point_d
 * @memberof zzglc
 * @description Data point d
 * @param {integer} Key
 * @returns {void}
 */
function data_point_d() {
/*
CREATE OR REPLACE FUNCTION zzglc.data_point_d("Key" integer)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

    DELETE FROM data.point
    WHERE id = "Key";

END $function$

*/
 }
/**
 * @function data_indicator_color_r
 * @memberof zzglc
 * @description Data indicator color r
 * @returns {Object}
 * @property {integer} id
 * @property {integer} indicator_id
 * @property {real} value_to
 * @property {integer} color_id
 * @property {character_varying} indicator_id_val
 * @property {character_varying} color_id_val
 * @property {character_varying} color_code
 */
function data_indicator_color_r() {
/*
CREATE OR REPLACE FUNCTION zzglc.data_indicator_color_r()
 RETURNS TABLE(id integer, indicator_id integer, value_to real, color_id integer, indicator_id_val character varying, color_id_val character varying, color_code character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

    RETURN QUERY
    SELECT
    t.id, t.indicator_id, t.value_to, t.color_id
    , indicator_id_t.name::VARCHAR AS indicator_id_val, color_id_t.name::VARCHAR AS color_id_val, color_id_t.code
    FROM data.indicator_color t

    LEFT JOIN data.indicator indicator_id_t ON indicator_id_t.id = t.indicator_id
    LEFT JOIN general.color color_id_t ON color_id_t.id = t.color_id
    
    ORDER BY t.indicator_id, t.value_to
;
END $function$

*/
 }
/**
 * @function general_boundary_c
 * @memberof zzglc
 * @description General boundary c
 * @param {character_varying} Json
 * @returns {void}
 */
function general_boundary_c() {
/*
CREATE OR REPLACE FUNCTION zzglc.general_boundary_c("Json" character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

    INSERT INTO general.boundary (
        osm_id,
        admin_level,
        name,
        local_name,
        geom
    )
    SELECT
        U.osm_id,
        U.admin_level,
        U.name,
        U.local_name,
        U.geom
    FROM
        json_to_record("Json"::json) U (
            osm_id integer,
            admin_level integer,
            name character varying,
            local_name character varying,
            geom geometry
        ) 
;
END $function$

*/
 }
/**
 * @function data_asset_theme_u
 * @memberof zzglc
 * @description Data asset theme u
 * @param {character_varying} Json
 * @returns {void}
 */
function data_asset_theme_u() {
/*
CREATE OR REPLACE FUNCTION zzglc.data_asset_theme_u("Json" character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE v_row_count INTEGER;
BEGIN

    UPDATE data.asset_theme t
    SET name = U.name 
    FROM json_to_record("Json"::json) AS U (
        id integer,
            name character varying
    ) 
    WHERE U.id = t.id
;

END $function$

*/
 }
/**
 * @function data_asset_u
 * @memberof zzglc
 * @description Data asset u
 * @param {character_varying} Json
 * @returns {void}
 */
function data_asset_u() {
/*
CREATE OR REPLACE FUNCTION zzglc.data_asset_u("Json" character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE v_row_count INTEGER;
BEGIN

    UPDATE data.asset t
    SET orig_id = U.orig_id,
        ignore = U.ignore,
        asset_catalog_id = U.asset_catalog_id,
        title = U.title,
        description = U.description,
        asset_theme_id = U.asset_theme_id,
        keywords_list = U.keywords_list,
        asset_version_id = U.asset_version_id,
        doi = U.doi,
        unit_id = U.unit_id,
        scale_factor = U.scale_factor,
        person_id = U.person_id,
        providers_list = U.providers_list,
        license_id = U.license_id,
        constellation_list = U.constellation_list,
        platform = U.platform,
        instruments_list = U.instruments_list,
        gsd = U.gsd,
        start_date = U.start_date,
        end_date = U.end_date,
        date_step = U.date_step,
        date_offset = U.date_offset,
        date_unit_id = U.date_unit_id,
        date_style_id = U.date_style_id,
        ignore_29feb = U.ignore_29feb,
        depth_list = U.depth_list,
        main_sld_url = U.main_sld_url,
        sld_1_url = U.sld_1_url,
        main_qml_url = U.main_qml_url,
        main_url = U.main_url,
        color_map = U.color_map,
        no_data = U.no_data,
        decimals = U.decimals,
        indicator_id = U.indicator_id 
    FROM json_to_record("Json"::json) AS U (
        id integer,
            orig_id character varying,
            ignore boolean,
            asset_catalog_id integer,
            title character varying,
            description character varying,
            asset_theme_id integer,
            keywords_list character varying,
            asset_version_id integer,
            doi character varying,
            unit_id integer,
            scale_factor character varying,
            person_id integer,
            providers_list character varying,
            license_id integer,
            constellation_list character varying,
            platform character varying,
            instruments_list character varying,
            gsd character varying,
            start_date date,
            end_date date,
            date_step integer,
            date_offset character varying,
            date_unit_id integer,
            date_style_id integer,
            ignore_29feb boolean,
            depth_list character varying,
            main_sld_url character varying,
            sld_1_url character varying,
            main_qml_url character varying,
            main_url character varying,
            color_map character varying,
            no_data integer,
            decimals integer,
            indicator_id integer
    ) 
    WHERE U.id = t.id
;

END $function$

*/
 }
/**
 * @function set_lon_lat_nuts_for_points
 * @memberof data
 * @description Set lon lat nuts for points
 * @param {integer} srid
 * @returns {void}
 */
function set_lon_lat_nuts_for_points() {
/*
CREATE OR REPLACE FUNCTION data.set_lon_lat_nuts_for_points(srid integer)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

UPDATE data.point p 
	SET lon = ST_X(ST_Transform(ST_SetSRID(ST_MakePoint(x, y), srid), 4326)),
      lat = ST_Y(ST_Transform(ST_SetSRID(ST_MakePoint(x, y), srid), 4326)) 
where lat is null and lon is null;

--CREATE INDEX point_geom_index ON data.point
--USING gist (st_transform(st_setsrid(st_makepoint(lon, lat), 4326), 3035) public.gist_geometry_ops_2d);

	UPDATE data.point p SET l3_id =  
	(SELECT id FROM general.nuts n 
	WHERE n.levl_code = 3 AND
	ST_Contains(n.geom, ST_Transform(ST_SetSRID(ST_MakePoint(p.lon, p.lat), 4326), 3035))) 
	WHERE l3_id IS NULL AND lat IS NOT NULL AND lon IS NOT NULL;
	
	-- DROP INDEX 	data.point_geom_index;

END $function$

*/
 }
/**
 * @function camel_to_snake
 * @memberof meta
 * @description Camel to snake
 * @param {text} input_text
 * @returns {text}
 */
function camel_to_snake() {
/*
CREATE OR REPLACE FUNCTION meta.camel_to_snake(input_text text)
 RETURNS text
 LANGUAGE plpgsql
AS $function$

DECLARE
    output_text text := '';
    prev_char text := '';
    curr_char text;
BEGIN

    -- if input text contains a space, return it as is
    IF input_text IS NULL OR input_text = '' OR input_text ~ ' ' THEN
        RETURN input_text;
    END IF;

		input_text := replace(input_text, '-', '_');

    FOR i IN 1..length(input_text) LOOP
        curr_char := substr(input_text, i, 1);
        IF i > 1
        AND curr_char = upper(curr_char)
        AND prev_char != '_'
        AND prev_char != upper(prev_char)
        THEN
            output_text := output_text || '_' || lower(curr_char);
            prev_char = '_';
        ELSE
            output_text := output_text || lower(curr_char);
            prev_char = curr_char;
        END IF;

    END LOOP;
    output_text := replace(output_text, '__', '_');

RETURN output_text;

END;
$function$

*/
 }
/**
 * @function data_asset_version_l
 * @memberof zzgll
 * @description Data asset version l
 * @param {character_varying} SearchValue
 * @param {integer} Key
 * @returns {Object}
 * @property {integer} id
 * @property {character_varying} name
 */
function data_asset_version_l() {
/*
CREATE OR REPLACE FUNCTION zzgll.data_asset_version_l("SearchValue" character varying, "Key" integer DEFAULT NULL::integer)
 RETURNS TABLE(id integer, name character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

        IF "Key" IS NOT NULL THEN
            RETURN QUERY
            SELECT t.id, t.name
            FROM data.asset_version t
            WHERE t.id = "Key"::integer;
        ELSE
            RETURN QUERY
           SELECT t.id, t.name
            FROM data.asset_version t
            WHERE t.name LIKE "SearchValue"
            ORDER BY t.name
           LIMIT 1000;
       END IF;
END $function$

*/
 }
/**
 * @function get_assets
 * @memberof data
 * @description Get assets
 * @param {integer} TitleId
 * @param {character_varying} Depth
 * @param {integer} Srid
 * @returns {json}
 */
function get_assets() {
/*
CREATE OR REPLACE FUNCTION data.get_assets("TitleId" integer, "Depth" character varying, "Srid" integer)
 RETURNS json
 LANGUAGE plpgsql
AS $function$

BEGIN

	-- Routine body goes here...
	  RETURN (
			SELECT json_agg(t.*)
			FROM (
				SELECT row_number() OVER (ORDER BY time_span DESC) value, 
				time_span label, 
				'image/tiff' type, 
				url source 
				FROM data.vw_asset 
				WHERE title_id = "TitleId" and (depth = "Depth" or "Depth" is null)
				ORDER BY 2 DESC
			) t
		);
END
$function$

*/
 }
/**
 * @function function_sizes
 * @memberof utils
 * @description Function sizes
 * @returns {Object}
 * @property {bigint} functions
 * @property {bigint} total
 */
function function_sizes() {
/*
CREATE OR REPLACE FUNCTION utils.function_sizes()
 RETURNS TABLE(functions bigint, total bigint)
 LANGUAGE plpgsql
AS $function$
BEGIN

RETURN QUERY (	
	SELECT
		count(*) functions, sum(length(routine_definition ))
	FROM
		information_schema.routines 
	WHERE
		specific_schema not in ('information_schema', 'pg_catalog', 'tiger', 'pgstac', 'topology', 'zzz_obsolete', 'public')
);
END $function$

*/
 }
/**
 * @function import_lucas2009
 * @memberof data
 * @description Import lucas2009
 * @param {text} jsonCV
 * @param {text} jsonData
 * @returns {void}
 */
function import_lucas2009() {
/*
CREATE OR REPLACE FUNCTION data.import_lucas2009("jsonCV" text, "jsonData" text)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

DROP TABLE IF EXISTS t;
CREATE TEMP TABLE t AS
SELECT * FROM json_to_recordset("jsonData"::json) AS J(
"pH_in_CaCl2" varchar, "POINT_ID" varchar, "CaCO3" varchar, "CEC" varchar, "OC" varchar, "pH_in_H2O" varchar, "GPS_LONG" varchar, "GPS_LAT" varchar, "P" varchar, "N" varchar, "K" varchar, "coarse" varchar, "clay" varchar, "silt" varchar, "sand" varchar, "Notes" varchar, "sample_ID" varchar);

WITH x AS (SELECT DISTINCT t."POINT_ID", t."GPS_LONG", t."GPS_LAT", t."Notes", t."sample_ID" FROM  t)
INSERT INTO data.point(point_key, lon, lat, notes, sample)
SELECT meta.clean_value(x."POINT_ID", 'varchar')::varchar, meta.clean_value(x."GPS_LONG", 'float8')::float8, meta.clean_value(x."GPS_LAT", 'float8')::float8, meta.clean_value(x."Notes", 'varchar')::varchar, meta.clean_value(x."sample_ID", 'int')::int FROM x
LEFT JOIN data.point point ON point.point_key= x."POINT_ID"
WHERE point.id IS NULL;

INSERT INTO data.measurement(point_id, indicator_id, value, date)
SELECT x.id, i.id, meta.clean_value(t."pH_in_CaCl2", 'float')::float, '2009-01-01'::date FROM t
LEFT JOIN data.point x ON x.point_key = t."POINT_ID"
left join data.indicator i on i.name_match = 'pH (CaCl2)' left join data.measurement y on y.point_id = x.id and y.indicator_id = i.id and y.date = '2009-01-01'::date
WHERE y.id IS NULL AND meta.clean_value(t."pH_in_CaCl2", 'float')::float IS NOT NULL ;

INSERT INTO data.measurement(point_id, indicator_id, value, date)
SELECT x.id, i.id, meta.clean_value(t."CaCO3", 'float')::float,  '2009-01-01'::date FROM t
LEFT JOIN data.point x ON x.point_key = t."POINT_ID"
left join data.indicator i on i.name_match = 'CaCO3' left join data.measurement y on y.point_id = x.id and y.indicator_id = i.id and y.date =  '2009-01-01'::date
WHERE y.id IS NULL AND meta.clean_value(t."CaCO3", 'float')::float IS NOT NULL ;

INSERT INTO data.measurement(point_id, indicator_id, value, date)
SELECT x.id, i.id, meta.clean_value(t."CEC", 'float')::float, '2019-01-01'::date FROM t
LEFT JOIN data.point x ON x.point_key = t."POINT_ID"
left join data.indicator i on i.name_match = 'CEC' left join data.measurement y on y.point_id = x.id and y.indicator_id = i.id and y.date =  '2009-01-01'::date
WHERE y.id IS NULL AND meta.clean_value(t."CEC", 'float')::float IS NOT NULL ;

INSERT INTO data.measurement(point_id, indicator_id, value, date)
SELECT x.id, i.id, meta.clean_value(t."OC", 'float')::float,  '2009-01-01'::date FROM t
LEFT JOIN data.point x ON x.point_key = t."POINT_ID"
left join data.indicator i on i.name = 'OC' left join data.measurement y on y.point_id = x.id and y.indicator_id = i.id and y.date =  '2009-01-01'::date
WHERE y.id IS NULL AND meta.clean_value(t."OC", 'float')::float IS NOT NULL ;

INSERT INTO data.measurement(point_id, indicator_id, value, date)
SELECT x.id, i.id, meta.clean_value(t."pH_in_H2O", 'float')::float, '2009-01-01'::date FROM t
LEFT JOIN data.point x ON x.point_key = t."POINT_ID"
left join data.indicator i on i.name_match = 'pH (H2O)' left join data.measurement y on y.point_id = x.id and y.indicator_id = i.id and y.date =  '2009-01-01'::date
WHERE y.id IS NULL AND meta.clean_value(t."pH_in_H2O", 'float')::float IS NOT NULL ;

INSERT INTO data.measurement(point_id, indicator_id, value, date)
SELECT x.id, i.id, meta.clean_value(t."P", 'float')::float,  '2009-01-01'::date FROM t
LEFT JOIN data.point x ON x.point_key = t."POINT_ID"
left join data.indicator i on i.name_match = 'P' left join data.measurement y on y.point_id = x.id and y.indicator_id = i.id and y.date =  '2009-01-01'::date
WHERE y.id IS NULL AND meta.clean_value(t."P", 'float')::float IS NOT NULL ;

INSERT INTO data.measurement(point_id, indicator_id, value, date)
SELECT x.id, i.id, meta.clean_value(t."N", 'float')::float,  '2009-01-01'::date FROM t
LEFT JOIN data.point x ON x.point_key = t."POINT_ID"
left join data.indicator i on i.name_match = 'N' left join data.measurement y on y.point_id = x.id and y.indicator_id = i.id and y.date =  '2009-01-01'::date
WHERE y.id IS NULL AND meta.clean_value(t."N", 'float')::float IS NOT NULL ;

INSERT INTO data.measurement(point_id, indicator_id, value, date)
SELECT x.id, i.id, meta.clean_value(t."K", 'float')::float,  '2009-01-01'::date FROM t
LEFT JOIN data.point x ON x.point_key = t."POINT_ID"
left join data.indicator i on i.name_match = 'K' left join data.measurement y on y.point_id = x.id and y.indicator_id = i.id and y.date =  '2009-01-01'::date
WHERE y.id IS NULL AND meta.clean_value(t."K", 'float')::float IS NOT NULL ;

INSERT INTO data.measurement(point_id, indicator_id, value, date)
SELECT x.id, i.id, meta.clean_value(t."coarse", 'float')::float,  '2009-01-01'::date FROM t
LEFT JOIN data.point x ON x.point_key = t."POINT_ID"
left join data.indicator i on i.name_match = 'Clay' left join data.measurement y on y.point_id = x.id and y.indicator_id = i.id and y.date =  '2009-01-01'::date
WHERE y.id IS NULL AND meta.clean_value(t."coarse", 'float')::float IS NOT NULL ;

INSERT INTO data.measurement(point_id, indicator_id, value, date)
SELECT x.id, i.id, meta.clean_value(t."clay", 'float')::float,  '2009-01-01'::date FROM t
LEFT JOIN data.point x ON x.point_key = t."POINT_ID"
left join data.indicator i on i.name_match = 'Coarse' left join data.measurement y on y.point_id = x.id and y.indicator_id = i.id and y.date =  '2009-01-01'::date
WHERE y.id IS NULL AND meta.clean_value(t."clay", 'float')::float IS NOT NULL ;

INSERT INTO data.measurement(point_id, indicator_id, value, date)
SELECT x.id, i.id, meta.clean_value(t."silt", 'float')::float,  '2009-01-01'::date FROM t
LEFT JOIN data.point x ON x.point_key = t."POINT_ID"
left join data.indicator i on i.name_match = 'Silt' left join data.measurement y on y.point_id = x.id and y.indicator_id = i.id and y.date =  '2009-01-01'::date
WHERE y.id IS NULL AND meta.clean_value(t."silt", 'float')::float IS NOT NULL ;

INSERT INTO data.measurement(point_id, indicator_id, value, date)
SELECT x.id, i.id, meta.clean_value(t."sand", 'float')::float,  '2009-01-01'::date FROM t
LEFT JOIN data.point x ON x.point_key = t."POINT_ID"
left join data.indicator i on i.name_match = 'Sand' left join data.measurement y on y.point_id = x.id and y.indicator_id = i.id and y.date =  '2009-01-01'::date
WHERE y.id IS NULL AND meta.clean_value(t."sand", 'float')::float IS NOT NULL ;

END $function$

*/
 }
/**
 * @function data_custom_geometry_property_c
 * @memberof zzglc
 * @description Data custom geometry property c
 * @param {character_varying} Json
 * @returns {integer}
 */
function data_custom_geometry_property_c() {
/*
CREATE OR REPLACE FUNCTION zzglc.data_custom_geometry_property_c("Json" character varying)
 RETURNS integer
 LANGUAGE plpgsql
AS $function$
   DECLARE v_id integer;
BEGIN

    INSERT INTO data.custom_geometry_property (
        custom_geometry_id,
        property_id,
        value
    )
    SELECT
        U.custom_geometry_id,
        U.property_id,
        U.value
    FROM
        json_to_record("Json"::json) U (
custom_geometry_id integer,
            property_id integer,
            value character varying(255)
        ) 
    RETURNING id INTO v_id;

    RETURN v_id;
END $function$

*/
 }
/**
 * @function meta_i18n_d
 * @memberof zzglc
 * @description Meta i18n d
 * @param {integer} Key
 * @returns {void}
 */
function meta_i18n_d() {
/*
CREATE OR REPLACE FUNCTION zzglc.meta_i18n_d("Key" integer)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

    DELETE FROM meta.i18n
    WHERE id = "Key";

END $function$

*/
 }
/**
 * @function data_geometry_type_r
 * @memberof zzglc
 * @description Data geometry type r
 * @returns {Object}
 * @property {integer} id
 * @property {character_varying} name
 */
function data_geometry_type_r() {
/*
CREATE OR REPLACE FUNCTION zzglc.data_geometry_type_r()
 RETURNS TABLE(id integer, name character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

    RETURN QUERY
    SELECT
    t.id, t.name
    FROM data.geometry_type t
;
END $function$

*/
 }
/**
 * @function meta_route_r
 * @memberof zzglc
 * @description Meta route r
 * @returns {Object}
 * @property {integer} id
 * @property {character_varying} name
 * @property {integer} order_no
 * @property {character_varying} path
 * @property {character_varying} component_name
 * @property {character_varying} icon
 * @property {character_varying} parent
 * @property {json} props
 * @property {boolean} offline
 * @property {boolean} public
 * @property {boolean} active
 */
function meta_route_r() {
/*
CREATE OR REPLACE FUNCTION zzglc.meta_route_r()
 RETURNS TABLE(id integer, name character varying, order_no integer, path character varying, component_name character varying, icon character varying, parent character varying, props json, offline boolean, public boolean, active boolean)
 LANGUAGE plpgsql
AS $function$
BEGIN

    RETURN QUERY
    SELECT
    t.id, t.name, t.order_no, t.path, t.component_name, t.icon, t.parent, t.props, t.offline, t.public, t.active
    FROM meta.route t
		LEFT JOIN meta.route p ON p.name = t.parent
    ORDER BY COALESCE(p.order_no, 0), t.order_no
;
END $function$

*/
 }
/**
 * @function data_shape_geometry_d
 * @memberof zzglc
 * @description Data shape geometry d
 * @param {integer} Key
 * @returns {void}
 */
function data_shape_geometry_d() {
/*
CREATE OR REPLACE FUNCTION zzglc.data_shape_geometry_d("Key" integer)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

    DELETE FROM data.shape_geometry
    WHERE id = "Key";

END $function$

*/
 }
/**
 * @function meta_lang_u
 * @memberof zzglc
 * @description Meta lang u
 * @param {character_varying} Json
 * @returns {void}
 */
function meta_lang_u() {
/*
CREATE OR REPLACE FUNCTION zzglc.meta_lang_u("Json" character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE v_row_count INTEGER;
BEGIN

    UPDATE meta.lang t
    SET name = U.name,
        tag = U.tag,
        short_tag = U.short_tag 
    FROM json_to_record("Json"::json) AS U (
        id integer,
            name character varying(255),
            tag character varying(15),
            time_modified timestamp(6) without time zone,
            short_tag character(2)
    ) 
    WHERE U.id = t.id
    AND t.time_modified = U.time_modified;
    GET DIAGNOSTICS v_row_count = ROW_COUNT;
    IF v_row_count = 0 THEN
      SELECT meta.raise_error(2);
    END IF
;

END $function$

*/
 }
/**
 * @function data_point_c
 * @memberof zzglc
 * @description Data point c
 * @param {character_varying} Json
 * @returns {void}
 */
function data_point_c() {
/*
CREATE OR REPLACE FUNCTION zzglc.data_point_c("Json" character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

    INSERT INTO data.point (
        point_key,
        lat,
        lon,
        data_source_id,
        sample,
        notes,
        l3_id,
        elev,
        name,
        x,
        y
    )
    SELECT
        U.point_key,
        U.lat,
        U.lon,
        U.data_source_id,
        U.sample,
        U.notes,
        U.l3_id,
        U.elev,
        U.name,
        U.x,
        U.y
    FROM
        json_to_record("Json"::json) U (
point_key character varying(255),
            lat double precision,
            lon double precision,
            data_source_id integer,
            sample integer,
            notes character varying(255),
            l3_id integer,
            elev integer,
            name character varying(255),
            x double precision,
            y double precision
        ) 
;
END $function$

*/
 }
/**
 * @function data_geometry_type_c
 * @memberof zzglc
 * @description Data geometry type c
 * @param {character_varying} Json
 * @returns {void}
 */
function data_geometry_type_c() {
/*
CREATE OR REPLACE FUNCTION zzglc.data_geometry_type_c("Json" character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

    INSERT INTO data.geometry_type (
        name
    )
    SELECT
        U.name
    FROM
        json_to_record("Json"::json) U (
name character varying(255)
        ) 
;
END $function$

*/
 }
/**
 * @function general_country_import_excel
 * @memberof general
 * @description General country import excel
 * @param {text} jsonCV
 * @param {text} jsonData
 * @returns {void}
 */
function general_country_import_excel() {
/*
CREATE OR REPLACE FUNCTION general.general_country_import_excel("jsonCV" text, "jsonData" text)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

	DROP TABLE IF EXISTS t;
	
	CREATE TEMP TABLE t AS
	SELECT * FROM json_to_recordset("jsonData"::json) AS J(name VARCHAR, code VARCHAR, region VARCHAR, sub_region VARCHAR);
	
	WITH x AS (
		SELECT DISTINCT t.region FROM t
	)
	INSERT INTO general.region (name)
	SELECT x.region FROM x 
	LEFT JOIN general.region r ON r.name = x.region
	WHERE r.id IS NULL;

	WITH x AS (
		SELECT DISTINCT t.sub_region FROM t
	)
	INSERT INTO general.sub_region (name)
	SELECT x.sub_region FROM x 
	LEFT JOIN general.sub_region r ON r.name = x.sub_region
	WHERE r.id IS NULL;
	
	WITH x AS (
		SELECT name, code, region, sub_region FROM t
	)
	INSERT INTO general.country (name, code, region_id, sub_region_id)
	SELECT x.name, x.code, r.id, s.id
	FROM x
	LEFT JOIN general.region r ON r.name = x.region
	LEFT JOIN general.sub_region s ON s.name = x.sub_region
	LEFT JOIN general.country c ON c.name = x.name
	WHERE c.id IS NULL;
	
END
$function$

*/
 }
/**
 * @function table_sizes
 * @memberof utils
 * @description Table sizes
 * @returns {Object}
 * @property {character_varying} schema_name
 * @property {character_varying} table_name
 * @property {character_varying} size_pretty
 * @property {bigint} size
 * @property {bigint} records
 */
function table_sizes() {
/*
CREATE OR REPLACE FUNCTION utils.table_sizes()
 RETURNS TABLE(schema_name character varying, table_name character varying, size_pretty character varying, size bigint, records bigint)
 LANGUAGE plpgsql
AS $function$

BEGIN

	RETURN QUERY
	select
	    t.table_schema::varchar,
		t.table_name::varchar,
		pg_size_pretty(pg_relation_size('"'||t.table_schema||'"."'||t.table_name||'"'))::varchar,
		pg_relation_size('"'||t.table_schema||'"."'||t.table_name||'"'),
		ut.n_live_tup AS records
	from information_schema.tables t
	left join pg_catalog.pg_stat_user_tables ut on ut.schemaname = t.table_schema and ut.relname = t.table_name
	where t.table_type = 'BASE TABLE' and t.table_schema not in ('information_schema', 'pg_catalog', 'tiger', 'pgstac', 'topology', 'zzz_obsolete')
	order by 4 desc;
END 
$function$

*/
 }
/**
 * @function general_mjesto_l
 * @memberof zzgll
 * @description General mjesto l
 * @param {character_varying} SearchValue
 * @param {integer} Key
 * @returns {Object}
 * @property {integer} id
 * @property {character_varying} name
 */
function general_mjesto_l() {
/*
CREATE OR REPLACE FUNCTION zzgll.general_mjesto_l("SearchValue" character varying, "Key" integer DEFAULT NULL::integer)
 RETURNS TABLE(id integer, name character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

        IF "Key" IS NOT NULL THEN
            RETURN QUERY
            SELECT t.id, t.name
            FROM general.mjesto t
            WHERE t.id = "Key"::integer;
        ELSE
            RETURN QUERY
           SELECT t.id, t.name
            FROM general.mjesto t
            WHERE t.name LIKE "SearchValue"
            ORDER BY t.name
           LIMIT 1000;
       END IF;
END $function$

*/
 }
/**
 * @function data_custom_geometry_property_r
 * @memberof zzglc
 * @description Data custom geometry property r
 * @returns {Object}
 * @property {integer} id
 * @property {integer} custom_geometry_id
 * @property {integer} property_id
 * @property {character_varying} value
 * @property {character_varying} custom_geometry_id_val
 * @property {character_varying} property_id_val
 */
function data_custom_geometry_property_r() {
/*
CREATE OR REPLACE FUNCTION zzglc.data_custom_geometry_property_r()
 RETURNS TABLE(id integer, custom_geometry_id integer, property_id integer, value character varying, custom_geometry_id_val character varying, property_id_val character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

    RETURN QUERY
    SELECT
    t.id, t.custom_geometry_id, t.property_id, t.value
    , custom_geometry_id_t.geometry_type_id::VARCHAR AS custom_geometry_id_val, COALESCE(i.name, property_id_t.name)::VARCHAR AS property_id_val
    FROM data.custom_geometry_property t

    LEFT JOIN data.custom_geometry custom_geometry_id_t ON custom_geometry_id_t.id = t.custom_geometry_id
    LEFT JOIN data.property property_id_t ON property_id_t.id = t.property_id
	LEFT JOIN data.indicator i ON i.id = property_id_t.indicator_id
;
END 
$function$

*/
 }
/**
 * @function general_partner_r
 * @memberof zzglc
 * @description General partner r
 * @returns {Object}
 * @property {integer} id
 * @property {character_varying} short_name
 * @property {character_varying} name
 * @property {timestamp_without_time_zone} time_modified
 * @property {integer} user_modified
 * @property {character_varying} user_modified_val
 */
function general_partner_r() {
/*
CREATE OR REPLACE FUNCTION zzglc.general_partner_r()
 RETURNS TABLE(id integer, short_name character varying, name character varying, time_modified timestamp without time zone, user_modified integer, user_modified_val character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

    RETURN QUERY
    SELECT
    t.id, t.short_name, t.name, t.time_modified, t.user_modified
    , user_modified_t.name::VARCHAR AS user_modified_val
     FROM general.partner t
     
     LEFT JOIN general.person user_modified_t ON user_modified_t.id = t.user_modified
     
     ORDER BY t.name
;
END $function$

*/
 }
/**
 * @function log_errors_u
 * @memberof zzglc
 * @description Log errors u
 * @param {character_varying} Json
 * @returns {void}
 */
function log_errors_u() {
/*
CREATE OR REPLACE FUNCTION zzglc.log_errors_u("Json" character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE v_row_count INTEGER;
BEGIN

    UPDATE log.errors t
    SET message = U.message,
        level = U.level,
        time_stamp = U.time_stamp,
        exception = U.exception,
        log_event = U.log_event,
        tenant_id = U.tenant_id,
        user_id = U.user_id,
        app_id = U.app_id 
    FROM json_to_record("Json"::json) AS U (
        id integer,
            message character varying,
            level character varying,
            time_stamp timestamp(6) without time zone,
            exception character varying,
            log_event character varying,
            tenant_id integer,
            user_id uuid,
            app_id integer,
            time_modified timestamp(6) without time zone
    ) 
    WHERE U.id = t.id
    AND t.time_modified = U.time_modified;
    GET DIAGNOSTICS v_row_count = ROW_COUNT;
    IF v_row_count = 0 THEN
      SELECT meta.raise_error(2);
    END IF
;

END $function$

*/
 }
/**
 * @function get_tile_layers
 * @memberof data
 * @description Get tile layers
 * @param {integer} Srid
 * @returns {Object}
 * @property {integer} fid
 * @property {character_varying} collection_title
 * @property {character_varying} href
 * @property {character_varying} type
 * @property {text} geom
 */
function get_tile_layers() {
/*
CREATE OR REPLACE FUNCTION data.get_tile_layers("Srid" integer)
 RETURNS TABLE(fid integer, collection_title character varying, href character varying, type character varying, geom text)
 LANGUAGE plpgsql
AS $function$
BEGIN

RETURN QUERY
SELECT * FROM (
select 0 fid, ' OSM' collection_title, '' href, 'OSM' type, null geom
UNION
select t.fid, t.collection_title, t.href, t.type, ST_AsGeoJSON(ST_Transform(t.geom, "Srid"), 6, 1) geom from data.oedce t
where t."type" LIKE '%tiff%'
) t
ORDER BY t.collection_title COLLATE "C";
END $function$

*/
 }
/**
 * @function data_nuts_1_l
 * @memberof zzgll
 * @description Data nuts 1 l
 * @param {character_varying} SearchValue
 * @param {integer} Key
 * @returns {Object}
 * @property {integer} id
 * @property {character_varying} name
 */
function data_nuts_1_l() {
/*
CREATE OR REPLACE FUNCTION zzgll.data_nuts_1_l("SearchValue" character varying, "Key" integer DEFAULT NULL::integer)
 RETURNS TABLE(id integer, name character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

        IF "Key" IS NOT NULL THEN
            RETURN QUERY
            SELECT t.id, t.name
            FROM data.nuts_1 t
            WHERE t.id = "Key"::integer;
        ELSE
            RETURN QUERY
           SELECT t.id, t.name
            FROM data.nuts_1 t
            WHERE t.name LIKE "SearchValue"
            ORDER BY t.name
           LIMIT 1000;
       END IF;
END $function$

*/
 }
/**
 * @function get_shape_geometry
 * @memberof data
 * @description Get shape geometry
 * @param {integer} Id
 * @param {integer} Srid
 * @returns {json}
 */
function get_shape_geometry() {
/*
CREATE OR REPLACE FUNCTION data.get_shape_geometry("Id" integer, "Srid" integer)
 RETURNS json
 LANGUAGE plpgsql
AS $function$
BEGIN

	RETURN (
		SELECT jsonb_build_object (
				'type',       'FeatureCollection',
				'features', json_agg(
						json_build_object(
							'type',       'Feature',
							'geometry',   st_asgeojson(t.geom)::json,
							'properties', t.properties													
						)
				)
    )
		FROM (
			SELECT b.id, b.properties, st_transform(geom, "Srid") geom
			FROM data.shape_geometry b 
			WHERE b.id = "Id"
		) t	
	);
END$function$

*/
 }
/**
 * @function get_db_procedures
 * @memberof meta
 * @description Get db procedures
 * @param {character_varying} SchemaName
 * @param {character_varying} ProcName
 * @returns {json}
 */
function get_db_procedures() {
/*
CREATE OR REPLACE FUNCTION meta.get_db_procedures("SchemaName" character varying, "ProcName" character varying)
 RETURNS json
 LANGUAGE plpgsql
AS $function$
BEGIN

RETURN (
	WITH t AS (
		SELECT 
		    n.nspname,
		    p.proname,
			pg_get_functiondef(p.oid) AS function_definition,
			s.description proc_comment,
			a.order_no::INT,
			a.param_name,
			pg_catalog.format_type(COALESCE (b.param_type, d.param_type), null) AS data_type,
			c.input_output,
			pg_catalog.format_type(p.prorettype, null) AS return_type
		FROM pg_proc p
		INNER JOIN pg_namespace n ON (p.pronamespace = n.oid)
		LEFT JOIN pg_description s ON s.objoid = p.oid
		LEFT JOIN unnest(proargnames) WITH ORDINALITY AS a(param_name, order_no) ON true
		LEFT JOIN unnest(proargtypes) WITH ORDINALITY AS b(param_type, bseq) ON a.order_no = b.bseq
		LEFT JOIN unnest(proargmodes) WITH ORDINALITY AS c(input_output, cseq) ON a.order_no = c.cseq
		LEFT JOIN unnest(proallargtypes) WITH ORDINALITY AS d(param_type, dseq) ON a.order_no = d.dseq
		WHERE 
		  (n.nspname = "SchemaName" AND p.proname = "ProcName")
		OR ("ProcName" IS NULL AND
			n.nspname in ('auth', 'data', 'general', 'log', 'meta', 'osm', 'utils', 'zzglc', 'zzgll', 'zzhistory'))
	),
	b AS (
		SELECT nspname, proname, return_type, function_definition, proc_comment,
		json_build_object('param_name', param_name, 'data_type', data_type, 'input_output', input_output) param
		FROM t 
	),
	c AS (
		SELECT nspname proc_schema, proname proc_name, return_type, function_definition, proc_comment,
		json_agg(param) params
		FROM b
		GROUP BY nspname, proname, return_type, function_definition, proc_comment
	)
	SELECT json_agg (c.*) FROM c
);
END $function$

*/
 }
/**
 * @function data_asset_theme_r
 * @memberof zzglc
 * @description Data asset theme r
 * @returns {Object}
 * @property {integer} id
 * @property {character_varying} name
 */
function data_asset_theme_r() {
/*
CREATE OR REPLACE FUNCTION zzglc.data_asset_theme_r()
 RETURNS TABLE(id integer, name character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

    RETURN QUERY
    SELECT
    t.id, t.name
    FROM data.asset_theme t
;
END $function$

*/
 }
/**
 * @function meta_i18n_lang_d
 * @memberof zzglc
 * @description Meta i18n lang d
 * @param {integer} Key
 * @returns {void}
 */
function meta_i18n_lang_d() {
/*
CREATE OR REPLACE FUNCTION zzglc.meta_i18n_lang_d("Key" integer)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

    DELETE FROM meta.i18n_lang
    WHERE id = "Key";

END $function$

*/
 }
/**
 * @function data_depth_c
 * @memberof zzglc
 * @description Data depth c
 * @param {character_varying} Json
 * @returns {void}
 */
function data_depth_c() {
/*
CREATE OR REPLACE FUNCTION zzglc.data_depth_c("Json" character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

    INSERT INTO data.depth (
        name,
        color_id
    )
    SELECT
        U.name,
        U.color_id
    FROM
        json_to_record("Json"::json) U (
name character varying,
            color_id integer
        ) 
;
END $function$

*/
 }
/**
 * @function get_indicators_for_data_source
 * @memberof data
 * @description Get indicators for data source
 * @param {integer} DataSourceId
 * @param {integer} LangId
 * @returns {json}
 */
function get_indicators_for_data_source() {
/*
CREATE OR REPLACE FUNCTION data.get_indicators_for_data_source("DataSourceId" integer, "LangId" integer)
 RETURNS json
 LANGUAGE plpgsql
AS $function$

BEGIN

RETURN (
   SELECT json_agg(t.*) FROM (
				SELECT i.id value, COALESCE (l.value, e.value, i.name) label,
				i.numerical, u.name unit, i.decimals_for_stats, i.decimals_for_display
				-- CASE WHEN i.table_field IS NULL THEN true ELSE false END numerical
				FROM data.vw_data_source_indicator v
				LEFT JOIN data.indicator i ON i.id = v.indicator_id
				LEFT JOIN data.indicator_lang l on l.indicator_id = i.id and l.lang_id = "LangId"
				LEFT JOIN data.indicator_lang e on e.indicator_id = i.id and e.lang_id = "LangId"
				LEFT JOIN data.unit u ON u.id = i.unit_id
				WHERE v.data_source_id = "DataSourceId"
				ORDER BY 2) t
);
END 
$function$

*/
 }
/**
 * @function _navicat_temp_stored_proc
 * @memberof data
 * @description  Navicat temp stored proc
 * @param {integer} PersonId
 * @param {integer} Id
 * @param {integer} GeometryTypeId
 * @param {character_varying} Name
 * @param {boolean} Public
 * @returns {integer}
 */
function _navicat_temp_stored_proc() {
/*
CREATE OR REPLACE FUNCTION data._navicat_temp_stored_proc("PersonId" integer, "Id" integer, "GeometryTypeId" integer, "Name" character varying, "Public" boolean)
 RETURNS integer
 LANGUAGE plpgsql
AS $function$		
DECLARE v_id INT;	
BEGIN

	UPDATE data.custom_geometry 
	SET geometry_type_id = "GeometryTypeId", name = "Name", public = "Public"
	WHERE id = "Id"
	RETURNING id INTO v_id;
	
	IF v_id IS NULL THEN
		INSERT INTO data.custom_geometry (geometry_type_id, name, public)
		VALUES ("GeometryTypeId", "Name", "Public")
		RETURNING id INTO v_id;
	END IF;
	
	RETURN v_id;
	

	--DROP TABLE IF EXISTS p;
	--CREATE TEMP TABLE p AS
	--SELECT * FROM json_to_recordset(properties->'props') AS t(property_id int, name VARCHAR, value VARCHAR);
	
	--INSERT INTO data.custom_geometry_property (custom_geometry_id, property_id, value)
	--SELECT "Id", property_id, value FROM p
	--ON CONFLICT(custom_geometry_id, property_id)
	--DO UPDATE SET value = EXCLUDED.value;
	
	--DELETE FROM data.custom_geometry_property d
	--WHERE d.custom_geometry_id = "Id" AND d.property_id NOT IN (
	  --SELECT p.property_id FROM p
	--);
	
END 
$function$

*/
 }
/**
 * @function data_custom_geometry_property_u
 * @memberof zzglc
 * @description Data custom geometry property u
 * @param {character_varying} Json
 * @returns {void}
 */
function data_custom_geometry_property_u() {
/*
CREATE OR REPLACE FUNCTION zzglc.data_custom_geometry_property_u("Json" character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE v_row_count INTEGER;
BEGIN

    UPDATE data.custom_geometry_property t
    SET custom_geometry_id = U.custom_geometry_id,
        property_id = U.property_id,
        value = U.value 
    FROM json_to_record("Json"::json) AS U (
        id integer,
            custom_geometry_id integer,
            property_id integer,
            value character varying(255)
    ) 
    WHERE U.id = t.id
;

END $function$

*/
 }
/**
 * @function meta_help_c
 * @memberof zzglc
 * @description Meta help c
 * @param {character_varying} Json
 * @returns {void}
 */
function meta_help_c() {
/*
CREATE OR REPLACE FUNCTION zzglc.meta_help_c("Json" character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

    INSERT INTO meta.help (
        name
    )
    SELECT
        U.name
    FROM
        json_to_record("Json"::json) U (
            name character varying
        ) 
;
END $function$

*/
 }
/**
 * @function meta_help_r
 * @memberof zzglc
 * @description Meta help r
 * @returns {Object}
 * @property {integer} id
 * @property {character_varying} name
 */
function meta_help_r() {
/*
CREATE OR REPLACE FUNCTION zzglc.meta_help_r()
 RETURNS TABLE(id integer, name character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

    RETURN QUERY
    SELECT
    t.id, t.name
    FROM meta.help t
;
END $function$

*/
 }
/**
 * @function data_lu_detail_c
 * @memberof zzglc
 * @description Data lu detail c
 * @param {character_varying} Json
 * @returns {void}
 */
function data_lu_detail_c() {
/*
CREATE OR REPLACE FUNCTION zzglc.data_lu_detail_c("Json" character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

    INSERT INTO data.lu_detail (
        name,
        color_id,
        code
    )
    SELECT
        U.name,
        U.color_id,
        U.code
    FROM
        json_to_record("Json"::json) U (
name character varying,
            color_id integer,
            code character(4)
        ) 
;
END $function$

*/
 }
/**
 * @function general_boundary_r
 * @memberof zzglc
 * @description General boundary r
 * @returns {Object}
 * @property {integer} id
 * @property {integer} osm_id
 * @property {integer} admin_level
 * @property {character_varying} name
 * @property {character_varying} local_name
 */
function general_boundary_r() {
/*
CREATE OR REPLACE FUNCTION zzglc.general_boundary_r()
 RETURNS TABLE(id integer, osm_id integer, admin_level integer, name character varying, local_name character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

    RETURN QUERY
    SELECT
    t.id, t.osm_id, t.admin_level, t.name, t.local_name
    FROM general.boundary t
;
END $function$

*/
 }
/**
 * @function data_file_sd_type_l
 * @memberof zzgll
 * @description Data file sd type l
 * @param {character_varying} SearchValue
 * @param {integer} Key
 * @returns {Object}
 * @property {integer} id
 * @property {character_varying} name
 */
function data_file_sd_type_l() {
/*
CREATE OR REPLACE FUNCTION zzgll.data_file_sd_type_l("SearchValue" character varying, "Key" integer DEFAULT NULL::integer)
 RETURNS TABLE(id integer, name character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

        IF "Key" IS NOT NULL THEN
            RETURN QUERY
            SELECT t.id, t.name
            FROM data.file_sd_type t
            WHERE t.id = "Key"::integer;
        ELSE
            RETURN QUERY
           SELECT t.id, t.name
            FROM data.file_sd_type t
            WHERE t.name LIKE "SearchValue"
            ORDER BY t.name
           LIMIT 1000;
       END IF;
END $function$

*/
 }
/**
 * @function data_custom_geometry_property_d
 * @memberof zzglc
 * @description Data custom geometry property d
 * @param {integer} Key
 * @returns {void}
 */
function data_custom_geometry_property_d() {
/*
CREATE OR REPLACE FUNCTION zzglc.data_custom_geometry_property_d("Key" integer)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

    DELETE FROM data.custom_geometry_property
    WHERE id = "Key";

END $function$

*/
 }
/**
 * @function get_context_person_id
 * @memberof auth
 * @description Get context person id
 * @returns {integer}
 */
function get_context_person_id() {
/*
CREATE OR REPLACE FUNCTION auth.get_context_person_id()
 RETURNS integer
 LANGUAGE plpgsql
AS $function$ 
BEGIN

	RETURN current_setting('context.person_id', true)::int;
END $function$

*/
 }
/**
 * @function prepare_import_proc
 * @memberof meta
 * @description Prepare import proc
 * @param {integer} Id
 * @returns {void}
 */
function prepare_import_proc() {
/*
CREATE OR REPLACE FUNCTION meta.prepare_import_proc("Id" integer)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
	DECLARE v_sql TEXT;
	   v_subsql TEXT;
		 v_master VARCHAR;
		 v_master_table VARCHAR;
		 v_master_schema VARCHAR;
		 v_detail VARCHAR;
	   v_fragment VARCHAR;
		 v_schema VARCHAR;
		 v_table VARCHAR;
		 v_key_source VARCHAR;
		 v_key_target VARCHAR;
		 v_read_list VARCHAR;
		 v_source_list VARCHAR;
		 v_target_list VARCHAR;
		 v_dummy VARCHAR;
		 v_target_column_list VARCHAR;
		 v_source_column_list VARCHAR;
		 v_joins VARCHAR;
		 v_col_name VARCHAR;
		 v_col_type VARCHAR;
		 v_clean_name VARCHAR;
		 v_split BOOL;
		 v_master_key VARCHAR;
		 v_target_column VARCHAR;
		 v_target_table VARCHAR;
		 v_trace VARCHAR;
BEGIN

	DROP TABLE IF EXISTS t;
	CREATE TEMP TABLE t AS
	SELECT m.schema_name, m.table_name, d.col_name, d.target_schema, d.target_table, d.target_column, d.col_type, d.name, d.is_fk, d.is_key, d.as_row, d.target_column_list, d.source_column_list, d.joins, d.split, d.ignore, d.ignore_in_master, d.constant_value
 	FROM meta.import_master m
 	INNER JOIN meta.import_detail d ON d.import_master_id = m.id
 	WHERE m.id = "Id" -- AND d.target_table > ''
	ORDER by d.id;	
	
	SELECT m.schema_name || '.' ||m.table_name, m.table_name, m.schema_name
	INTO v_master, v_master_table, v_master_schema
	FROM meta.import_master m 
	WHERE m.id = "Id";
	
	SELECT col_name INTO v_master_key FROM t WHERE t.is_key AND NOT t.is_fk;
	
	-- RAISE NOTICE '%', v_master;
	
	-- create all detail tables
	FOR v_schema, v_table, v_detail IN 
		SELECT DISTINCT t.target_schema, t.target_table, t.name 
		FROM t WHERE t.name &lt;> v_master AND NOT t.ignore AND t.as_row = false AND NOT t.split
		LOOP

		IF NOT EXISTS (SELECT 1 FROM pg_tables WHERE schemaname = v_schema AND tablename = v_table) THEN
			
			SELECT string_agg(t.target_column || ' ' || t.col_type, ', ')
			INTO v_fragment
			FROM t 
			WHERE t.target_schema = v_schema AND t.target_table = v_table;
			
			v_sql := E'CREATE TABLE ' || v_detail || 
			'(id int primary key generated always as identity, ' || v_fragment || E');\n';
			
			-- RAISE NOTICE '%', v_sql;
			
			EXECUTE v_sql;
			
			EXECUTE 'ALTER TABLE ' || v_detail || ' OWNER TO gl';
			
		END IF;
				
  END LOOP;
	
		-- create all link tables
	FOR v_schema, v_table, v_detail IN 
		SELECT DISTINCT t.target_schema, t.target_table, t.name 
		FROM t WHERE t.name &lt;> v_master AND (NOT t.ignore OR t.is_fk) AND t.as_row = false AND t.split
		LOOP

		RAISE NOTICE '% %', v_schema, v_master_table || '_' || v_table;
		
		IF NOT EXISTS (SELECT 1 FROM pg_tables WHERE schemaname = v_master_schema AND tablename = v_master_table || '_' || v_table) THEN		
			v_sql := E'CREATE TABLE ' || v_master || '_' || v_table || 
			'(id int primary key generated always as identity, ' || v_master_table || '_id int, ' || v_table || '_id int' || E');\n';
			
			RAISE NOTICE '%', v_sql;
			
			EXECUTE v_sql;
			
			EXECUTE 'ALTER TABLE ' || v_master || '_' || v_table || ' OWNER TO gl';
			
		END IF;
				
  END LOOP;
	
	-- create master table
	IF NOT EXISTS (SELECT 1 FROM pg_tables WHERE schemaname || '.' || tablename = v_master) THEN
		
		SELECT string_agg(
			CASE WHEN t.is_fk THEN 
				t.target_table || '_id int REFERENCES ' || t.target_schema || '.' || t.target_table || '(id)'
			ELSE 
				t.target_column || ' ' || t.col_type
			END
			, ', ')	INTO v_fragment
		FROM t 
		WHERE NOT t.split AND ((t.name = v_master) OR t.is_fk);
		
		v_sql := E'\nCREATE TABLE ' || v_master || 
		'(id int primary key generated always as identity, ' || v_fragment || E');\n';
		
		RAISE NOTICE '%', v_sql;
		EXECUTE v_sql;
		
		EXECUTE 'ALTER TABLE ' || v_master || ' OWNER TO gl';
		
	END IF;

--return;

  -- create import procedeure
	SELECT 
	'CREATE OR REPLACE FUNCTION ' || m.schema_name || '.import_' || m.import_name || 
	E' ("jsonCV" text, "jsonData" text)\n' 
  'RETURNS pg_catalog.void AS $$\n'
	'BEGIN\n' 
	'DROP TABLE IF EXISTS t;\n'
	'CREATE TEMP TABLE t AS\n'
	'SELECT * FROM json_to_recordset("jsonData"::json) AS J(\n'
	INTO v_sql
	FROM meta.import_master m
	WHERE m.id = "Id";
	
 	SELECT string_agg('"' || col_name || '" varchar', ', ') 
	INTO v_fragment
 	FROM t;
	
	v_sql := v_sql || v_fragment || E');\n';
	
	IF v_sql IS NULL THEN
		RAISE NOTICE 'null 1';
	END IF;
	
-- 	SELECT json_agg(x.*) INTO v_trace
-- 	FROM (
-- 	SELECT DISTINCT CASE WHEN t.name != v_master THEN 'A' ELSE 'B' END, t.target_schema, t.target_table, t.name, t.split, t.target_column
-- 	FROM t 
-- 	WHERE t.as_row = false and t.target_table > '' ORDER BY 1
--   ) x;
-- 	RAISE NOTICE '%', v_trace;
	
	-- import tables
	
	FOR v_dummy, v_schema, v_table, v_detail, v_split, v_target_column, v_col_name IN 
	SELECT DISTINCT CASE WHEN t.name != v_master THEN 'A' ELSE 'B' END, t.target_schema, t.target_table, t.name, t.split, t.target_column, t.col_name
	FROM t 
	WHERE t.as_row = false AND NOT t.ignore AND (t.name != v_master OR t.name = v_master AND t.is_key)
	ORDER BY 1
	LOOP
	
		RAISE NOTICE 'loop step % % % % %', v_detail, v_dummy, v_schema, v_table, v_split;
		
    -- get key column	 
		SELECT col_name, target_column INTO v_key_source, v_key_target
		FROM t 
		WHERE NOT t.ignore 
		AND ((t.name = v_detail AND t.is_key)  -- it is a key for foreign table
		  OR (v_dummy = 'B' AND t.is_key AND t.name = v_master)  -- it is main tabke
		);
		
		IF v_split THEN
			v_fragment := E'\nCREATE TEMP TABLE temp_' || v_table || E' AS\n'
			'SELECT "' || v_master_key || '", TRIM(s) ' || v_col_name || E' FROM t\n'
			'CROSS JOIN LATERAL string_to_table("' || v_col_name || '", '','') s';
			RAISE NOTICE 'ctt: %', v_fragment;
			v_sql := v_sql || v_fragment || E';\n';
			IF v_sql IS NULL THEN
				RAISE NOTICE 'null 2';
	    END IF;
	
		END IF;
		
		-- create list for insert
		SELECT 
			string_agg(CASE WHEN t.is_fk AND v_dummy = 'B' THEN t.target_table || '_id' ELSE t.target_column END, ', '), 
			string_agg('t."' || t.col_name || '"', ', '),
			string_agg(
				CASE 
				WHEN t.is_fk AND t.name != v_detail 
				THEN 
					t.target_table || '.id' 
				WHEN t.constant_value IS NOT NULL THEN
					t.constant_value
				ELSE 
					'meta.clean_value(x."' || t.col_name || '", ''' || t.col_type || ''')::' || t.col_type 
				END
				, ', ')
		INTO v_target_list, v_read_list, v_source_list
		FROM t
		WHERE t.as_row = false and NOT t.ignore AND
		(t.name = v_detail OR v_dummy = 'B' AND NOT t.split AND NOT t.ignore_in_master);
		
		--RAISE NOTICE 'ttt % % %', v_target_list, v_read_list, v_source_list;
		
	
		v_subsql := E'\nWITH x AS (SELECT DISTINCT ' || v_read_list || ' FROM ' || 
		CASE WHEN v_split THEN 'temp_' || v_table ELSE '' END
		|| E' t)\n'
		 'INSERT INTO ' || v_detail || '(';	 
		 
    v_subsql := v_subsql || v_target_list	|| E')\n'
		'SELECT ' || v_source_list || E' FROM x\n'
		'LEFT JOIN ' || v_schema || '.' || v_table || ' ' || v_table || ' ON ' || v_table || '.' || v_key_target || '= x."' || v_key_source || E'"\n';		

		-- RAISE NOTICE 'xxx v_subsql %', v_subsql;
		
		v_fragment := '';

		-- create joins
		IF v_detail = v_master THEN

			SELECT string_agg(
				'LEFT JOIN ' || t.name || ' ' || t.target_table || ' ON ' || t.target_table || '.' || t.target_column || ' = x."' || t.col_name || '"', E'\n'
			)
			INTO v_fragment
			FROM t 
			WHERE t.is_fk AND NOT t.split AND NOT t.ignore AND NOT t.ignore_in_master;
			v_fragment = v_fragment || E'\n';
			
		END IF;
			
		--RAISE NOTICE 'xxx % %', v_fragment, v_subsql;		
		
		v_subsql := v_subsql || COALESCE(v_fragment, '') || 'WHERE ' || v_table || E'.id IS NULL;\n\n'	; 
		
		--RAISE NOTICE 'v_subsql: %', v_subsql;			
			
		v_sql := v_sql || v_subsql;
		IF v_sql IS NULL THEN
		  RAISE NOTICE 'null 3';
	  END IF;
	
		
  END LOOP;	

	SELECT col_name, target_column INTO v_key_source, v_key_target FROM t WHERE t.is_key AND t.name = v_master;
	
	-- create insert for link tables
	FOR v_target_column, v_target_table, v_detail, v_col_name IN
	SELECT t.target_column, t.target_table, t.name, t.col_name FROM t WHERE t.split
	LOOP
		v_fragment := 'INSERT INTO ' || v_master || '_' || v_target_table || ' (' || v_master_table || '_id, ' || v_target_table || E'_id )\n'
		'SELECT m.id, d.id FROM temp_' || v_target_table || E' x\n'
		'INNER JOIN ' || v_master || ' m ON m."' || v_key_target || '" = x."' || v_key_source || E'"\n'
		'INNER JOIN ' || v_detail || ' d ON d.' || v_target_column || ' = x."' || v_col_name || E'"\n'
		'LEFT JOIN ' || v_master || '_' || v_target_table || ' l ON l.' || v_master_table || '_id = m.id AND l.' || v_target_table || E'_id = d.id\n' 
		'WHERE l.id IS NULL;\n';
		RAISE NOTICE 'link insert: %d', v_fragment;
		v_sql := v_sql || v_fragment;
		IF v_sql IS NULL THEN
		  RAISE NOTICE 'null 4';
	  END IF;
	
	END LOOP;
	
	-- create insert for as_row's

	FOR v_detail, v_col_name, v_col_type, v_target_column_list, v_source_column_list, v_joins IN 
	SELECT t.name, t.col_name, t.col_type, t.target_column_list, t.source_column_list, t.joins
	FROM t 
	WHERE t.as_row = true
	LOOP
	
		--RAISE NOTICE 'creating % % % % % %' , v_detail, v_col_name, v_col_type, v_target_column_list, v_source_column_list, v_joins;
		
		v_clean_name := 'meta.clean_value(t."' || v_col_name || '", ' || '''' || v_col_type || ''')::' || v_col_type;

		v_subsql = E'\nINSERT INTO ' || v_detail || '(' || v_target_column_list || E')\n'
		'SELECT ' || REPLACE (v_source_column_list, 'col_name', v_clean_name) || E' FROM t\n'
		'LEFT JOIN ' || v_master || ' x ON x.' || v_key_target || ' = t."' || v_key_source || E'"\n'
		|| v_joins || E'\nWHERE y.id IS NULL AND ' || v_clean_name || E' IS NOT NULL ;\n';		
		
		RAISE NOTICE '%', v_subsql;
		
		v_sql := v_sql || v_subsql;

	END LOOP;
	
	v_sql := v_sql || E'\nEND $$ LANGUAGE plpgsql';
	
	-- RAISE NOTICE 'done, executing';
	
	-- RAISE NOTICE 'Final sql: % %', LENGTH(v_sql), v_sql;
	-- RAISE NOTICE 'End final sql:';
	DELETE FROM meta.trace;
	INSERT INTO meta.trace (text) VALUES(v_sql);
	
	EXECUTE v_sql;
	
	RETURN;
END$function$

*/
 }
/**
 * @function general_partner_c
 * @memberof zzglc
 * @description General partner c
 * @param {character_varying} Json
 * @returns {void}
 */
function general_partner_c() {
/*
CREATE OR REPLACE FUNCTION zzglc.general_partner_c("Json" character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

    INSERT INTO general.partner (
        short_name,
        name,
        user_modified
    )
    SELECT
        U.short_name,
        U.name,
        U.user_modified
    FROM
        json_to_record("Json"::json) U (
            short_name character varying,
            name character varying,
            user_modified integer
        ) 
;
END $function$

*/
 }
/**
 * @function get_i18n
 * @memberof meta
 * @description Get i18n
 * @param {integer} LangId
 * @returns {json}
 */
function get_i18n() {
/*
CREATE OR REPLACE FUNCTION meta.get_i18n("LangId" integer)
 RETURNS json
 LANGUAGE plpgsql
AS $function$
	BEGIN

	-- Routine body goes here...
	RETURN (
		-- SELECT json_agg(json_build_object(i.key, l.value))
		SELECT json_object_agg(i.key, l.value)
		FROM meta.i18n i
		INNER JOIN meta.i18n_lang l ON l.i18n_id = i.id and l.lang_id = "LangId"
	);
END$function$

*/
 }
/**
 * @function data_point_import_excel
 * @memberof data
 * @description Data point import excel
 * @param {text} jsonCV
 * @param {text} jsonData
 * @returns {void}
 */
function data_point_import_excel() {
/*
CREATE OR REPLACE FUNCTION data.data_point_import_excel("jsonCV" text, "jsonData" text)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

DROP TABLE IF EXISTS t;
CREATE TEMP TABLE t AS
SELECT * FROM json_to_recordset("jsonData"::json) AS J(
"Depth" varchar, "POINTID" varchar, "pH_CaCl2" varchar, "pH_H2O" varchar, "EC" varchar, "OC" varchar, "CaCO3" varchar, "P" varchar, "N" varchar, "K" varchar, "OC (20-30 cm)" varchar, "CaCO3 (20-30 cm)" varchar, "Ox_Al" varchar, "Ox_Fe" varchar, "NUTS_0" varchar, "NUTS_1" varchar, "NUTS_2" varchar, "NUTS_3" varchar, "TH_LAT" varchar, "TH_LONG" varchar, "SURVEY_DATE" varchar, "Elev" varchar, "LC" varchar, "LU" varchar, "LC0_Desc" varchar, "LC1_Desc" varchar, "LU1_Desc" varchar);

WITH x AS (SELECT DISTINCT t."Depth" FROM t)
INSERT INTO data.depth(name)
SELECT meta.clean_value(x."Depth", 'varchar')::varchar FROM x
LEFT JOIN data.depth depth ON depth.name= x."Depth"
WHERE depth.id IS NULL;

WITH x AS (SELECT DISTINCT t."LC" FROM t)
INSERT INTO data.lc(name)
SELECT meta.clean_value(x."LC", 'varchar')::varchar FROM x
LEFT JOIN data.lc lc ON lc.name= x."LC"
WHERE lc.id IS NULL;

WITH x AS (SELECT DISTINCT t."LC1_Desc" FROM t)
INSERT INTO data.lc_detail(name)
SELECT meta.clean_value(x."LC1_Desc", 'varchar')::varchar FROM x
LEFT JOIN data.lc_detail lc_detail ON lc_detail.name= x."LC1_Desc"
WHERE lc_detail.id IS NULL;

WITH x AS (SELECT DISTINCT t."LC0_Desc" FROM t)
INSERT INTO data.lc_main(name)
SELECT meta.clean_value(x."LC0_Desc", 'varchar')::varchar FROM x
LEFT JOIN data.lc_main lc_main ON lc_main.name= x."LC0_Desc"
WHERE lc_main.id IS NULL;

WITH x AS (SELECT DISTINCT t."LU" FROM t)
INSERT INTO data.lu(name)
SELECT meta.clean_value(x."LU", 'varchar')::varchar FROM x
LEFT JOIN data.lu lu ON lu.name= x."LU"
WHERE lu.id IS NULL;

WITH x AS (SELECT DISTINCT t."LU1_Desc" FROM t)
INSERT INTO data.lu_detail(name)
SELECT meta.clean_value(x."LU1_Desc", 'varchar')::varchar FROM x
LEFT JOIN data.lu_detail lu_detail ON lu_detail.name= x."LU1_Desc"
WHERE lu_detail.id IS NULL;

WITH x AS (SELECT DISTINCT t."NUTS_0" FROM t)
INSERT INTO data.nuts_0(name)
SELECT meta.clean_value(x."NUTS_0", 'varchar')::varchar FROM x
LEFT JOIN data.nuts_0 nuts_0 ON nuts_0.name= x."NUTS_0"
WHERE nuts_0.id IS NULL;

WITH x AS (SELECT DISTINCT t."NUTS_1" FROM t)
INSERT INTO data.nuts_1(name)
SELECT meta.clean_value(x."NUTS_1", 'varchar')::varchar FROM x
LEFT JOIN data.nuts_1 nuts_1 ON nuts_1.name= x."NUTS_1"
WHERE nuts_1.id IS NULL;

WITH x AS (SELECT DISTINCT t."NUTS_2" FROM t)
INSERT INTO data.nuts_2(name)
SELECT meta.clean_value(x."NUTS_2", 'varchar')::varchar FROM x
LEFT JOIN data.nuts_2 nuts_2 ON nuts_2.name= x."NUTS_2"
WHERE nuts_2.id IS NULL;

WITH x AS (SELECT DISTINCT t."NUTS_3" FROM t)
INSERT INTO data.nuts_3(name)
SELECT meta.clean_value(x."NUTS_3", 'varchar')::varchar FROM x
LEFT JOIN data.nuts_3 nuts_3 ON nuts_3.name= x."NUTS_3"
WHERE nuts_3.id IS NULL;

WITH x AS (SELECT DISTINCT t."Depth", t."POINTID", t."NUTS_0", t."NUTS_1", t."NUTS_2", t."NUTS_3", t."TH_LAT", t."TH_LONG", t."Elev", t."LC", t."LU", t."LC0_Desc", t."LC1_Desc", t."LU1_Desc" FROM t)
INSERT INTO data.point(depth_id, point_key, nuts_0_id, nuts_1_id, nuts_2_id, nuts_3_id, lat, lon, elev, lc_id, lu_id, lc_main_id, lc_detail_id, lu_detail_id)
SELECT depth.id, meta.clean_value(x."POINTID", 'varchar')::varchar, nuts_0.id, nuts_1.id, nuts_2.id, nuts_3.id, meta.clean_value(x."TH_LAT", 'float')::float, meta.clean_value(x."TH_LONG", 'float')::float, meta.clean_value(x."Elev", 'int')::int, lc.id, lu.id, lc_main.id, lc_detail.id, lu_detail.id FROM x
LEFT JOIN data.point point ON point.point_key= x."POINTID"
LEFT JOIN data.depth depth ON depth.name = x."Depth"
LEFT JOIN data.nuts_0 nuts_0 ON nuts_0.name = x."NUTS_0"
LEFT JOIN data.nuts_1 nuts_1 ON nuts_1.name = x."NUTS_1"
LEFT JOIN data.nuts_2 nuts_2 ON nuts_2.name = x."NUTS_2"
LEFT JOIN data.nuts_3 nuts_3 ON nuts_3.name = x."NUTS_3"
LEFT JOIN data.lc lc ON lc.name = x."LC"
LEFT JOIN data.lu lu ON lu.name = x."LU"
LEFT JOIN data.lc_main lc_main ON lc_main.name = x."LC0_Desc"
LEFT JOIN data.lc_detail lc_detail ON lc_detail.name = x."LC1_Desc"
LEFT JOIN data.lu_detail lu_detail ON lu_detail.name = x."LU1_Desc"
WHERE point.id IS NULL;

INSERT INTO data.measurement(point_id, indicator_id, value, date)
SELECT x.id, i.id, meta.clean_value(t."pH_CaCl2", 'float')::float, meta.clean_value(t."SURVEY_DATE", 'date')::date FROM t
LEFT JOIN data.point x ON x.point_key = t."POINTID"
left join data.indicator i on i.name = 'pH (CaCl2)' left join data.measurement y on y.point_id = x.id and y.indicator_id = i.id and y.date = meta.clean_value(t."SURVEY_DATE", 'date')::date
WHERE y.id IS NULL AND meta.clean_value(t."pH_CaCl2", 'float')::float IS NOT NULL ;

INSERT INTO data.measurement(point_id, indicator_id, value, date)
SELECT x.id, i.id, meta.clean_value(t."pH_H2O", 'float')::float, meta.clean_value(t."SURVEY_DATE", 'date')::date FROM t
LEFT JOIN data.point x ON x.point_key = t."POINTID"
left join data.indicator i on i.name = 'pH (H2O)' left join data.measurement y on y.point_id = x.id and y.indicator_id = i.id and y.date = meta.clean_value(t."SURVEY_DATE", 'date')::date
WHERE y.id IS NULL AND meta.clean_value(t."pH_H2O", 'float')::float IS NOT NULL ;

INSERT INTO data.measurement(point_id, indicator_id, value, date)
SELECT x.id, i.id, meta.clean_value(t."EC", 'float')::float, meta.clean_value(t."SURVEY_DATE", 'date')::date FROM t
LEFT JOIN data.point x ON x.point_key = t."POINTID"
left join data.indicator i on i.name = 'EC' left join data.measurement y on y.point_id = x.id and y.indicator_id = i.id and y.date = meta.clean_value(t."SURVEY_DATE", 'date')::date
WHERE y.id IS NULL AND meta.clean_value(t."EC", 'float')::float IS NOT NULL ;

INSERT INTO data.measurement(point_id, indicator_id, value, date)
SELECT x.id, i.id, meta.clean_value(t."OC", 'float')::float, meta.clean_value(t."SURVEY_DATE", 'date')::date FROM t
LEFT JOIN data.point x ON x.point_key = t."POINTID"
left join data.indicator i on i.name = 'OC' left join data.measurement y on y.point_id = x.id and y.indicator_id = i.id and y.date = meta.clean_value(t."SURVEY_DATE", 'date')::date
WHERE y.id IS NULL AND meta.clean_value(t."OC", 'float')::float IS NOT NULL ;

INSERT INTO data.measurement(point_id, indicator_id, value, date)
SELECT x.id, i.id, meta.clean_value(t."CaCO3", 'float')::float, meta.clean_value(t."SURVEY_DATE", 'date')::date FROM t
LEFT JOIN data.point x ON x.point_key = t."POINTID"
left join data.indicator i on i.name = 'CaCO3' left join data.measurement y on y.point_id = x.id and y.indicator_id = i.id and y.date = meta.clean_value(t."SURVEY_DATE", 'date')::date
WHERE y.id IS NULL AND meta.clean_value(t."CaCO3", 'float')::float IS NOT NULL ;

INSERT INTO data.measurement(point_id, indicator_id, value, date)
SELECT x.id, i.id, meta.clean_value(t."P", 'float')::float, meta.clean_value(t."SURVEY_DATE", 'date')::date FROM t
LEFT JOIN data.point x ON x.point_key = t."POINTID"
left join data.indicator i on i.name = 'P' left join data.measurement y on y.point_id = x.id and y.indicator_id = i.id and y.date = meta.clean_value(t."SURVEY_DATE", 'date')::date
WHERE y.id IS NULL AND meta.clean_value(t."P", 'float')::float IS NOT NULL ;

INSERT INTO data.measurement(point_id, indicator_id, value, date)
SELECT x.id, i.id, meta.clean_value(t."N", 'float')::float, meta.clean_value(t."SURVEY_DATE", 'date')::date FROM t
LEFT JOIN data.point x ON x.point_key = t."POINTID"
left join data.indicator i on i.name = 'N' left join data.measurement y on y.point_id = x.id and y.indicator_id = i.id and y.date = meta.clean_value(t."SURVEY_DATE", 'date')::date
WHERE y.id IS NULL AND meta.clean_value(t."N", 'float')::float IS NOT NULL ;

INSERT INTO data.measurement(point_id, indicator_id, value, date)
SELECT x.id, i.id, meta.clean_value(t."K", 'float')::float, meta.clean_value(t."SURVEY_DATE", 'date')::date FROM t
LEFT JOIN data.point x ON x.point_key = t."POINTID"
left join data.indicator i on i.name = 'K' left join data.measurement y on y.point_id = x.id and y.indicator_id = i.id and y.date = meta.clean_value(t."SURVEY_DATE", 'date')::date
WHERE y.id IS NULL AND meta.clean_value(t."K", 'float')::float IS NOT NULL ;

INSERT INTO data.measurement(point_id, indicator_id, value, date)
SELECT x.id, i.id, meta.clean_value(t."OC (20-30 cm)", 'float')::float, meta.clean_value(t."SURVEY_DATE", 'date')::date FROM t
LEFT JOIN data.point x ON x.point_key = t."POINTID"
left join data.indicator i on i.name = 'OC (20-30 cm)' left join data.measurement y on y.point_id = x.id and y.indicator_id = i.id and y.date = meta.clean_value(t."SURVEY_DATE", 'date')::date
WHERE y.id IS NULL AND meta.clean_value(t."OC (20-30 cm)", 'float')::float IS NOT NULL ;

INSERT INTO data.measurement(point_id, indicator_id, value, date)
SELECT x.id, i.id, meta.clean_value(t."CaCO3 (20-30 cm)", 'float')::float, meta.clean_value(t."SURVEY_DATE", 'date')::date FROM t
LEFT JOIN data.point x ON x.point_key = t."POINTID"
left join data.indicator i on i.name = 'CaCO3 (20-30 cm)' left join data.measurement y on y.point_id = x.id and y.indicator_id = i.id and y.date = meta.clean_value(t."SURVEY_DATE", 'date')::date
WHERE y.id IS NULL AND meta.clean_value(t."CaCO3 (20-30 cm)", 'float')::float IS NOT NULL ;

INSERT INTO data.measurement(point_id, indicator_id, value, date)
SELECT x.id, i.id, meta.clean_value(t."Ox_Al", 'float')::float, meta.clean_value(t."SURVEY_DATE", 'date')::date FROM t
LEFT JOIN data.point x ON x.point_key = t."POINTID"
left join data.indicator i on i.name = 'Ox_Al' left join data.measurement y on y.point_id = x.id and y.indicator_id = i.id and y.date = meta.clean_value(t."SURVEY_DATE", 'date')::date
WHERE y.id IS NULL AND meta.clean_value(t."Ox_Al", 'float')::float IS NOT NULL ;

INSERT INTO data.measurement(point_id, indicator_id, value, date)
SELECT x.id, i.id, meta.clean_value(t."Ox_Fe", 'float')::float, meta.clean_value(t."SURVEY_DATE", 'date')::date FROM t
LEFT JOIN data.point x ON x.point_key = t."POINTID"
left join data.indicator i on i.name = 'Ox_Fe' left join data.measurement y on y.point_id = x.id and y.indicator_id = i.id and y.date = meta.clean_value(t."SURVEY_DATE", 'date')::date
WHERE y.id IS NULL AND meta.clean_value(t."Ox_Fe", 'float')::float IS NOT NULL ;

END $function$

*/
 }
/**
 * @function data_unit_c
 * @memberof zzglc
 * @description Data unit c
 * @param {character_varying} Json
 * @returns {void}
 */
function data_unit_c() {
/*
CREATE OR REPLACE FUNCTION zzglc.data_unit_c("Json" character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

    INSERT INTO data.unit (
        name
    )
    SELECT
        U.name
    FROM
        json_to_record("Json"::json) U (
name character varying(255)
        ) 
;
END $function$

*/
 }
/**
 * @function data_date_style_u
 * @memberof zzglc
 * @description Data date style u
 * @param {character_varying} Json
 * @returns {void}
 */
function data_date_style_u() {
/*
CREATE OR REPLACE FUNCTION zzglc.data_date_style_u("Json" character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE v_row_count INTEGER;
BEGIN

    UPDATE data.date_style t
    SET name = U.name 
    FROM json_to_record("Json"::json) AS U (
        id integer,
            name character varying
    ) 
    WHERE U.id = t.id
;

END $function$

*/
 }
/**
 * @function general_person_u
 * @memberof zzglc
 * @description General person u
 * @param {character_varying} Json
 * @returns {void}
 */
function general_person_u() {
/*
CREATE OR REPLACE FUNCTION zzglc.general_person_u("Json" character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE v_row_count INTEGER;
BEGIN

    UPDATE general.person t
    SET first_name = U.first_name,
        last_name = U.last_name,
        partner_id = U.partner_id,
        email = U.email,
        name1 = U.name1,
        user_email = U.user_email 
    FROM json_to_record("Json"::json) AS U (
        id integer,
            first_name character varying(255),
            last_name character varying(255),
            partner_id integer,
            email character varying(255),
            name character varying,
            name1 character varying(255),
            user_email character varying(255)
    ) 
    WHERE U.id = t.id
;

END $function$

*/
 }
/**
 * @function general_person_r
 * @memberof zzglc
 * @description General person r
 * @returns {Object}
 * @property {integer} id
 * @property {character_varying} first_name
 * @property {character_varying} last_name
 * @property {integer} partner_id
 * @property {character_varying} email
 * @property {character_varying} name
 * @property {character_varying} name1
 * @property {character_varying} user_email
 * @property {character_varying} partner_id_val
 */
function general_person_r() {
/*
CREATE OR REPLACE FUNCTION zzglc.general_person_r()
 RETURNS TABLE(id integer, first_name character varying, last_name character varying, partner_id integer, email character varying, name character varying, name1 character varying, user_email character varying, partner_id_val character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

    RETURN QUERY
    SELECT
    t.id, t.first_name, t.last_name, t.partner_id, t.email, t.name, t.name1, t.user_email
    , partner_id_t.short_name::VARCHAR AS partner_id_val
    FROM general.person t

    LEFT JOIN general.partner partner_id_t ON partner_id_t.id = t.partner_id
    
    ORDER BY t.last_name, t.first_name
;
END $function$

*/
 }
/**
 * @function data_data_source_u
 * @memberof zzglc
 * @description Data data source u
 * @param {character_varying} Json
 * @returns {void}
 */
function data_data_source_u() {
/*
CREATE OR REPLACE FUNCTION zzglc.data_data_source_u("Json" character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE v_row_count INTEGER;
BEGIN

    UPDATE data.data_source t
    SET name = U.name,
        srid = U.srid 
    FROM json_to_record("Json"::json) AS U (
        id integer,
            name character varying(255),
            srid integer
    ) 
    WHERE U.id = t.id
;

END $function$

*/
 }
/**
 * @function data_data_source_r
 * @memberof zzglc
 * @description Data data source r
 * @returns {Object}
 * @property {integer} id
 * @property {character_varying} name
 * @property {integer} srid
 */
function data_data_source_r() {
/*
CREATE OR REPLACE FUNCTION zzglc.data_data_source_r()
 RETURNS TABLE(id integer, name character varying, srid integer)
 LANGUAGE plpgsql
AS $function$
BEGIN

    RETURN QUERY
    SELECT
    t.id, t.name, t.srid
    FROM data.data_source t
    
    ORDER BY t.name
;
END $function$

*/
 }
/**
 * @function general_partner_l
 * @memberof zzgll
 * @description General partner l
 * @param {character_varying} SearchValue
 * @param {integer} Key
 * @returns {Object}
 * @property {integer} id
 * @property {character_varying} name
 */
function general_partner_l() {
/*
CREATE OR REPLACE FUNCTION zzgll.general_partner_l("SearchValue" character varying, "Key" integer DEFAULT NULL::integer)
 RETURNS TABLE(id integer, name character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

	IF "Key" IS NOT NULL THEN
			RETURN QUERY
			SELECT t.id, t.short_name
			FROM general.partner t
			WHERE t.id = "Key"::integer;
	ELSE
			RETURN QUERY
		 SELECT t.id, t.short_name
			FROM general.partner t
			WHERE t.name LIKE "SearchValue"
			ORDER BY t.name
		 LIMIT 1000;
  END IF;
END $function$

*/
 }
/**
 * @function get_shapes_for_data_source
 * @memberof data
 * @description Get shapes for data source
 * @param {integer} DataSourceId
 * @returns {json}
 */
function get_shapes_for_data_source() {
/*
CREATE OR REPLACE FUNCTION data.get_shapes_for_data_source("DataSourceId" integer)
 RETURNS json
 LANGUAGE plpgsql
AS $function$
BEGIN

	RETURN (
		SELECT json_agg(t.*) FROM (
			SELECT id value, name label 
			FROM data.shape
			WHERE data_source_id = "DataSourceId"
			ORDER BY 2
		) t	
	);
END$function$

*/
 }
/**
 * @function general_country_d
 * @memberof zzglc
 * @description General country d
 * @param {smallint} Key
 * @returns {void}
 */
function general_country_d() {
/*
CREATE OR REPLACE FUNCTION zzglc.general_country_d("Key" smallint)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

    DELETE FROM general.country
    WHERE id = "Key";

END $function$

*/
 }
/**
 * @function data_geometry_type_u
 * @memberof zzglc
 * @description Data geometry type u
 * @param {character_varying} Json
 * @returns {void}
 */
function data_geometry_type_u() {
/*
CREATE OR REPLACE FUNCTION zzglc.data_geometry_type_u("Json" character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE v_row_count INTEGER;
BEGIN

    UPDATE data.geometry_type t
    SET name = U.name 
    FROM json_to_record("Json"::json) AS U (
        id integer,
            name character varying(255)
    ) 
    WHERE U.id = t.id
;

END $function$

*/
 }
/**
 * @function update_backoffice_routes
 * @memberof meta
 * @description Update backoffice routes
 * @returns {void}
 */
function update_backoffice_routes() {
/*
CREATE OR REPLACE FUNCTION meta.update_backoffice_routes()
 RETURNS void
 LANGUAGE plpgsql
AS $function$
	BEGIN

	
		--DROP FOREIGN TABLE meta.vw_ai4soilhealth_hierarchy;
		--IMPORT FOREIGN SCHEMA meta LIMIT TO (vw_ai4soilhealth_hierarchy)
		--FROM SERVER gl
		--INTO meta;		
		--GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA meta TO gl;
		
		WITH RECURSIVE t AS (
			SELECT * FROM meta.route r 
			WHERE r.name = 'Backoffice'
			UNION ALL
			SELECT c.* FROM meta.route c
			INNER JOIN t ON t.name = c.parent
		)
		DELETE FROM meta.route r
		WHERE name IN (SELECT name FROM t) AND name != 'Backoffice';
		--SELECT * FROM t
		
		INSERT INTO meta.route (name, order_no, path, component_name, icon, parent, props, offline, public, active)
		SELECT child, order_no, '/' || child, 'table', 'table_chart', parent, '{ "edit" : "' || proc || '", "frugal" : true }', false, false, true
		FROM meta.vw_ai4soilhealth_hierarchy;
END $function$

*/
 }
/**
 * @function import_lucas2015att
 * @memberof data
 * @description Import lucas2015att
 * @param {text} jsonCV
 * @param {text} jsonData
 * @returns {void}
 */
function import_lucas2015att() {
/*
CREATE OR REPLACE FUNCTION data.import_lucas2015att("jsonCV" text, "jsonData" text)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

DROP TABLE IF EXISTS t;
CREATE TEMP TABLE t AS
SELECT * FROM json_to_recordset("jsonData"::json) AS J(
"LC0_Desc" varchar, "Point_ID" varchar, "LC" varchar, "LU" varchar);

WITH x AS (SELECT DISTINCT t."LC" FROM  t)
INSERT INTO data.lc_detail(code)
SELECT meta.clean_value(x."LC", 'varchar')::varchar FROM x
LEFT JOIN data.lc_detail lc_detail ON lc_detail.code= x."LC"
WHERE lc_detail.id IS NULL;

WITH x AS (SELECT DISTINCT t."LC0_Desc" FROM  t)
INSERT INTO data.lc_main(name)
SELECT meta.clean_value(x."LC0_Desc", 'varchar')::varchar FROM x
LEFT JOIN data.lc_main lc_main ON lc_main.name= x."LC0_Desc"
WHERE lc_main.id IS NULL;

WITH x AS (SELECT DISTINCT t."LU" FROM  t)
INSERT INTO data.lu_detail(code)
SELECT meta.clean_value(x."LU", 'varchar')::varchar FROM x
LEFT JOIN data.lu_detail lu_detail ON lu_detail.code= x."LU"
WHERE lu_detail.id IS NULL;

WITH x AS (SELECT DISTINCT t."LC0_Desc", t."Point_ID", t."LC", t."LU" FROM  t)
INSERT INTO data.point_att(lc_main_id, point_id, lc_detail_id, lu_detail_id)
SELECT lc_main.id, point.id, lc_detail.id, lu_detail.id 
FROM x
INNER JOIN data.point point ON point.point_key= x."Point_ID"
LEFT JOIN data.lc_main lc_main ON lc_main.name = x."LC0_Desc"
LEFT JOIN data.lc_detail lc_detail ON lc_detail.code = x."LC"
LEFT JOIN data.lu_detail lu_detail ON lu_detail.code = x."LU"
; --WHERE point.id IS NULL;

END $function$

*/
 }
/**
 * @function data_property_l
 * @memberof zzgll
 * @description Data property l
 * @param {character_varying} SearchValue
 * @param {integer} Key
 * @returns {Object}
 * @property {integer} id
 * @property {character_varying} name
 */
function data_property_l() {
/*
CREATE OR REPLACE FUNCTION zzgll.data_property_l("SearchValue" character varying, "Key" integer DEFAULT NULL::integer)
 RETURNS TABLE(id integer, name character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

        IF "Key" IS NOT NULL THEN
            RETURN QUERY
            SELECT t.id, COALESCE(i.name, t.name) name
            FROM data.property t
						LEFT JOIN data.indicator i ON i.id = t.indicator_id
            WHERE t.id = "Key"::integer;
        ELSE
            RETURN QUERY
           SELECT t.id, COALESCE(i.name, t.name) name
            FROM data.property t
						LEFT JOIN data.indicator i ON i.id = t.indicator_id
            WHERE COALESCE(i.name, t.name) LIKE "SearchValue"
            ORDER BY t.name
           LIMIT 1000;
       END IF;
END $function$

*/
 }
/**
 * @function get_context_app_id
 * @memberof auth
 * @description Get context app id
 * @returns {integer}
 */
function get_context_app_id() {
/*
CREATE OR REPLACE FUNCTION auth.get_context_app_id()
 RETURNS integer
 LANGUAGE plpgsql
AS $function$ BEGIN

	
	RETURN current_setting('context.app_id', true)::INTEGER;

END $function$

*/
 }
/**
 * @function get_indicator_values
 * @memberof data
 * @description Get indicator values
 * @param {integer} IndicatorId
 * @param {integer} DataSourceId
 * @returns {Object}
 * @property {double_precision} lon
 * @property {double_precision} lat
 * @property {real} value
 * @property {date} date
 * @property {character_varying} color_code
 * @property {character_varying} point_key
 * @property {character} nuts_0
 * @property {character_varying} description
 * @property {character_varying} point_name
 * @property {integer} point_id
 */
function get_indicator_values() {
/*
CREATE OR REPLACE FUNCTION data.get_indicator_values("IndicatorId" integer, "DataSourceId" integer)
 RETURNS TABLE(lon double precision, lat double precision, value real, date date, color_code character varying, point_key character varying, nuts_0 character, description character varying, point_name character varying, point_id integer)
 LANGUAGE plpgsql
AS $function$

	DECLARE v_numerical BOOL;
					v_sql VARCHAR;
BEGIN

  SELECT numerical
	INTO v_numerical
	FROM data.indicator WHERE id = "IndicatorId";

	IF v_numerical = false THEN
	
			RETURN QUERY
				SELECT p.lon, p.lat, m.description_id::float4 value, m.date, ic.code, p.point_key, n.cntr_code, d.name, p.name point_name, p.id point_id
				FROM data.attribute m
				INNER JOIN data.point p ON p.id = m.point_id
				LEFT JOIN general.nuts n ON n.id = p.l3_id
				LEFT JOIN data.attribute_description d ON d.indicator_id = "IndicatorId" and d.description_id = m.description_id
				LEFT JOIN general.color ic ON ic.id = d.color_id 
				WHERE m.indicator_id = "IndicatorId" AND m.data_source_id = "DataSourceId"
				ORDER BY d.name
				; 
	ELSE
	
		RETURN QUERY
			SELECT t.lon, t.lat, avg(t.value)::float4 value, t.date, t.color_code, t.point_key, t.cntr_code, t.description, t.point_name, t.point_id 
			FROM (
				SELECT p.lon, p.lat, m.value, m.date, ic.color_code, p.point_key, n.cntr_code, null::varchar description, d.name depth_name, p.name point_name, p.id point_id,
				ROW_NUMBER() OVER (PARTITION BY m.point_id, m.indicator_id, m.depth_id ORDER BY m.date DESC, d.name) nr
				FROM data.measurement m
				INNER JOIN data.point p ON p.id = m.point_id
				LEFT JOIN data.depth d ON d.id = m.depth_id
				LEFT JOIN general.nuts n ON n.id = p.l3_id
				LEFT JOIN data.vw_indicator_color ic 
				ON m.value > ic.value_from AND m.value &lt;= ic.value_to AND ic.indicator_id = m.indicator_id
				WHERE m.indicator_id = "IndicatorId" AND m.data_source_id = "DataSourceId"
			) t WHERE t.nr = 1
			GROUP BY t.lon, t.lat, t.date, t.color_code, t.point_key, t.cntr_code, t.description, t.point_name, t.point_id
			ORDER BY value
			; 
	END IF;
END 
$function$

*/
 }
/**
 * @function auth_user_l
 * @memberof zzgll
 * @description Auth user l
 * @param {character_varying} SearchValue
 * @param {uuid} Key
 * @returns {Object}
 * @property {uuid} id
 * @property {character_varying} name
 */
function auth_user_l() {
/*
CREATE OR REPLACE FUNCTION zzgll.auth_user_l("SearchValue" character varying, "Key" uuid DEFAULT NULL::uuid)
 RETURNS TABLE(id uuid, name character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

        IF "Key" IS NOT NULL THEN
            RETURN QUERY
            SELECT t.id, t.user_name name
            FROM auth.user t
            WHERE t.id = "Key"::uuid;
        ELSE
            RETURN QUERY
            SELECT t.id, t.user_name name
            FROM auth.user t
            WHERE t.user_name LIKE "SearchValue"
            ORDER BY t.user_name
           LIMIT 1000;
       END IF;
END $function$

*/
 }
/**
 * @function delete_custom_geometry_time
 * @memberof data
 * @description Delete custom geometry time
 * @param {integer} PersonId
 * @param {integer} Id
 * @returns {void}
 */
function delete_custom_geometry_time() {
/*
CREATE OR REPLACE FUNCTION data.delete_custom_geometry_time("PersonId" integer, "Id" integer)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

	IF NOT EXISTS (
		SELECT 1 FROM data.custom_geometry_time t
		INNER JOIN data.custom_geometry g ON g.id = t.custom_geometry_id
		WHERE t.id = "Id" AND g.person_id ="PersonId"
	) THEN
		SELECT raise_error(4, 'Not allowed');
		RETURN;
	END IF;
		
	DELETE FROM data.custom_geometry_time WHERE id = "Id";
END $function$

*/
 }
/**
 * @function get_nuts
 * @memberof data
 * @description Get nuts
 * @param {integer} Level
 * @param {integer} Srid
 * @param {integer} Zoom
 * @param {double_precision} MinX
 * @param {double_precision} MinY
 * @param {double_precision} MaxX
 * @param {double_precision} MaxY
 * @param {integer} IndicatorId
 * @param {integer} DataSourceId
 * @returns {json}
 */
function get_nuts() {
/*
CREATE OR REPLACE FUNCTION data.get_nuts("Level" integer, "Srid" integer, "Zoom" integer, "MinX" double precision, "MinY" double precision, "MaxX" double precision, "MaxY" double precision, "IndicatorId" integer, "DataSourceId" integer)
 RETURNS json
 LANGUAGE plpgsql
AS $function$

DECLARE bb geometry;
				simplify float;
-- SELECT * FROM data.get_nuts(0, 3035, 10, 2217542.415101382,1337159.7278276538,6191714.062701465,4547067.5970431045, 1)				
BEGIN

  bb := st_makeenvelope ("MinX", "MinY", "MaxX", "MaxY", "Srid");
	bb := st_transform(bb, 3035);
	
	RAISE NOTICE '%', bb;
	
	IF ("Zoom" &lt;= 6) THEN
		simplify := 1000;
	ELSIF ("Zoom" &lt;= 7) THEN
		simplify := 500;
	ELSIF ("Zoom" &lt;= 8) THEN
		simplify := 300;
	ELSIF ("Zoom" &lt;= 9) THEN
		simplify := 200;		
	ELSIF ("Zoom" &lt;= 10) THEN 
		simplify := 10;
	ELSIF ("Zoom" &lt;= 11) THEN 
		simplify := 70;
	ELSIF ("Zoom" &lt;= 12) THEN 
		simplify := 50;
	ELSIF ("Zoom" &lt;= 13) THEN 
		simplify := 20;
	ELSIF ("Zoom" &lt;= 14) THEN 
		simplify := 10;
	ELSE
		simplify := 1;
	END IF;
	
	DROP TABLE IF EXISTS c;
	
	RETURN (
		SELECT jsonb_build_object (
				'type',       'FeatureCollection',
				'features', json_agg(st_asgeojson(t.*)::json)
    )
		FROM (
			SELECT b.id, b.nuts_name name, b.levl_code, v.value_avg, v.value_min, v.value_max, ic.color_code, -- u.name unit_name,
			st_transform(st_simplify(b.geom,simplify, true), "Srid")
			FROM general.nuts b 
			LEFT JOIN data.vw_avg_indicator_values_by_nuts v ON b.nuts_id = v.nuts_id AND v.indicator_id = "IndicatorId" AND v.data_source_id = "DataSourceId"
			LEFT JOIN data.vw_indicator_color ic 
			ON ic.indicator_id = v.indicator_id AND ic.value_from &lt; v.value_avg AND ic.value_to >= v.value_avg
--			LEFT JOIN data.indicator i 
--			ON i.id = v.indicator_id
--			LEFT JOIN general.unit u 
--			ON u.id = i.unit_id
			WHERE b.levl_code = "Level" AND st_intersects(b.geom, bb)
		) t	
	);
END
$function$

*/
 }
/**
 * @function general_ai_model_u
 * @memberof zzglc
 * @description General ai model u
 * @param {character_varying} Json
 * @returns {void}
 */
function general_ai_model_u() {
/*
CREATE OR REPLACE FUNCTION zzglc.general_ai_model_u("Json" character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE v_row_count INTEGER;
BEGIN

    UPDATE general.ai_model t
    SET name = U.name 
    FROM json_to_record("Json"::json) AS U (
        id integer,
            name character varying(255)
    ) 
    WHERE U.id = t.id
;

END $function$

*/
 }
/**
 * @function general_region_r
 * @memberof zzglc
 * @description General region r
 * @returns {Object}
 * @property {smallint} id
 * @property {character_varying} name
 */
function general_region_r() {
/*
CREATE OR REPLACE FUNCTION zzglc.general_region_r()
 RETURNS TABLE(id smallint, name character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

    RETURN QUERY
    SELECT
    t.id, t.name
    FROM general.region t
;
END $function$

*/
 }
/**
 * @function import_lucas2015pm
 * @memberof data
 * @description Import lucas2015pm
 * @param {text} jsonCV
 * @param {text} jsonData
 * @returns {void}
 */
function import_lucas2015pm() {
/*
CREATE OR REPLACE FUNCTION data.import_lucas2015pm("jsonCV" text, "jsonData" text)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

DROP TABLE IF EXISTS t;
CREATE TEMP TABLE t AS
SELECT * FROM json_to_recordset("jsonData"::json) AS J(
"Point_ID" varchar, "NUTS_2" varchar, "NUTS_0" varchar, "pH_CaCl2" varchar, "CaCO3" varchar, "pH_H2O" varchar, "NUTS_1" varchar, "NUTS_3" varchar, "N" varchar, "OC" varchar, "K" varchar, "EC" varchar, "P" varchar, "X" varchar, "Y" varchar);

WITH x AS (SELECT DISTINCT t."NUTS_0" FROM  t)
INSERT INTO data.nuts_0(name)
SELECT meta.clean_value(x."NUTS_0", 'varchar')::varchar FROM x
LEFT JOIN data.nuts_0 nuts_0 ON nuts_0.name= x."NUTS_0"
WHERE nuts_0.id IS NULL;

WITH x AS (SELECT DISTINCT t."NUTS_1" FROM  t)
INSERT INTO data.nuts_1(name)
SELECT meta.clean_value(x."NUTS_1", 'varchar')::varchar FROM x
LEFT JOIN data.nuts_1 nuts_1 ON nuts_1.name= x."NUTS_1"
WHERE nuts_1.id IS NULL;

WITH x AS (SELECT DISTINCT t."NUTS_2" FROM  t)
INSERT INTO data.nuts_2(name)
SELECT meta.clean_value(x."NUTS_2", 'varchar')::varchar FROM x
LEFT JOIN data.nuts_2 nuts_2 ON nuts_2.name= x."NUTS_2"
WHERE nuts_2.id IS NULL;

WITH x AS (SELECT DISTINCT t."NUTS_3" FROM  t)
INSERT INTO data.nuts_3(name)
SELECT meta.clean_value(x."NUTS_3", 'varchar')::varchar FROM x
LEFT JOIN data.nuts_3 nuts_3 ON nuts_3.name= x."NUTS_3"
WHERE nuts_3.id IS NULL;

WITH x AS (SELECT DISTINCT t."Point_ID", t."NUTS_2", t."NUTS_0", t."NUTS_1", t."NUTS_3", t."X", t."Y" FROM  t)
INSERT INTO data.point(point_key, nuts_2_id, nuts_0_id, nuts_1_id, nuts_3_id, lon, lat)
SELECT meta.clean_value(x."Point_ID", 'varchar')::varchar, nuts_2.id, nuts_0.id, nuts_1.id, nuts_3.id, meta.clean_value(x."X", 'float8')::float8, meta.clean_value(x."Y", 'float8')::float8 FROM x
LEFT JOIN data.point point ON point.point_key= x."Point_ID"
LEFT JOIN data.nuts_2 nuts_2 ON nuts_2.name = x."NUTS_2"
LEFT JOIN data.nuts_0 nuts_0 ON nuts_0.name = x."NUTS_0"
LEFT JOIN data.nuts_1 nuts_1 ON nuts_1.name = x."NUTS_1"
LEFT JOIN data.nuts_3 nuts_3 ON nuts_3.name = x."NUTS_3"
WHERE point.id IS NULL;

INSERT INTO data.measurement(point_id, indicator_id, value, date)
SELECT x.id, i.id, meta.clean_value(t."pH_CaCl2", 'float')::float, '2015-01-01'::date FROM t
LEFT JOIN data.point x ON x.point_key = t."Point_ID"
left join data.indicator i on i.name_match = 'pH (CaCl2)' left join data.measurement y on y.point_id = x.id and y.indicator_id = i.id and y.date = '2015-01-01'::date
WHERE y.id IS NULL AND meta.clean_value(t."pH_CaCl2", 'float')::float IS NOT NULL ;

INSERT INTO data.measurement(point_id, indicator_id, value, date)
SELECT x.id, i.id, meta.clean_value(t."CaCO3", 'float')::float,  '2015-01-01'::date FROM t
LEFT JOIN data.point x ON x.point_key = t."Point_ID"
left join data.indicator i on i.name_match = 'CaCO3' left join data.measurement y on y.point_id = x.id and y.indicator_id = i.id and y.date =  '2015-01-01'::date
WHERE y.id IS NULL AND meta.clean_value(t."CaCO3", 'float')::float IS NOT NULL ;

INSERT INTO data.measurement(point_id, indicator_id, value, date)
SELECT x.id, i.id, meta.clean_value(t."pH_H2O", 'float')::float, '2015-01-01'::date FROM t
LEFT JOIN data.point x ON x.point_key = t."Point_ID"
left join data.indicator i on i.name_match = 'pH (H2O)' left join data.measurement y on y.point_id = x.id and y.indicator_id = i.id and y.date =  '2015-01-01'::date
WHERE y.id IS NULL AND meta.clean_value(t."pH_H2O", 'float')::float IS NOT NULL ;

INSERT INTO data.measurement(point_id, indicator_id, value, date)
SELECT x.id, i.id, meta.clean_value(t."N", 'float')::float,  '2015-01-01'::date FROM t
LEFT JOIN data.point x ON x.point_key = t."Point_ID"
left join data.indicator i on i.name_match = 'N' left join data.measurement y on y.point_id = x.id and y.indicator_id = i.id and y.date =  '2015-01-01'::date
WHERE y.id IS NULL AND meta.clean_value(t."N", 'float')::float IS NOT NULL ;

INSERT INTO data.measurement(point_id, indicator_id, value, date)
SELECT x.id, i.id, meta.clean_value(t."OC", 'float')::float,  '2015-01-01'::date FROM t
LEFT JOIN data.point x ON x.point_key = t."Point_ID"
left join data.indicator i on i.name = 'OC' left join data.measurement y on y.point_id = x.id and y.indicator_id = i.id and y.date =  '2015-01-01'::date
WHERE y.id IS NULL AND meta.clean_value(t."OC", 'float')::float IS NOT NULL ;

INSERT INTO data.measurement(point_id, indicator_id, value, date)
SELECT x.id, i.id, meta.clean_value(t."K", 'float')::float,  '2015-01-01'::date FROM t
LEFT JOIN data.point x ON x.point_key = t."Point_ID"
left join data.indicator i on i.name_match = 'K' left join data.measurement y on y.point_id = x.id and y.indicator_id = i.id and y.date =  '2015-01-01'::date
WHERE y.id IS NULL AND meta.clean_value(t."K", 'float')::float IS NOT NULL ;

INSERT INTO data.measurement(point_id, indicator_id, value, date)
SELECT x.id, i.id, meta.clean_value(t."EC", 'float')::float, '2015-01-01'::date FROM t
LEFT JOIN data.point x ON x.point_key = t."Point_ID"
left join data.indicator i on i.name_match = 'EC' left join data.measurement y on y.point_id = x.id and y.indicator_id = i.id and y.date =  '2015-01-01'::date
WHERE y.id IS NULL AND meta.clean_value(t."EC", 'float')::float IS NOT NULL ;

INSERT INTO data.measurement(point_id, indicator_id, value, date)
SELECT x.id, i.id, meta.clean_value(t."P", 'float')::float,  '2015-01-01'::date FROM t
LEFT JOIN data.point x ON x.point_key = t."Point_ID"
left join data.indicator i on i.name_match = 'P' left join data.measurement y on y.point_id = x.id and y.indicator_id = i.id and y.date =  '2015-01-01'::date
WHERE y.id IS NULL AND meta.clean_value(t."P", 'float')::float IS NOT NULL ;

END $function$

*/
 }
/**
 * @function auth_route_role_public_u
 * @memberof zzglc
 * @description Auth route role public u
 * @param {character_varying} Json
 * @returns {void}
 */
function auth_route_role_public_u() {
/*
CREATE OR REPLACE FUNCTION zzglc.auth_route_role_public_u("Json" character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE v_row_count INTEGER;
BEGIN

    UPDATE auth.route_role_public t
    SET route_id = U.route_id,
        role_public_id = U.role_public_id 
    FROM json_to_record("Json"::json) AS U (
        id integer,
            route_id integer,
            role_public_id integer
    ) 
    WHERE U.id = t.id
;

END $function$

*/
 }
/**
 * @function data_nuts_0_l
 * @memberof zzgll
 * @description Data nuts 0 l
 * @param {character_varying} SearchValue
 * @param {integer} Key
 * @returns {Object}
 * @property {integer} id
 * @property {character_varying} name
 */
function data_nuts_0_l() {
/*
CREATE OR REPLACE FUNCTION zzgll.data_nuts_0_l("SearchValue" character varying, "Key" integer DEFAULT NULL::integer)
 RETURNS TABLE(id integer, name character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

        IF "Key" IS NOT NULL THEN
            RETURN QUERY
            SELECT t.id, t.name
            FROM data.nuts_0 t
            WHERE t.id = "Key"::integer;
        ELSE
            RETURN QUERY
           SELECT t.id, t.name
            FROM data.nuts_0 t
            WHERE t.name LIKE "SearchValue"
            ORDER BY t.name
           LIMIT 1000;
       END IF;
END $function$

*/
 }
/**
 * @function delete_custom_geometry
 * @memberof data
 * @description Delete custom geometry
 * @param {integer} PersonId
 * @param {integer} Id
 * @returns {void}
 */
function delete_custom_geometry() {
/*
CREATE OR REPLACE FUNCTION data.delete_custom_geometry("PersonId" integer, "Id" integer)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

	DELETE FROM data.custom_geometry WHERE id = "Id" AND person_id = "PersonId";
END $function$

*/
 }
/**
 * @function general_person_d
 * @memberof zzglc
 * @description General person d
 * @param {integer} Key
 * @returns {void}
 */
function general_person_d() {
/*
CREATE OR REPLACE FUNCTION zzglc.general_person_d("Key" integer)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

    DELETE FROM general.person
    WHERE id = "Key";

END $function$

*/
 }
/**
 * @function data_lc_main_c
 * @memberof zzglc
 * @description Data lc main c
 * @param {character_varying} Json
 * @returns {void}
 */
function data_lc_main_c() {
/*
CREATE OR REPLACE FUNCTION zzglc.data_lc_main_c("Json" character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

    INSERT INTO data.lc_main (
        name,
        color_id
    )
    SELECT
        U.name,
        U.color_id
    FROM
        json_to_record("Json"::json) U (
name character varying,
            color_id integer
        ) 
;
END $function$

*/
 }
/**
 * @function general_osoba_import_excel
 * @memberof general
 * @description General osoba import excel
 * @param {text} jsonCV
 * @param {text} jsonData
 * @returns {void}
 */
function general_osoba_import_excel() {
/*
CREATE OR REPLACE FUNCTION general.general_osoba_import_excel("jsonCV" text, "jsonData" text)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

DROP TABLE IF EXISTS t;
CREATE TEMP TABLE t AS
SELECT * FROM json_to_recordset("jsonData"::json) AS J(
"osoba" varchar, "mjesto" varchar);

WITH x AS (SELECT DISTINCT t."mjesto" FROM t)
INSERT INTO general.mjesto(name)
SELECT x."mjesto" FROM x
LEFT JOIN general.mjesto y ON y.name= x."mjesto"
WHERE y.id IS NULL;

WITH x AS (SELECT DISTINCT t."osoba", t."mjesto" FROM t)
INSERT INTO general.osoba(name, mjesto_id)
SELECT x."osoba", mjesto.id FROM x
LEFT JOIN general.osoba y ON y.name= x."osoba"
LEFT JOIN general.mjesto mjesto ON mjesto.name = x.mjesto
WHERE y.id IS NULL;

END $function$

*/
 }
/**
 * @function meta_safe_function_u
 * @memberof zzglc
 * @description Meta safe function u
 * @param {character_varying} Json
 * @returns {void}
 */
function meta_safe_function_u() {
/*
CREATE OR REPLACE FUNCTION zzglc.meta_safe_function_u("Json" character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE v_row_count INTEGER;
BEGIN

    UPDATE meta.safe_function t
    SET name = U.name 
    FROM json_to_record("Json"::json) AS U (
        id integer,
            name character varying(255)
    ) 
    WHERE U.id = t.id
;

END $function$

*/
 }
/**
 * @function import_detail_clone
 * @memberof meta
 * @description Import detail clone
 * @param {character_varying} Id
 * @returns {void}
 */
function import_detail_clone() {
/*
CREATE OR REPLACE FUNCTION meta.import_detail_clone("Id" character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
	DECLARE v_new_id INT;
BEGIN

	-- Routine body goes here...
	INSERT INTO meta.import_detail (import_master_id, col_name, target_schema, target_table, target_column, col_type, is_key, is_fk, as_row, target_column_list, source_column_list, joins, split, ignore)
	SELECT import_master_id, col_name || '_cloned', target_schema, target_table, target_column, col_type, is_key, is_fk, as_row, target_column_list, source_column_list, joins, split, ignore
	FROM meta.import_detail 
	WHERE id = "Id"::int
	RETURNING id INTO v_new_id;

	RETURN;
END$function$

*/
 }
/**
 * @function data_asset_catalog_l
 * @memberof zzgll
 * @description Data asset catalog l
 * @param {character_varying} SearchValue
 * @param {integer} Key
 * @returns {Object}
 * @property {integer} id
 * @property {character_varying} name
 */
function data_asset_catalog_l() {
/*
CREATE OR REPLACE FUNCTION zzgll.data_asset_catalog_l("SearchValue" character varying, "Key" integer DEFAULT NULL::integer)
 RETURNS TABLE(id integer, name character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

        IF "Key" IS NOT NULL THEN
            RETURN QUERY
            SELECT t.id, t.name
            FROM data.asset_catalog t
            WHERE t.id = "Key"::integer;
        ELSE
            RETURN QUERY
           SELECT t.id, t.name
            FROM data.asset_catalog t
            WHERE t.name LIKE "SearchValue"
            ORDER BY t.name
           LIMIT 1000;
       END IF;
END $function$

*/
 }
/**
 * @function add_comment_to_procedure
 * @memberof meta
 * @description add_comment_to_procedure
 * @param {character_varying} SchemaName - Name of the schema
 * @param {character_varying} ProcName - Name of the proc
 * @returns {json}
 */
function add_comment_to_procedure() {
/*
CREATE OR REPLACE FUNCTION meta.add_comment_to_procedure("SchemaName" character varying, "ProcName" character varying)
 RETURNS json
 LANGUAGE plpgsql
AS $function$
BEGIN

RETURN (
	WITH t AS (
		SELECT 
		    n.nspname,
		    p.proname,
			pg_get_functiondef(p.oid) AS function_definition,
			s.description proc_comment,
			a.order_no::INT,
			a.param_name,
			pg_catalog.format_type(COALESCE (b.param_type, d.param_type), null) AS data_type,
			c.input_output,
			pg_catalog.format_type(p.prorettype, null) AS return_type
		FROM pg_proc p
		INNER JOIN pg_namespace n ON (p.pronamespace = n.oid)
		LEFT JOIN pg_description s ON s.objoid = p.oid
		LEFT JOIN unnest(proargnames) WITH ORDINALITY AS a(param_name, order_no) ON true
		LEFT JOIN unnest(proargtypes) WITH ORDINALITY AS b(param_type, bseq) ON a.order_no = b.bseq
		LEFT JOIN unnest(proargmodes) WITH ORDINALITY AS c(input_output, cseq) ON a.order_no = c.cseq
		LEFT JOIN unnest(proallargtypes) WITH ORDINALITY AS d(param_type, dseq) ON a.order_no = d.dseq
		WHERE n.nspname = "SchemaName" AND p.proname = "ProcName"
	),
	b AS (
		SELECT nspname, proname, return_type, function_definition, proc_comment,
		json_build_object('param_name', param_name, 'data_type', data_type, 'input_output', input_output) param
		FROM t 
	),
	c AS (
		SELECT nspname proc_schema, proname proc_name, return_type, function_definition, proc_comment,
		json_agg(param) params
		FROM b
		GROUP BY nspname, proname, return_type, function_definition, proc_comment
	)
	SELECT json_agg (c.*) FROM c
);
END $function$

*/
 }
/**
 * @function general_sub_region_c
 * @memberof zzglc
 * @description General sub region c
 * @param {character_varying} Json
 * @returns {void}
 */
function general_sub_region_c() {
/*
CREATE OR REPLACE FUNCTION zzglc.general_sub_region_c("Json" character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

    INSERT INTO general.sub_region (
        name
    )
    SELECT
        U.name
    FROM
        json_to_record("Json"::json) U (
            name character varying
        ) 
;
END $function$

*/
 }
/**
 * @function data_attribute_u
 * @memberof zzglc
 * @description Data attribute u
 * @param {character_varying} Json
 * @returns {void}
 */
function data_attribute_u() {
/*
CREATE OR REPLACE FUNCTION zzglc.data_attribute_u("Json" character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE v_row_count INTEGER;
BEGIN

    UPDATE data.attribute t
    SET point_id = U.point_id,
        indicator_id = U.indicator_id,
        description_id = U.description_id,
        data_source_id = U.data_source_id,
        date = U.date,
        attribute_description_id = U.attribute_description_id 
    FROM json_to_record("Json"::json) AS U (
        id integer,
            point_id integer,
            indicator_id integer,
            description_id integer,
            data_source_id integer,
            date date,
            attribute_description_id integer
    ) 
    WHERE U.id = t.id
;

END $function$

*/
 }
/**
 * @function general_message_d
 * @memberof zzglc
 * @description General message d
 * @param {integer} Key
 * @returns {void}
 */
function general_message_d() {
/*
CREATE OR REPLACE FUNCTION zzglc.general_message_d("Key" integer)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

    DELETE FROM general.message
    WHERE id = "Key";

END $function$

*/
 }
/**
 * @function data_geometry_type_property_d
 * @memberof zzglc
 * @description Data geometry type property d
 * @param {integer} Key
 * @returns {void}
 */
function data_geometry_type_property_d() {
/*
CREATE OR REPLACE FUNCTION zzglc.data_geometry_type_property_d("Key" integer)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

    DELETE FROM data.geometry_type_property
    WHERE id = "Key";

END $function$

*/
 }
/**
 * @function meta_news_d
 * @memberof zzglc
 * @description Meta news d
 * @param {integer} Key
 * @returns {void}
 */
function meta_news_d() {
/*
CREATE OR REPLACE FUNCTION zzglc.meta_news_d("Key" integer)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

    DELETE FROM meta.news
    WHERE id = "Key";

END $function$

*/
 }
/**
 * @function get_custom_geometry
 * @memberof data
 * @description Get custom geometry
 * @param {integer} PersonId
 * @param {integer} Id
 * @returns {json}
 */
function get_custom_geometry() {
/*
CREATE OR REPLACE FUNCTION data.get_custom_geometry("PersonId" integer, "Id" integer)
 RETURNS json
 LANGUAGE plpgsql
AS $function$

DECLARE
    feature_collection json;
BEGIN

		
		SELECT jsonb_build_object(
            'type', 'FeatureCollection',
            'features', json_agg(t.feature)
        ) AS fc
    INTO feature_collection
    FROM (				
				-- real geometries
				SELECT json_build_object(
					'type', 'Feature',
					'id', 'g' || id::VARCHAR,
					'geometry', st_asgeojson(geometry)::json,
					'properties', json_build_object (
							'custom_geometry_id', id, 
							'geometry_type_id', geometry_type_id, 
							'name', name, 
							'public', public
					)
				) feature
				FROM data.custom_geometry g
				WHERE g.person_id = "PersonId" AND (g.id = "Id" OR "Id" = 0)
				
				UNION ALL
				
				-- files
				SELECT json_build_object(
					'type', 'Feature',
					'id', 'f' || f.id::VARCHAR,
					'geometry', f.geometry, -- st_asgeojson(st_makepoint(lon, lat))::json,
					'properties', json_build_object (
							'custom_geometry_id', g.id, 
							'geometry_type_id', g.geometry_type_id, 
							'extension', f.extension,
							'file_id', f.id,
							'compass', f.compass,
							'name', f.name
					)
				) feature			   
				FROM data.custom_geometry g
				INNER JOIN data.custom_geometry_file f ON f.custom_geometry_id = g.id
				WHERE g.person_id = "PersonId" AND (g.id = "Id" OR "Id" = 0)
	) t;
		
	RETURN feature_collection;

END 
$function$

*/
 }
/**
 * @function get_schema_name
 * @memberof meta
 * @description Get schema name
 * @param {text} TableName
 * @returns {text}
 */
function get_schema_name() {
/*
CREATE OR REPLACE FUNCTION meta.get_schema_name("TableName" text)
 RETURNS text
 LANGUAGE plpgsql
AS $function$
DECLARE
    schema_name text;
BEGIN

    -- Retrieve the schema name for the given table
    SELECT nspname INTO schema_name
    FROM pg_class c
    JOIN pg_namespace n ON c.relnamespace = n.oid
    WHERE c.relname = "TableName"
    LIMIT 1;

    RETURN schema_name;
END;
$function$

*/
 }
/**
 * @function get_all_nuts
 * @memberof general
 * @description Get all nuts
 * @param {integer} Id
 * @param {integer} Srid
 * @returns {json}
 */
function get_all_nuts() {
/*
CREATE OR REPLACE FUNCTION general.get_all_nuts("Id" integer, "Srid" integer)
 RETURNS json
 LANGUAGE plpgsql
AS $function$
BEGIN

	RETURN (
		SELECT jsonb_build_object (
				'type',       'FeatureCollection',
				'features', json_agg(st_asgeojson(t.*)::json)
    )
		FROM (
			SELECT b.id, b.name_latn, b.levl_code, st_transform(geom, "Srid") geom
			FROM general.nuts b 
			WHERE b.id = "Id"
		) t	
	);
END$function$

*/
 }
/**
 * @function data_theme_l
 * @memberof zzgll
 * @description Data theme l
 * @param {character_varying} SearchValue
 * @param {integer} Key
 * @returns {Object}
 * @property {integer} id
 * @property {character_varying} name
 */
function data_theme_l() {
/*
CREATE OR REPLACE FUNCTION zzgll.data_theme_l("SearchValue" character varying, "Key" integer DEFAULT NULL::integer)
 RETURNS TABLE(id integer, name character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

        IF "Key" IS NOT NULL THEN
            RETURN QUERY
            SELECT t.id, t.name
            FROM data.theme t
            WHERE t.id = "Key"::integer;
        ELSE
            RETURN QUERY
           SELECT t.id, t.name
            FROM data.theme t
            WHERE t.name LIKE "SearchValue"
            ORDER BY t.name
           LIMIT 1000;
       END IF;
END $function$

*/
 }
/**
 * @function meta_import_master_u
 * @memberof zzglc
 * @description Meta import master u
 * @param {character_varying} Json
 * @returns {void}
 */
function meta_import_master_u() {
/*
CREATE OR REPLACE FUNCTION zzglc.meta_import_master_u("Json" character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE v_row_count INTEGER;
BEGIN

    UPDATE meta.import_master t
    SET schema_name = U.schema_name,
        table_name = U.table_name,
        file_name = U.file_name,
        sheet = U.sheet,
        import_name = U.import_name,
        data_date = U.data_date,
        constant_value = U.constant_value 
    FROM json_to_record("Json"::json) AS U (
        id integer,
            schema_name character varying(255),
            table_name character varying(255),
            file_name character varying(1024),
            sheet character varying(255),
            name character varying,
            import_name character varying(255),
            data_date character varying,
            constant_value character varying(255)
    ) 
    WHERE U.id = t.id
;

END $function$

*/
 }
/**
 * @function get_shape
 * @memberof data
 * @description Get shape
 * @param {integer} Id
 * @param {integer} Srid
 * @returns {json}
 */
function get_shape() {
/*
CREATE OR REPLACE FUNCTION data.get_shape("Id" integer, "Srid" integer)
 RETURNS json
 LANGUAGE plpgsql
AS $function$
BEGIN

	RETURN (
		SELECT jsonb_build_object (
				'type',       'FeatureCollection',
				'features', json_agg(
						json_build_object(
							'type',       'Feature',
							'geometry',   st_asgeojson(t.geom)::json,
							'properties', t.properties													
						)
				)
    )
		FROM (
			SELECT b.id, b.properties, st_transform(geom, "Srid") geom
			FROM data.shape_geometry b 
			WHERE b.shape_id = "Id"
		) t	
	);
END$function$

*/
 }
/**
 * @function data_indicator_lang_d
 * @memberof zzglc
 * @description Data indicator lang d
 * @param {integer} Key
 * @returns {void}
 */
function data_indicator_lang_d() {
/*
CREATE OR REPLACE FUNCTION zzglc.data_indicator_lang_d("Key" integer)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

    DELETE FROM data.indicator_lang
    WHERE id = "Key";

END $function$

*/
 }
/**
 * @function auth_user_role_c
 * @memberof zzglc
 * @description Auth user role c
 * @param {character_varying} Json
 * @returns {void}
 */
function auth_user_role_c() {
/*
CREATE OR REPLACE FUNCTION zzglc.auth_user_role_c("Json" character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

    INSERT INTO auth.user_role (
        user_id,
        role_id
    )
    SELECT
        U.user_id,
        U.role_id
    FROM
        json_to_record("Json"::json) U (
            user_id uuid,
            role_id uuid
        ) 
;
END $function$

*/
 }
/**
 * @function meta_news_c
 * @memberof zzglc
 * @description Meta news c
 * @param {character_varying} Json
 * @returns {void}
 */
function meta_news_c() {
/*
CREATE OR REPLACE FUNCTION zzglc.meta_news_c("Json" character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

    INSERT INTO meta.news (
        name,
        active,
        user_modified,
        time_created
    )
    SELECT
        U.name,
        U.active,
        U.user_modified,
        U.time_created
    FROM
        json_to_record("Json"::json) U (
name character varying(255),
            active boolean,
            user_modified integer,
            time_created timestamp without time zone
        ) 
;
END $function$

*/
 }
/**
 * @function get_routes
 * @memberof meta
 * @description Get routes
 * @param {integer} PersonId
 * @param {integer} LangId
 * @returns {json}
 */
function get_routes() {
/*
CREATE OR REPLACE FUNCTION meta.get_routes("PersonId" integer, "LangId" integer)
 RETURNS json
 LANGUAGE plpgsql
AS $function$
	BEGIN

	-- Routine body goes here...
	RETURN (
		SELECT json_agg(t.*)
		FROM (
			SELECT r.order_no, r.name, r.path, r.component_name, r.offline, r.public, r.props, 
			COALESCE (r.value, r.name) title, r.icon, r.parent, r.active FROM (
				SELECT r.order_no, r.name, r.path, r.component_name, r.offline, r.public, r.props, 
				l.value, r.icon, r.parent, r.active
				FROM meta.route r
				LEFT JOIN auth.route_role_public rrp ON rrp.route_id = r.id
				LEFT JOIN auth.person_role_public prp ON prp.person_id = "PersonId" AND prp.role_public_id = rrp.role_public_id
				LEFT JOIN meta.i18n i ON i.key = r.name
				LEFT JOIN meta.i18n_lang l ON l.i18n_id = i.id and l.lang_id = "LangId"
				WHERE r.active
				AND (r."public" 
				OR (rrp.id is null and "PersonId" is not null) -- no role assigned
				OR (rrp.id is not null and rrp.role_public_id = prp.role_public_id)) -- role assigned and matched
				ORDER BY r.order_no
			) r 
		) t 
	);
END$function$

*/
 }
/**
 * @function data_property_d
 * @memberof zzglc
 * @description Data property d
 * @param {integer} Key
 * @returns {void}
 */
function data_property_d() {
/*
CREATE OR REPLACE FUNCTION zzglc.data_property_d("Key" integer)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

    DELETE FROM data.property
    WHERE id = "Key";

END $function$

*/
 }
/**
 * @function data_indicator_lang_r
 * @memberof zzglc
 * @description Data indicator lang r
 * @param {integer} LangId
 * @returns {Object}
 * @property {integer} id
 * @property {integer} indicator_id
 * @property {integer} lang_id
 * @property {character_varying} value
 * @property {character_varying} indicator_id_val
 * @property {character_varying} lang_id_val
 */
function data_indicator_lang_r() {
/*
CREATE OR REPLACE FUNCTION zzglc.data_indicator_lang_r("LangId" integer)
 RETURNS TABLE(id integer, indicator_id integer, lang_id integer, value character varying, indicator_id_val character varying, lang_id_val character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

    RETURN QUERY
    SELECT
    COALESCE (t.id, -row_number() over (order by indicator_id_t.name))::int id
		, indicator_id_t.id indicator_id
		, "LangId" lang_id
		, COALESCE(t.value, t1.value)
    , indicator_id_t.name::VARCHAR AS indicator_id_val
		, lang_id_t.name::VARCHAR AS lang_id_val
		--, (t.id is not null) translated
    FROM data.indicator indicator_id_t
    LEFT JOIN data.indicator_lang t ON indicator_id_t.id = t.indicator_id AND t.lang_id = "LangId"
   	LEFT JOIN meta.lang lang_id_t ON lang_id_t.id = t.lang_id
		LEFT JOIN data.indicator_lang t1 ON t1.lang_id = 1 AND t1.indicator_id = indicator_id_t.id    
    ORDER BY indicator_id_t.name
;
END $function$

*/
 }
/**
 * @function data_asset_version_d
 * @memberof zzglc
 * @description Data asset version d
 * @param {integer} Key
 * @returns {void}
 */
function data_asset_version_d() {
/*
CREATE OR REPLACE FUNCTION zzglc.data_asset_version_d("Key" integer)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

    DELETE FROM data.asset_version
    WHERE id = "Key";

END $function$

*/
 }
/**
 * @function data_lc_main_u
 * @memberof zzglc
 * @description Data lc main u
 * @param {character_varying} Json
 * @returns {void}
 */
function data_lc_main_u() {
/*
CREATE OR REPLACE FUNCTION zzglc.data_lc_main_u("Json" character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE v_row_count INTEGER;
BEGIN

    UPDATE data.lc_main t
    SET name = U.name,
        color_id = U.color_id 
    FROM json_to_record("Json"::json) AS U (
        id integer,
            name character varying,
            color_id integer
    ) 
    WHERE U.id = t.id
;

END $function$

*/
 }
/**
 * @function data_license_r
 * @memberof zzglc
 * @description Data license r
 * @returns {Object}
 * @property {integer} id
 * @property {character_varying} name
 */
function data_license_r() {
/*
CREATE OR REPLACE FUNCTION zzglc.data_license_r()
 RETURNS TABLE(id integer, name character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

    RETURN QUERY
    SELECT
    t.id, t.name
    FROM data.license t
;
END $function$

*/
 }
/**
 * @function update_custom_geometry
 * @memberof data
 * @description Update custom geometry
 * @param {integer} PersonId
 * @param {integer} Id
 * @param {integer} FileId
 * @param {text} Feature
 * @returns {void}
 */
function update_custom_geometry() {
/*
CREATE OR REPLACE FUNCTION data.update_custom_geometry("PersonId" integer, "Id" integer, "FileId" integer, "Feature" text)
 RETURNS void
 LANGUAGE plpgsql
AS $function$		
DECLARE v_RowCountInt INT;
BEGIN

	IF "FileId" IS NOT NULL THEN
		UPDATE data.custom_geometry_file f
		SET geometry = st_geomfromgeojson(("Feature"::json)->'geometry') 
		WHERE id = "FileId" 
		AND EXISTS (SELECT 1 FROM data.custom_geometry g WHERE g.id = f.custom_geometry_id AND g.person_id = "PersonId");
	ELSE
		UPDATE data.custom_geometry 
		SET geometry = st_geomfromgeojson(("Feature"::json)->'geometry')
		WHERE id = "Id" AND person_id = "PersonId";
  END IF;
	GET DIAGNOSTICS v_RowCountInt = ROW_COUNT;
	IF v_RowCountInt = 0 THEN
	  SELECT meta.raise_error(4);
	END IF;
	
END 
$function$

*/
 }
/**
 * @function data_custom_geometry_c
 * @memberof zzglc
 * @description Data custom geometry c
 * @param {character_varying} Json
 * @returns {integer}
 */
function data_custom_geometry_c() {
/*
CREATE OR REPLACE FUNCTION zzglc.data_custom_geometry_c("Json" character varying)
 RETURNS integer
 LANGUAGE plpgsql
AS $function$
   DECLARE v_id integer;
BEGIN

    INSERT INTO data.custom_geometry (
        geometry_type_id,
        person_id,
        route_key,
        geometry,
        name,
        public,
        time_created
    )
    SELECT
        U.geometry_type_id,
        U.person_id,
        U.route_key,
        U.geometry,
        U.name,
        U.public,
        U.time_created
    FROM
        json_to_record("Json"::json) U (
geometry_type_id integer,
            person_id integer,
            route_key character varying,
            geometry geometry,
            name character varying(255),
            public boolean,
            time_created timestamp with time zone
        ) 
    RETURNING id INTO v_id;

    RETURN v_id;
END $function$

*/
 }
/**
 * @function general_color_l
 * @memberof zzgll
 * @description General color l
 * @param {character_varying} SearchValue
 * @param {integer} Key
 * @returns {Object}
 * @property {integer} id
 * @property {character_varying} name
 * @property {character_varying} code
 */
function general_color_l() {
/*
CREATE OR REPLACE FUNCTION zzgll.general_color_l("SearchValue" character varying, "Key" integer DEFAULT NULL::integer)
 RETURNS TABLE(id integer, name character varying, code character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

        IF "Key" IS NOT NULL THEN
            RETURN QUERY
            SELECT t.id, t.name, t.code
            FROM general.color t
            WHERE t.id = "Key"::integer;
        ELSE
            RETURN QUERY
           SELECT t.id, t.name, t.code
            FROM general.color t
            WHERE LOWER(t.name) LIKE LOWER("SearchValue")
            ORDER BY t.name
           LIMIT 1000;
       END IF;
END $function$

*/
 }
/**
 * @function set_shape_geometry
 * @memberof data
 * @description Set shape geometry
 * @param {integer} ShapeId
 * @param {integer} Srid
 * @param {text} Properties
 * @param {text} Geometry
 * @returns {void}
 */
function set_shape_geometry() {
/*
CREATE OR REPLACE FUNCTION data.set_shape_geometry("ShapeId" integer, "Srid" integer, "Properties" text, "Geometry" text)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE p json;
DECLARE parents VARCHAR;
BEGIN

		INSERT INTO data.shape_geometry (
			shape_id, 
			properties, 
			geom)
		VALUES (
		  "ShapeId", 
			"Properties"::json,
			st_transform(st_multi(st_setsrid(st_geomfromgeojson("Geometry"), "Srid")), 3035)
		);
		

RETURN;
END$function$

*/
 }
/**
 * @function auth_route_role_public_d
 * @memberof zzglc
 * @description Auth route role public d
 * @param {integer} Key
 * @returns {void}
 */
function auth_route_role_public_d() {
/*
CREATE OR REPLACE FUNCTION zzglc.auth_route_role_public_d("Key" integer)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

    DELETE FROM auth.route_role_public
    WHERE id = "Key";

END $function$

*/
 }
/**
 * @function meta_safe_function_r
 * @memberof zzglc
 * @description Meta safe function r
 * @returns {Object}
 * @property {integer} id
 * @property {character_varying} name
 */
function meta_safe_function_r() {
/*
CREATE OR REPLACE FUNCTION zzglc.meta_safe_function_r()
 RETURNS TABLE(id integer, name character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

    RETURN QUERY
    SELECT
    t.id, t.name
    FROM meta.safe_function t
;
END $function$

*/
 }
/**
 * @function rmv
 * @memberof meta
 * @description Rmv
 * @returns {void}
 */
function rmv() {
/*
CREATE OR REPLACE FUNCTION meta.rmv()
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

	REFRESH MATERIALIZED VIEW data.vw_avg_indicator_values_by_nuts0;
	REFRESH MATERIALIZED VIEW data.vw_indicator_color;
END $function$

*/
 }
/**
 * @function get_geometry_type_properties
 * @memberof data
 * @description Get geometry type properties
 * @param {integer} LangId
 * @returns {json}
 */
function get_geometry_type_properties() {
/*
CREATE OR REPLACE FUNCTION data.get_geometry_type_properties("LangId" integer)
 RETURNS json
 LANGUAGE plpgsql
AS $function$

BEGIN

	RETURN (
		SELECT json_agg(t.*) FROM
			(SELECT 
			 g.id value,
			 g.name label,
			 json_agg(jsonb_build_object(
				 'property_id', a.id,
				 'name', COALESCE(i.name, a.name),
				 'data_type_id', a.data_type_id,
				 'unit', COALESCE(ui.name, u.name),
				 'indicator_id', i.id,
				 'numerical', COALESCE(i.numerical,a.numerical),
				 'order_no', p.order_no,
				 'required', p.required,
				 'value_from', i.value_from,
				 'value_to', i.value_to,
				 'mask', a.mask
			 )) properties
			FROM data.geometry_type g
			LEFT JOIN data.geometry_type_property p ON g.id = p.geometry_type_id
			LEFT JOIN data.property a ON a.id = p.property_id
			LEFT JOIN data.indicator i ON i.id = a.indicator_id
			LEFT JOIN data.unit u ON u.id = a.unit_id
			LEFT JOIN data.unit ui ON ui.id = i.unit_id
			GROUP BY g.id, g.name
			ORDER BY g.name
		) t
	);
end 
$function$

*/
 }
/**
 * @function data_unit_l
 * @memberof zzgll
 * @description Data unit l
 * @param {character_varying} SearchValue
 * @param {integer} Key
 * @returns {Object}
 * @property {integer} id
 * @property {character_varying} name
 */
function data_unit_l() {
/*
CREATE OR REPLACE FUNCTION zzgll.data_unit_l("SearchValue" character varying, "Key" integer DEFAULT NULL::integer)
 RETURNS TABLE(id integer, name character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

        IF "Key" IS NOT NULL THEN
            RETURN QUERY
            SELECT t.id, t.name
            FROM data.unit t
            WHERE t.id = "Key"::integer;
        ELSE
            RETURN QUERY
           SELECT t.id, t.name
            FROM data.unit t
            WHERE t.name LIKE "SearchValue"
            ORDER BY t.name
           LIMIT 1000;
       END IF;
END $function$

*/
 }
/**
 * @function get_srids
 * @memberof general
 * @description Get srids
 * @returns {json}
 */
function get_srids() {
/*
CREATE OR REPLACE FUNCTION general.get_srids()
 RETURNS json
 LANGUAGE plpgsql
AS $function$
BEGIN

	RETURN (
		SELECT '[3857, 3035]'::json
	);
END$function$

*/
 }
/**
 * @function data_attribute_description_d
 * @memberof zzglc
 * @description Data attribute description d
 * @param {integer} Key
 * @returns {void}
 */
function data_attribute_description_d() {
/*
CREATE OR REPLACE FUNCTION zzglc.data_attribute_description_d("Key" integer)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

    DELETE FROM data.attribute_description
    WHERE id = "Key";

END $function$

*/
 }
/**
 * @function data_lc_main_r
 * @memberof zzglc
 * @description Data lc main r
 * @returns {Object}
 * @property {integer} id
 * @property {character_varying} name
 * @property {integer} color_id
 * @property {character_varying} color_id_val
 * @property {character_varying} color_code
 */
function data_lc_main_r() {
/*
CREATE OR REPLACE FUNCTION zzglc.data_lc_main_r()
 RETURNS TABLE(id integer, name character varying, color_id integer, color_id_val character varying, color_code character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

    RETURN QUERY
    SELECT
    t.id, t.name, t.color_id
    , color_id_t.name::VARCHAR AS color_id_val, color_id_t.code
    FROM data.lc_main t

    LEFT JOIN general.color color_id_t ON color_id_t.id = t.color_id
    
    ORDER BY t.name
;
END $function$

*/
 }
/**
 * @function data_file_theme_l
 * @memberof zzgll
 * @description Data file theme l
 * @param {character_varying} SearchValue
 * @param {integer} Key
 * @returns {Object}
 * @property {integer} id
 * @property {character_varying} name
 */
function data_file_theme_l() {
/*
CREATE OR REPLACE FUNCTION zzgll.data_file_theme_l("SearchValue" character varying, "Key" integer DEFAULT NULL::integer)
 RETURNS TABLE(id integer, name character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

        IF "Key" IS NOT NULL THEN
            RETURN QUERY
            SELECT t.id, t.name
            FROM data.file_theme t
            WHERE t.id = "Key"::integer;
        ELSE
            RETURN QUERY
           SELECT t.id, t.name
            FROM data.file_theme t
            WHERE t.name LIKE "SearchValue"
            ORDER BY t.name
           LIMIT 1000;
       END IF;
END $function$

*/
 }
/**
 * @function data_data_source_l
 * @memberof zzgll
 * @description Data data source l
 * @param {character_varying} SearchValue
 * @param {integer} Key
 * @returns {Object}
 * @property {integer} id
 * @property {character_varying} name
 */
function data_data_source_l() {
/*
CREATE OR REPLACE FUNCTION zzgll.data_data_source_l("SearchValue" character varying, "Key" integer DEFAULT NULL::integer)
 RETURNS TABLE(id integer, name character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

        IF "Key" IS NOT NULL THEN
            RETURN QUERY
            SELECT t.id, t.name
            FROM data.data_source t
            WHERE t.id = "Key"::integer;
        ELSE
            RETURN QUERY
           SELECT t.id, t.name
            FROM data.data_source t
            WHERE t.name LIKE "SearchValue"
            ORDER BY t.name
           LIMIT 1000;
       END IF;
END $function$

*/
 }
/**
 * @function data_indicator_c
 * @memberof zzglc
 * @description Data indicator c
 * @param {character_varying} Json
 * @returns {integer}
 */
function data_indicator_c() {
/*
CREATE OR REPLACE FUNCTION zzglc.data_indicator_c("Json" character varying)
 RETURNS integer
 LANGUAGE plpgsql
AS $function$
   DECLARE v_id integer;
BEGIN

    INSERT INTO data.indicator (
        name,
        unit_id,
        lod,
        name_match,
        decimals_for_stats,
        decimals_for_display,
        numerical,
        value_from,
        value_to
    )
    SELECT
        U.name,
        U.unit_id,
        U.lod,
        U.name_match,
        U.decimals_for_stats,
        U.decimals_for_display,
        U.numerical,
        U.value_from,
        U.value_to
    FROM
        json_to_record("Json"::json) U (
name character varying(255),
            unit_id integer,
            lod character varying(255),
            name_match character varying(255),
            decimals_for_stats integer,
            decimals_for_display integer,
            numerical boolean,
            value_from real,
            value_to real
        ) 
    RETURNING id INTO v_id;

    RETURN v_id;
END $function$

*/
 }
/**
 * @function get_custom_geometry_props
 * @memberof data
 * @description Get custom geometry props
 * @param {integer} PersonId
 * @param {integer} Id
 * @returns {json}
 */
function get_custom_geometry_props() {
/*
CREATE OR REPLACE FUNCTION data.get_custom_geometry_props("PersonId" integer, "Id" integer)
 RETURNS json
 LANGUAGE plpgsql
AS $function$
DECLARE v_general json;
DECLARE v_props json;
DECLARE v_files json;
BEGIN

	SELECT json_build_object('id', id, 'geometry_type_id', geometry_type_id, 'name', name, 'public', public)
	INTO v_general
	FROM data.custom_geometry
	WHERE id = "Id" AND person_id = "PersonId";
  
	IF v_general IS NOT NULL THEN
		SELECT json_agg(t.*) INTO v_props
		FROM (
					SELECT t.id, t.observation_time, json_agg(fp.*) props
					FROM data.custom_geometry_time t
					INNER JOIN data.custom_geometry_property fp ON fp.custom_geometry_time_id = t.id
					WHERE t.custom_geometry_id = "Id"
					GROUP BY t.id
					ORDER BY t.observation_time
		) t;
		
		SELECT json_agg(t.*) INTO v_files
			FROM (
					SELECT f.id, f.name, f.time_modified, f.extension, f.compass
			FROM data.custom_geometry_file f 
			WHERE f.custom_geometry_id = "Id"
		) t;
	END IF;
	
	RETURN json_build_object('general', v_general, 'times', COALESCE(v_props, '[]') , 'files', COALESCE ( v_files, '[]'));
END 
$function$

*/
 }
/**
 * @function auth_person_role_public_r
 * @memberof zzglc
 * @description Auth person role public r
 * @returns {Object}
 * @property {integer} id
 * @property {integer} person_id
 * @property {integer} role_public_id
 * @property {character_varying} person_id_val
 * @property {character_varying} role_public_id_val
 */
function auth_person_role_public_r() {
/*
CREATE OR REPLACE FUNCTION zzglc.auth_person_role_public_r()
 RETURNS TABLE(id integer, person_id integer, role_public_id integer, person_id_val character varying, role_public_id_val character varying)
 LANGUAGE plpgsql
AS $function$
    BEGIN

				RETURN QUERY (
        SELECT t.id, t.person_id, t.role_public_id, person_id.name, role_public_id.name
        FROM auth.person_role_public t 
        LEFT JOIN general.person person_id ON person_id.id = t.person_id
        LEFT JOIN auth.role_public role_public_id ON role_public_id.id = t.role_public_id
				);
    END $function$

*/
 }
/**
 * @function general_ai_model_d
 * @memberof zzglc
 * @description General ai model d
 * @param {integer} Key
 * @returns {void}
 */
function general_ai_model_d() {
/*
CREATE OR REPLACE FUNCTION zzglc.general_ai_model_d("Key" integer)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

    DELETE FROM general.ai_model
    WHERE id = "Key";

END $function$

*/
 }
/**
 * @function get_indicators_by_nuts
 * @memberof data
 * @description Get indicators by nuts
 * @param {text} Params
 * @param {integer} PersonId
 * @param {integer} LangId
 * @returns {Object}
 * @property {integer} levl_code
 * @property {character_varying} country
 * @property {character_varying} name_latn
 * @property {character_varying} nuts_id
 * @property {character_varying} indicator
 * @property {numeric} average
 * @property {numeric} min
 * @property {numeric} max
 */
function get_indicators_by_nuts() {
/*
CREATE OR REPLACE FUNCTION data.get_indicators_by_nuts("Params" text, "PersonId" integer, "LangId" integer)
 RETURNS TABLE(levl_code integer, country character varying, name_latn character varying, nuts_id character varying, indicator character varying, average numeric, min numeric, max numeric)
 LANGUAGE plpgsql
AS $function$
BEGIN

 
	RETURN QUERY
	SELECT v.levl_code, c.name_latn, n.name_latn, n.nuts_id, i.name, v.value_avg::decimal(10,2), v.value_min::decimal(10,2), v.value_max::decimal(10,2)
	FROM data.vw_avg_indicator_values_by_nuts v
	INNER JOIN general.nuts n ON n.nuts_id = v.nuts_id
	INNER JOIN data.indicator i ON i.id = v.indicator_id
	INNER JOIN general.nuts c ON c.nuts_id = n.cntr_code 
	ORDER BY 1, 2, 3, 4, 5;
END $function$

*/
 }
/**
 * @function meta_i18n_l
 * @memberof zzgll
 * @description Meta i18n l
 * @param {character_varying} SearchValue
 * @param {integer} Key
 * @returns {Object}
 * @property {integer} id
 * @property {character_varying} key
 */
function meta_i18n_l() {
/*
CREATE OR REPLACE FUNCTION zzgll.meta_i18n_l("SearchValue" character varying, "Key" integer DEFAULT NULL::integer)
 RETURNS TABLE(id integer, key character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

        IF "Key" IS NOT NULL THEN
            RETURN QUERY
            SELECT t.id, t.key
            FROM meta.i18n t
            WHERE t.id = "Key"::integer;
        ELSE
            RETURN QUERY
           SELECT t.id, t.key
            FROM meta.i18n t
            WHERE t.key LIKE "SearchValue"
            ORDER BY t.key
           LIMIT 1000;
       END IF;
END $function$

*/
 }
/**
 * @function data_geometry_type_property_r
 * @memberof zzglc
 * @description Data geometry type property r
 * @returns {Object}
 * @property {integer} id
 * @property {integer} geometry_type_id
 * @property {integer} order_no
 * @property {integer} property_id
 * @property {character_varying} geometry_type_id_val
 * @property {character_varying} property_id_val
 */
function data_geometry_type_property_r() {
/*
CREATE OR REPLACE FUNCTION zzglc.data_geometry_type_property_r()
 RETURNS TABLE(id integer, geometry_type_id integer, order_no integer, property_id integer, geometry_type_id_val character varying, property_id_val character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

    RETURN QUERY
    SELECT
    t.id, t.geometry_type_id, t.order_no, t.property_id
    , geometry_type_id_t.name::VARCHAR AS geometry_type_id_val
		, COALESCE(i.name, property_id_t.name)::VARCHAR AS property_id_val
    FROM data.geometry_type_property t

    LEFT JOIN data.geometry_type geometry_type_id_t ON geometry_type_id_t.id = t.geometry_type_id
    LEFT JOIN data.property property_id_t ON property_id_t.id = t.property_id
    LEFT JOIN data.indicator i ON i.id = property_id_t.indicator_id
    ORDER BY geometry_type_id_t.name, t.order_no
;
END $function$

*/
 }
/**
 * @function data_property_r
 * @memberof zzglc
 * @description Data property r
 * @returns {Object}
 * @property {integer} id
 * @property {character_varying} name
 * @property {integer} indicator_id
 * @property {integer} unit_id
 * @property {integer} data_type_id
 * @property {boolean} numerical
 * @property {character_varying} mask
 * @property {character_varying} indicator_id_val
 * @property {character_varying} unit_id_val
 * @property {character_varying} _data_type_id_val
 */
function data_property_r() {
/*
CREATE OR REPLACE FUNCTION zzglc.data_property_r()
 RETURNS TABLE(id integer, name character varying, indicator_id integer, unit_id integer, data_type_id integer, numerical boolean, mask character varying, indicator_id_val character varying, unit_id_val character varying, " data_type_id_val" character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

    RETURN QUERY
    SELECT
    t.id, t.name, t.indicator_id, t.unit_id, t.data_type_id, t.numerical, t.mask
    , indicator_id_t.name::VARCHAR AS indicator_id_val
		, unit_id_t.name::VARCHAR AS unit_id_val
		, dt.name::VARCHAR AS data_type_id_val
    FROM data.property t

    LEFT JOIN data.indicator indicator_id_t ON indicator_id_t.id = t.indicator_id
    LEFT JOIN data.unit unit_id_t ON unit_id_t.id = t.unit_id
    LEFT JOIN meta.data_type dt ON dt.id = t.data_type_id
				
    ORDER BY t.name
;
END $function$

*/
 }
/**
 * @function add_user_and_timestamp_column
 * @memberof meta
 * @description Add user and timestamp column
 * @param {character_varying} SchemaName
 * @param {character_varying} TableName
 * @returns {void}
 */
function add_user_and_timestamp_column() {
/*
CREATE OR REPLACE FUNCTION meta.add_user_and_timestamp_column("SchemaName" character varying, "TableName" character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
	DECLARE
	  sql VARCHAR;
BEGIN

	IF NOT EXISTS (SELECT 1
		FROM   pg_attribute
		WHERE  attrelid = ("SchemaName" || '.' || "TableName")::regclass  -- table name optionally schema-qualified
		AND    attnum > 0
		AND    NOT attisdropped
		AND    attname = 'time_modified') THEN
		EXECUTE format ('ALTER TABLE %s.%s ADD column time_modified timestamp', "SchemaName", "TableName");
		EXECUTE format ('ALTER TABLE %s.%s ADD column user_modified int4', "SchemaName", "TableName");
	END IF;
	
	EXECUTE format ('UPDATE %s.%s SET time_modified=CURRENT_TIMESTAMP WHERE time_modified IS NULL', "SchemaName", "TableName");	

	PERFORM meta.add_update_user_and_time_modified_trigger("SchemaName", "TableName");

	EXECUTE format ('alter table %s.%s add constraint fk_%s_person FOREIGN KEY (user_modified) REFERENCES general.person (id)', "SchemaName", "TableName", "TableName");
	
END $function$

*/
 }
/**
 * @function create_context
 * @memberof auth
 * @description Create context
 * @param {uuid} UserId
 * @param {integer} LangId
 * @param {integer} AppId
 * @param {uuid} ImpersonatedUserId
 * @returns {void}
 */
function create_context() {
/*
CREATE OR REPLACE FUNCTION auth.create_context("UserId" uuid, "LangId" integer, "AppId" integer, "ImpersonatedUserId" uuid DEFAULT NULL::uuid)
 RETURNS void
 LANGUAGE plpgsql
AS $function$ BEGIN

  PERFORM set_config('context.user_id', "UserId"::text, false);
	PERFORM set_config('context.impersonated_user_id', "ImpersonatedUserId"::text, false);
	PERFORM set_config('context.lang_id', "LangId"::text, false);
	PERFORM set_config('context.app_id', "AppId"::text, false);
END $function$

*/
 }
/**
 * @function meta_table_ref_col_u
 * @memberof zzglc
 * @description Meta table ref col u
 * @param {character_varying} Json
 * @returns {void}
 */
function meta_table_ref_col_u() {
/*
CREATE OR REPLACE FUNCTION zzglc.meta_table_ref_col_u("Json" character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE v_row_count INTEGER;
BEGIN

    UPDATE meta.table_ref_col t
    SET schema_name = U.schema_name,
        table_name = U.table_name,
        ref_col = U.ref_col 
    FROM json_to_record("Json"::json) AS U (
        id integer,
            schema_name character varying(255),
            table_name character varying(255),
            ref_col character varying(255)
    ) 
    WHERE U.id = t.id
;

END $function$

*/
 }
/**
 * @function data_file_scale_l
 * @memberof zzgll
 * @description Data file scale l
 * @param {character_varying} SearchValue
 * @param {integer} Key
 * @returns {Object}
 * @property {integer} id
 * @property {character_varying} name
 */
function data_file_scale_l() {
/*
CREATE OR REPLACE FUNCTION zzgll.data_file_scale_l("SearchValue" character varying, "Key" integer DEFAULT NULL::integer)
 RETURNS TABLE(id integer, name character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

        IF "Key" IS NOT NULL THEN
            RETURN QUERY
            SELECT t.id, t.name
            FROM data.file_scale t
            WHERE t.id = "Key"::integer;
        ELSE
            RETURN QUERY
           SELECT t.id, t.name
            FROM data.file_scale t
            WHERE t.name LIKE "SearchValue"
            ORDER BY t.name
           LIMIT 1000;
       END IF;
END $function$

*/
 }
/**
 * @function delete_file
 * @memberof data
 * @description Delete file
 * @param {integer} PersonId
 * @param {integer} FileId
 * @returns {void}
 */
function delete_file() {
/*
CREATE OR REPLACE FUNCTION data.delete_file("PersonId" integer, "FileId" integer)
 RETURNS void
 LANGUAGE plpgsql
AS $function$ 
BEGIN

	IF EXISTS (
		SELECT 1 FROM data.custom_geometry_file f
			INNER JOIN data.custom_geometry g ON g.id = f.custom_geometry_id
			WHERE f.id = "FileId" AND g.person_id = "PersonId"
	) THEN 
		DELETE FROM data.custom_geometry_file f WHERE id = "FileId";
		RETURN;
	END IF;
	PERFORM meta.raise_error(4, '') ;
	
END$function$

*/
 }
/**
 * @function data_file_resolution_l
 * @memberof zzgll
 * @description Data file resolution l
 * @param {character_varying} SearchValue
 * @param {integer} Key
 * @returns {Object}
 * @property {integer} id
 * @property {character_varying} name
 */
function data_file_resolution_l() {
/*
CREATE OR REPLACE FUNCTION zzgll.data_file_resolution_l("SearchValue" character varying, "Key" integer DEFAULT NULL::integer)
 RETURNS TABLE(id integer, name character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

        IF "Key" IS NOT NULL THEN
            RETURN QUERY
            SELECT t.id, t.name
            FROM data.file_resolution t
            WHERE t.id = "Key"::integer;
        ELSE
            RETURN QUERY
           SELECT t.id, t.name
            FROM data.file_resolution t
            WHERE t.name LIKE "SearchValue"
            ORDER BY t.name
           LIMIT 1000;
       END IF;
END $function$

*/
 }
/**
 * @function meta_trace_c
 * @memberof zzglc
 * @description Meta trace c
 * @param {character_varying} Json
 * @returns {void}
 */
function meta_trace_c() {
/*
CREATE OR REPLACE FUNCTION zzglc.meta_trace_c("Json" character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

    INSERT INTO meta.trace (
        text
    )
    SELECT
        U.text
    FROM
        json_to_record("Json"::json) U (
            text character varying
        ) 
;
END $function$

*/
 }
/**
 * @function data_measurement_r
 * @memberof zzglc
 * @description Data measurement r
 * @returns {Object}
 * @property {integer} id
 * @property {integer} indicator_id
 * @property {real} value
 * @property {integer} point_id
 * @property {character} lod
 * @property {date} date
 * @property {integer} data_source_id
 * @property {character_varying} indicator_id_val
 * @property {character_varying} point_id_val
 * @property {character_varying} data_source_id_val
 */
function data_measurement_r() {
/*
CREATE OR REPLACE FUNCTION zzglc.data_measurement_r()
 RETURNS TABLE(id integer, indicator_id integer, value real, point_id integer, lod character, date date, data_source_id integer, indicator_id_val character varying, point_id_val character varying, data_source_id_val character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

    RETURN QUERY
    SELECT
    t.id, t.indicator_id, t.value, t.point_id, t.lod, t.date, t.data_source_id
    , indicator_id_t.name::VARCHAR AS indicator_id_val, point_id_t.point_key::VARCHAR AS point_id_val, data_source_id_t.name::VARCHAR AS data_source_id_val
    FROM data.measurement t

    LEFT JOIN data.indicator indicator_id_t ON indicator_id_t.id = t.indicator_id
    LEFT JOIN data.point point_id_t ON point_id_t.id = t.point_id
    LEFT JOIN data.data_source data_source_id_t ON data_source_id_t.id = t.data_source_id
    
    ORDER BY t.indicator_id
;
END $function$

*/
 }
/**
 * @function meta_i18n_c
 * @memberof zzglc
 * @description Meta i18n c
 * @param {character_varying} Json
 * @returns {void}
 */
function meta_i18n_c() {
/*
CREATE OR REPLACE FUNCTION zzglc.meta_i18n_c("Json" character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

    INSERT INTO meta.i18n (
        key
    )
    SELECT
        U.key
    FROM
        json_to_record("Json"::json) U (
            key character varying
        ) 
;
END $function$

*/
 }
/**
 * @function is_function_safe
 * @memberof meta
 * @description Is function safe
 * @param {character_varying} Function
 * @returns {boolean}
 */
function is_function_safe() {
/*
CREATE OR REPLACE FUNCTION meta.is_function_safe("Function" character varying)
 RETURNS boolean
 LANGUAGE plpgsql
AS $function$
BEGIN

	IF EXISTS (SELECT 1 FROM meta.safe_function WHERE name = "Function") THEN
		RETURN true;
	ELSE
	  RETURN false;
	END IF;
END $function$

*/
 }
/**
 * @function data_indicator_color_d
 * @memberof zzglc
 * @description Data indicator color d
 * @param {integer} Key
 * @returns {void}
 */
function data_indicator_color_d() {
/*
CREATE OR REPLACE FUNCTION zzglc.data_indicator_color_d("Key" integer)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

    DELETE FROM data.indicator_color
    WHERE id = "Key";

END $function$

*/
 }
/**
 * @function meta_trace_u
 * @memberof zzglc
 * @description Meta trace u
 * @param {character_varying} Json
 * @returns {void}
 */
function meta_trace_u() {
/*
CREATE OR REPLACE FUNCTION zzglc.meta_trace_u("Json" character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE v_row_count INTEGER;
BEGIN

    UPDATE meta.trace t
    SET text = U.text 
    FROM json_to_record("Json"::json) AS U (
        id integer,
            text character varying(32768),
            time_modified timestamp without time zone
    ) 
    WHERE U.id = t.id
    AND t.time_modified = U.time_modified;
    GET DIAGNOSTICS v_row_count = ROW_COUNT;
    IF v_row_count = 0 THEN
      SELECT meta.raise_error(2);
    END IF
;

END $function$

*/
 }
/**
 * @function meta_news_lang_u
 * @memberof zzglc
 * @description Meta news lang u
 * @param {character_varying} Json
 * @returns {void}
 */
function meta_news_lang_u() {
/*
CREATE OR REPLACE FUNCTION zzglc.meta_news_lang_u("Json" character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE v_row_count INTEGER;
BEGIN

    UPDATE meta.news_lang t
    SET lang_id = U.lang_id,
        text = U.text,
        extended_text = U.extended_text,
        user_modified = U.user_modified,
        time_created = U.time_created,
        active = U.active,
        title = U.title,
        news_id = U.news_id 
    FROM json_to_record("Json"::json) AS U (
        id integer,
            lang_id integer,
            text character varying(65535),
            extended_text character varying(65535),
            time_modified timestamp without time zone,
            user_modified integer,
            time_created timestamp without time zone,
            active boolean,
            title character varying(255),
            news_id integer
    ) 
    WHERE U.id = t.id
    AND t.time_modified = U.time_modified;
    GET DIAGNOSTICS v_row_count = ROW_COUNT;
    IF v_row_count = 0 THEN
      SELECT meta.raise_error(2);
    END IF
;

END $function$

*/
 }
/**
 * @function log_errors_c
 * @memberof zzglc
 * @description Log errors c
 * @param {character_varying} Json
 * @returns {void}
 */
function log_errors_c() {
/*
CREATE OR REPLACE FUNCTION zzglc.log_errors_c("Json" character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

    INSERT INTO log.errors (
        message,
        level,
        time_stamp,
        exception,
        log_event,
        tenant_id,
        user_id,
        app_id
    )
    SELECT
        U.message,
        U.level,
        U.time_stamp,
        U.exception,
        U.log_event,
        U.tenant_id,
        U.user_id,
        U.app_id
    FROM
        json_to_record("Json"::json) U (
message character varying,
            level character varying,
            time_stamp timestamp(6) without time zone,
            exception character varying,
            log_event character varying,
            tenant_id integer,
            user_id uuid,
            app_id integer
        ) 
;
END $function$

*/
 }
/**
 * @function data_geometry_type_property_l
 * @memberof zzgll
 * @description Data geometry type property l
 * @param {character_varying} SearchValue
 * @param {integer} Key
 * @returns {Object}
 * @property {integer} id
 * @property {integer} geometry_type_id
 */
function data_geometry_type_property_l() {
/*
CREATE OR REPLACE FUNCTION zzgll.data_geometry_type_property_l("SearchValue" character varying, "Key" integer DEFAULT NULL::integer)
 RETURNS TABLE(id integer, geometry_type_id integer)
 LANGUAGE plpgsql
AS $function$
BEGIN

        IF "Key" IS NOT NULL THEN
            RETURN QUERY
            SELECT t.id, t.geometry_type_id
            FROM data.geometry_type_property t
            WHERE t.id = "Key"::integer;
        ELSE
            RETURN QUERY
           SELECT t.id, t.geometry_type_id
            FROM data.geometry_type_property t
            WHERE t.geometry_type_id LIKE "SearchValue"
            ORDER BY t.geometry_type_id
           LIMIT 1000;
       END IF;
END $function$

*/
 }
/**
 * @function data_catalog_l
 * @memberof zzgll
 * @description Data catalog l
 * @param {character_varying} SearchValue
 * @param {integer} Key
 * @returns {Object}
 * @property {integer} id
 * @property {character_varying} name
 */
function data_catalog_l() {
/*
CREATE OR REPLACE FUNCTION zzgll.data_catalog_l("SearchValue" character varying, "Key" integer DEFAULT NULL::integer)
 RETURNS TABLE(id integer, name character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

        IF "Key" IS NOT NULL THEN
            RETURN QUERY
            SELECT t.id, t.name
            FROM data.catalog t
            WHERE t.id = "Key"::integer;
        ELSE
            RETURN QUERY
           SELECT t.id, t.name
            FROM data.catalog t
            WHERE t.name LIKE "SearchValue"
            ORDER BY t.name
           LIMIT 1000;
       END IF;
END $function$

*/
 }
/**
 * @function data_property_type_l
 * @memberof zzgll
 * @description Data property type l
 * @param {character_varying} SearchValue
 * @param {integer} Key
 * @returns {Object}
 * @property {integer} id
 * @property {character_varying} name
 */
function data_property_type_l() {
/*
CREATE OR REPLACE FUNCTION zzgll.data_property_type_l("SearchValue" character varying, "Key" integer DEFAULT NULL::integer)
 RETURNS TABLE(id integer, name character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

        IF "Key" IS NOT NULL THEN
            RETURN QUERY
            SELECT t.id, t.name
            FROM data.property_type t
            WHERE t.id = "Key"::integer;
        ELSE
            RETURN QUERY
           SELECT t.id, t.name
            FROM data.property_type t
            WHERE t.name LIKE "SearchValue"
            ORDER BY t.name
           LIMIT 1000;
       END IF;
END $function$

*/
 }
/**
 * @function get_locale_options
 * @memberof meta
 * @description Get locale options
 * @returns {json}
 */
function get_locale_options() {
/*
CREATE OR REPLACE FUNCTION meta.get_locale_options()
 RETURNS json
 LANGUAGE plpgsql
AS $function$
	BEGIN

	-- Routine body goes here...
	RETURN (
		SELECT json_agg(t.*)
		FROM (
			SELECT tag "value", name "label", id, short_tag
			FROM meta.lang ORDER BY name
		) t
	);
END$function$

*/
 }
/**
 * @function get_lucas
 * @memberof data
 * @description Get lucas
 * @param {text} Params
 * @param {integer} PersonId
 * @param {integer} LangId
 * @returns {Object}
 * @property {character_varying} Point
 * @property {character_varying} Depth
 * @property {double_precision} OxAl
 * @property {double_precision} N
 * @property {double_precision} P
 * @property {double_precision} OxFe
 * @property {double_precision} pH_(CaCl&lt;sub>2&lt;/sub>)
 * @property {double_precision} EC
 * @property {double_precision} K
 * @property {double_precision} OC
 * @property {double_precision} pH_(H&lt;sub>2&lt;/sub>O)
 * @property {double_precision} CaCO&lt;sub>3&lt;/sub>
 * @property {character_varying} Nuts_0
 * @property {character_varying} Nuts_1
 * @property {character_varying} Nuts_2
 * @property {character_varying} Nuts_3
 * @property {double_precision} Lat
 * @property {double_precision} Lon
 * @property {date} Date
 * @property {integer} Elevation
 * @property {character_varying} Land_cover
 * @property {character_varying} Land_usage
 * @property {character_varying} Main_land_cover
 * @property {character_varying} Detailed_land_cover
 * @property {character_varying} Detailed_land_use
 */
function get_lucas() {
/*
CREATE OR REPLACE FUNCTION data.get_lucas("Params" text, "PersonId" integer, "LangId" integer)
 RETURNS TABLE("Point" character varying, "Depth" character varying, "OxAl" double precision, "N" double precision, "P" double precision, "OxFe" double precision, "pH (CaCl&lt;sub>2&lt;/sub>)" double precision, "EC" double precision, "K" double precision, "OC" double precision, "pH (H&lt;sub>2&lt;/sub>O)" double precision, "CaCO&lt;sub>3&lt;/sub>" double precision, "Nuts_0" character varying, "Nuts_1" character varying, "Nuts_2" character varying, "Nuts_3" character varying, "Lat" double precision, "Lon" double precision, "Date" date, "Elevation" integer, "Land cover" character varying, "Land usage" character varying, "Main land cover" character varying, "Detailed land cover" character varying, "Detailed land use" character varying)
 LANGUAGE plpgsql
AS $function$
DECLARE v_data_source_id INT;
BEGIN

  v_data_source_id = 1;
	RETURN QUERY (
			SELECT p.point_key, d.name depth 
			  , t."Ox_Al", t."N", t."P", t."Ox_Fe", t."pH (CaCl2)", t."EC", t."K", t."OC", t."pH (H2O)", t."CaCO3"
			  , n0.nuts_id nuts_0, n1.nuts_id nuts_1, n2.nuts_id nuts_2, n3.nuts_id nuts_3, p.lat, p.lon, t.date, p.elev
				, lcd.code::VARCHAR lc, lud.code::VARCHAR lu, lcm.name lc0_desc, lcd.name lc1_desc, lud.name lu1_desc
			FROM (
				SELECT * FROM crosstab (
					'SELECT p.id, m.date, m.depth_id, i.name, m.value
					from data.measurement m
					INNER JOIN data.indicator i on i.id = m.indicator_id 
					INNER JOIN data.point p on p.id = m.point_id WHERE m.data_source_id = ' || v_data_source_id || ' ORDER BY 1, 2',
					'SELECT DISTINCT i.name FROM data.indicator i inner join data.measurement m on m.indicator_id = i.id AND m.data_source_id = ' || v_data_source_id

				) AS ct (id int, date date, depth_id int, "Ox_Al" float, "N" float, "P" float, "Ox_Fe" float, "pH (CaCl2)" float, "EC" float, "K" float, "OC" float, "pH (H2O)" float, "CaCO3" float)
			) t
			INNER JOIN data.point p on p.id = t.id
			LEFT JOIN data.vw_nuts v ON v.l3_id = p.l3_id
			LEFT JOIN general.nuts n0 ON n0.id = v.l0_id
			LEFT JOIN general.nuts n1 ON n1.id = v.l1_id
			LEFT JOIN general.nuts n2 ON n2.id = v.l2_id
			LEFT JOIN general.nuts n3 ON n3.id = v.l3_id	
			LEFT JOIN data.attribute a_lcd ON a_lcd.indicator_id = 14 and a_lcd.point_id = p.id and a_lcd.data_source_id = v_data_source_id
			LEFT JOIN data.attribute a_lcm ON a_lcm.indicator_id = 15 and a_lcm.point_id = p.id and a_lcm.data_source_id = v_data_source_id	
			LEFT JOIN data.attribute a_lud ON a_lud.indicator_id = 16 and a_lud.point_id = p.id and a_lud.data_source_id = v_data_source_id					
			LEFT JOIN data.depth d ON d.id = t.depth_id
			LEFT JOIN data.attribute_description lcm 
				ON lcm.indicator_id = a_lcm.indicator_id AND lcm.description_id = a_lcm.description_id 
			LEFT JOIN data.attribute_description lcd 
				ON lcd.indicator_id = a_lcd.indicator_id AND lcd.description_id = a_lcd.description_id
			LEFT JOIN data.attribute_description lud ON 
				lud.indicator_id = a_lud.indicator_id AND lud.description_id = a_lud.description_id
			--LEFT JOIN data.lc_main lcm ON lcm.id = a_lcm.description_id
			--LEFT JOIN data.lc_detail lcd ON lcd.id = a_lcd.description_id
			--LEFT JOIN data.lu_detail lud ON lud.id = a_lud.description_id
			ORDER BY 2
--		) t
	);
		
END $function$

*/
 }
/**
 * @function meta_help_lang_c
 * @memberof zzglc
 * @description Meta help lang c
 * @param {character_varying} Json
 * @returns {void}
 */
function meta_help_lang_c() {
/*
CREATE OR REPLACE FUNCTION zzglc.meta_help_lang_c("Json" character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

    INSERT INTO meta.help_lang (
        help_id,
        lang_id,
        value
    )
    SELECT
        U.help_id,
        U.lang_id,
        U.value
    FROM
        json_to_record("Json"::json) U (
help_id integer,
            lang_id integer,
            value character varying(1024)
        ) 
;
END $function$

*/
 }
/**
 * @function auth_role_public_l
 * @memberof zzgll
 * @description Auth role public l
 * @param {character_varying} SearchValue
 * @param {integer} Key
 * @returns {Object}
 * @property {integer} id
 * @property {character_varying} name
 */
function auth_role_public_l() {
/*
CREATE OR REPLACE FUNCTION zzgll.auth_role_public_l("SearchValue" character varying, "Key" integer DEFAULT NULL::integer)
 RETURNS TABLE(id integer, name character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

        IF "Key" IS NOT NULL THEN
            RETURN QUERY
            SELECT t.id, t.name
            FROM auth.role_public t
            WHERE t.id = "Key"::integer;
        ELSE
            RETURN QUERY
            SELECT t.id, t.name
            FROM auth.role_public t
            WHERE t.name LIKE "SearchValue"
            ORDER BY t.name
            LIMIT 1000;
       END IF;
END $function$

*/
 }
/**
 * @function general_partner_u
 * @memberof zzglc
 * @description General partner u
 * @param {character_varying} Json
 * @returns {void}
 */
function general_partner_u() {
/*
CREATE OR REPLACE FUNCTION zzglc.general_partner_u("Json" character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE v_row_count INTEGER;
BEGIN

    UPDATE general.partner t
    SET short_name = U.short_name,
        name = U.name,
        user_modified = U.user_modified 
    FROM json_to_record("Json"::json) AS U (
        id integer,
            short_name character varying(64),
            name character varying(256),
            time_modified timestamp without time zone,
            user_modified integer
    ) 
    WHERE U.id = t.id
    AND t.time_modified = U.time_modified;
    GET DIAGNOSTICS v_row_count = ROW_COUNT;
    IF v_row_count = 0 THEN
      SELECT meta.raise_error(2);
    END IF
;

END $function$

*/
 }
/**
 * @function log_errors_d
 * @memberof zzglc
 * @description Log errors d
 * @param {integer} Key
 * @returns {void}
 */
function log_errors_d() {
/*
CREATE OR REPLACE FUNCTION zzglc.log_errors_d("Key" integer)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

    DELETE FROM log.errors
    WHERE id = "Key";

END $function$

*/
 }
/**
 * @function data_indicator_color_c
 * @memberof zzglc
 * @description Data indicator color c
 * @param {character_varying} Json
 * @returns {void}
 */
function data_indicator_color_c() {
/*
CREATE OR REPLACE FUNCTION zzglc.data_indicator_color_c("Json" character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

    INSERT INTO data.indicator_color (
        indicator_id,
        value_to,
        color_id
    )
    SELECT
        U.indicator_id,
        U.value_to,
        U.color_id
    FROM
        json_to_record("Json"::json) U (
indicator_id integer,
            value_to real,
            color_id integer
        ) 
;
END $function$

*/
 }
/**
 * @function data_lc_detail_u
 * @memberof zzglc
 * @description Data lc detail u
 * @param {character_varying} Json
 * @returns {void}
 */
function data_lc_detail_u() {
/*
CREATE OR REPLACE FUNCTION zzglc.data_lc_detail_u("Json" character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE v_row_count INTEGER;
BEGIN

    UPDATE data.lc_detail t
    SET name = U.name,
        color_id = U.color_id,
        code = U.code 
    FROM json_to_record("Json"::json) AS U (
        id integer,
            name character varying,
            color_id integer,
            code character(3)
    ) 
    WHERE U.id = t.id
;

END $function$

*/
 }
/**
 * @function meta_lang_d
 * @memberof zzglc
 * @description Meta lang d
 * @param {integer} Key
 * @returns {void}
 */
function meta_lang_d() {
/*
CREATE OR REPLACE FUNCTION zzglc.meta_lang_d("Key" integer)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

    DELETE FROM meta.lang
    WHERE id = "Key";

END $function$

*/
 }
/**
 * @function delete_message
 * @memberof general
 * @description Delete message
 * @param {integer} Id
 * @returns {void}
 */
function delete_message() {
/*
CREATE OR REPLACE FUNCTION general.delete_message("Id" integer)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

	DELETE FROM general.message WHERE id = "Id";
	DELETE FROM general.message WHERE parent_id = "Id";
	RETURN;
END$function$

*/
 }
/**
 * @function data_nuts_2_l
 * @memberof zzgll
 * @description Data nuts 2 l
 * @param {character_varying} SearchValue
 * @param {integer} Key
 * @returns {Object}
 * @property {integer} id
 * @property {character_varying} name
 */
function data_nuts_2_l() {
/*
CREATE OR REPLACE FUNCTION zzgll.data_nuts_2_l("SearchValue" character varying, "Key" integer DEFAULT NULL::integer)
 RETURNS TABLE(id integer, name character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

        IF "Key" IS NOT NULL THEN
            RETURN QUERY
            SELECT t.id, t.name
            FROM data.nuts_2 t
            WHERE t.id = "Key"::integer;
        ELSE
            RETURN QUERY
           SELECT t.id, t.name
            FROM data.nuts_2 t
            WHERE t.name LIKE "SearchValue"
            ORDER BY t.name
           LIMIT 1000;
       END IF;
END $function$

*/
 }
/**
 * @function meta_safe_function_d
 * @memberof zzglc
 * @description Meta safe function d
 * @param {integer} Key
 * @returns {void}
 */
function meta_safe_function_d() {
/*
CREATE OR REPLACE FUNCTION zzglc.meta_safe_function_d("Key" integer)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

    DELETE FROM meta.safe_function
    WHERE id = "Key";

END $function$

*/
 }
/**
 * @function data_shape_d
 * @memberof zzglc
 * @description Data shape d
 * @param {integer} Key
 * @returns {void}
 */
function data_shape_d() {
/*
CREATE OR REPLACE FUNCTION zzglc.data_shape_d("Key" integer)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

    DELETE FROM data.shape
    WHERE id = "Key";

END $function$

*/
 }
/**
 * @function data_measurement_u
 * @memberof zzglc
 * @description Data measurement u
 * @param {character_varying} Json
 * @returns {void}
 */
function data_measurement_u() {
/*
CREATE OR REPLACE FUNCTION zzglc.data_measurement_u("Json" character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE v_row_count INTEGER;
BEGIN

    UPDATE data.measurement t
    SET indicator_id = U.indicator_id,
        value = U.value,
        point_id = U.point_id,
        lod = U.lod,
        date = U.date,
        data_source_id = U.data_source_id 
    FROM json_to_record("Json"::json) AS U (
        id integer,
            indicator_id integer,
            value real,
            point_id integer,
            lod character(1),
            date date,
            data_source_id integer
    ) 
    WHERE U.id = t.id
;

END $function$

*/
 }
/**
 * @function data_attribute_r
 * @memberof zzglc
 * @description Data attribute r
 * @returns {Object}
 * @property {integer} id
 * @property {integer} point_id
 * @property {integer} indicator_id
 * @property {integer} description_id
 * @property {integer} data_source_id
 * @property {date} date
 * @property {integer} attribute_description_id
 * @property {character_varying} point_id_val
 * @property {character_varying} indicator_id_val
 * @property {character_varying} data_source_id_val
 * @property {character_varying} attribute_description_id_val
 */
function data_attribute_r() {
/*
CREATE OR REPLACE FUNCTION zzglc.data_attribute_r()
 RETURNS TABLE(id integer, point_id integer, indicator_id integer, description_id integer, data_source_id integer, date date, attribute_description_id integer, point_id_val character varying, indicator_id_val character varying, data_source_id_val character varying, attribute_description_id_val character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

    RETURN QUERY
    SELECT
    t.id, t.point_id, t.indicator_id, t.description_id, t.data_source_id, t.date, t.attribute_description_id
    , point_id_t.point_key::VARCHAR AS point_id_val, indicator_id_t.name::VARCHAR AS indicator_id_val, data_source_id_t.name::VARCHAR AS data_source_id_val, attribute_description_id_t.name::VARCHAR AS attribute_description_id_val
    FROM data.attribute t

    LEFT JOIN data.point point_id_t ON point_id_t.id = t.point_id
    LEFT JOIN data.indicator indicator_id_t ON indicator_id_t.id = t.indicator_id
    LEFT JOIN data.data_source data_source_id_t ON data_source_id_t.id = t.data_source_id
    LEFT JOIN data.attribute_description attribute_description_id_t ON attribute_description_id_t.id = t.attribute_description_id
    
    ORDER BY t.point_id
;
END $function$

*/
 }
/**
 * @function data_license_c
 * @memberof zzglc
 * @description Data license c
 * @param {character_varying} Json
 * @returns {void}
 */
function data_license_c() {
/*
CREATE OR REPLACE FUNCTION zzglc.data_license_c("Json" character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

    INSERT INTO data.license (
        name
    )
    SELECT
        U.name
    FROM
        json_to_record("Json"::json) U (
name character varying
        ) 
;
END $function$

*/
 }
/**
 * @function meta_news_lang_d
 * @memberof zzglc
 * @description Meta news lang d
 * @param {integer} Key
 * @returns {void}
 */
function meta_news_lang_d() {
/*
CREATE OR REPLACE FUNCTION zzglc.meta_news_lang_d("Key" integer)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

    DELETE FROM meta.news_lang
    WHERE id = "Key";

END $function$

*/
 }
/**
 * @function general_country_l
 * @memberof zzgll
 * @description General country l
 * @param {character_varying} SearchValue
 * @param {smallint} Key
 * @returns {Object}
 * @property {smallint} id
 * @property {character_varying} name
 */
function general_country_l() {
/*
CREATE OR REPLACE FUNCTION zzgll.general_country_l("SearchValue" character varying, "Key" smallint DEFAULT NULL::smallint)
 RETURNS TABLE(id smallint, name character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

        IF "Key" IS NOT NULL THEN
            RETURN QUERY
            SELECT t.id, t.name
            FROM general.country t
            WHERE t.id = "Key"::smallint;
        ELSE
            RETURN QUERY
           SELECT t.id, t.name
            FROM general.country t
            WHERE t.name LIKE "SearchValue"
            ORDER BY t.name
           LIMIT 1000;
       END IF;
END $function$

*/
 }
/**
 * @function meta_import_detail_d
 * @memberof zzglc
 * @description Meta import detail d
 * @param {integer} Key
 * @returns {void}
 */
function meta_import_detail_d() {
/*
CREATE OR REPLACE FUNCTION zzglc.meta_import_detail_d("Key" integer)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

    DELETE FROM meta.import_detail
    WHERE id = "Key";

END $function$

*/
 }
/**
 * @function data_file_type_l
 * @memberof zzgll
 * @description Data file type l
 * @param {character_varying} SearchValue
 * @param {integer} Key
 * @returns {Object}
 * @property {integer} id
 * @property {character_varying} name
 */
function data_file_type_l() {
/*
CREATE OR REPLACE FUNCTION zzgll.data_file_type_l("SearchValue" character varying, "Key" integer DEFAULT NULL::integer)
 RETURNS TABLE(id integer, name character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

        IF "Key" IS NOT NULL THEN
            RETURN QUERY
            SELECT t.id, t.name
            FROM data.file_type t
            WHERE t.id = "Key"::integer;
        ELSE
            RETURN QUERY
           SELECT t.id, t.name
            FROM data.file_type t
            WHERE t.name LIKE "SearchValue"
            ORDER BY t.name
           LIMIT 1000;
       END IF;
END $function$

*/
 }
/**
 * @function data_date_style_c
 * @memberof zzglc
 * @description Data date style c
 * @param {character_varying} Json
 * @returns {void}
 */
function data_date_style_c() {
/*
CREATE OR REPLACE FUNCTION zzglc.data_date_style_c("Json" character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

    INSERT INTO data.date_style (
        name
    )
    SELECT
        U.name
    FROM
        json_to_record("Json"::json) U (
name character varying
        ) 
;
END $function$

*/
 }
/**
 * @function data_oedce_c
 * @memberof zzglc
 * @description Data oedce c
 * @param {character_varying} Json
 * @returns {void}
 */
function data_oedce_c() {
/*
CREATE OR REPLACE FUNCTION zzglc.data_oedce_c("Json" character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

    INSERT INTO data.oedce (
        start_datetime,
        end_datetime,
        gsd,
        instruments,
        datetime,
        item_id,
        item_bbox,
        href,
        type,
        main,
        roles,
        asset_id,
        collection_id,
        collection_title,
        collection_description,
        collection_providers,
        collection_keywords,
        collection_license,
        platform,
        geom
    )
    SELECT
        U.start_datetime,
        U.end_datetime,
        U.gsd,
        U.instruments,
        U.datetime,
        U.item_id,
        U.item_bbox,
        U.href,
        U.type,
        U.main,
        U.roles,
        U.asset_id,
        U.collection_id,
        U.collection_title,
        U.collection_description,
        U.collection_providers,
        U.collection_keywords,
        U.collection_license,
        U.platform,
        U.geom
    FROM
        json_to_record("Json"::json) U (
            start_datetime character varying,
            end_datetime character varying,
            gsd character varying,
            instruments character varying,
            datetime character varying,
            item_id character varying,
            item_bbox character varying,
            href character varying,
            type character varying,
            main character varying,
            roles character varying,
            asset_id character varying,
            collection_id character varying,
            collection_title character varying,
            collection_description character varying,
            collection_providers character varying,
            collection_keywords character varying,
            collection_license character varying,
            platform character varying,
            geom geometry
        ) 
;
END $function$

*/
 }
/**
 * @function auth_role_public_d
 * @memberof zzglc
 * @description Auth role public d
 * @param {integer} Key
 * @returns {void}
 */
function auth_role_public_d() {
/*
CREATE OR REPLACE FUNCTION zzglc.auth_role_public_d("Key" integer)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

    DELETE FROM auth.role_public
    WHERE id = "Key";

END $function$

*/
 }
/**
 * @function route_reorder
 * @memberof meta
 * @description Route reorder
 * @param {character_varying} SourceId
 * @param {integer} ToIndex
 * @returns {void}
 */
function route_reorder() {
/*
CREATE OR REPLACE FUNCTION meta.route_reorder("SourceId" character varying, "ToIndex" integer DEFAULT 0)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

	
	UPDATE meta.route
	SET order_no = "ToIndex"
	WHERE id = "SourceId"::INT;

	UPDATE meta.route
	SET order_no = order_no + 1
	WHERE order_no >= "ToIndex"
	AND id &lt;> "SourceId"::INT;

	WITH cte AS (
		SELECT t.id, row_number() over (ORDER BY t.order_no) new_order_no
		FROM meta.route t
	  ORDER BY t.order_no
	) 
	UPDATE meta.route gc
	SET order_no = cte.new_order_no
	FROM cte 
	WHERE gc.id = cte.id;

END $function$

*/
 }
/**
 * @function remove_quotes_from_table
 * @memberof meta
 * @description Remove quotes from table
 * @param {character_varying} TableName
 * @returns {void}
 */
function remove_quotes_from_table() {
/*
CREATE OR REPLACE FUNCTION meta.remove_quotes_from_table("TableName" character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE
    v_column_name text;
		v_data_type text;
BEGIN

    FOR v_column_name, v_data_type IN
        SELECT c.column_name, c.data_type
        FROM information_schema.columns c
        WHERE c.table_name = "TableName"
    LOOP
				IF v_data_type IN ('character varying', 'text', 'character') THEN
					EXECUTE format('
							UPDATE %I
							SET %I = TRIM(BOTH ''"\'' FROM %I)',
							"TableName",
							v_column_name,
							v_column_name
					);
				END IF;
    END LOOP;
END;
$function$

*/
 }
/**
 * @function meta_i18n_r
 * @memberof zzglc
 * @description Meta i18n r
 * @returns {Object}
 * @property {integer} id
 * @property {character_varying} key
 */
function meta_i18n_r() {
/*
CREATE OR REPLACE FUNCTION zzglc.meta_i18n_r()
 RETURNS TABLE(id integer, key character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

    RETURN QUERY
    SELECT
    t.id, t.key
    FROM meta.i18n t
    
    ORDER BY t.key
;
END $function$

*/
 }
/**
 * @function get_ai_models
 * @memberof general
 * @description Get ai models
 * @returns {Object}
 * @property {integer} value
 * @property {character_varying} label
 */
function get_ai_models() {
/*
CREATE OR REPLACE FUNCTION general.get_ai_models()
 RETURNS TABLE(value integer, label character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

	-- Routine body goes here...
	RETURN QUERY (
		SELECT id, name FROM general.ai_model ORDER BY 2
	);

END $function$

*/
 }
/**
 * @function data_unit_u
 * @memberof zzglc
 * @description Data unit u
 * @param {character_varying} Json
 * @returns {void}
 */
function data_unit_u() {
/*
CREATE OR REPLACE FUNCTION zzglc.data_unit_u("Json" character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE v_row_count INTEGER;
BEGIN

    UPDATE data.unit t
    SET name = U.name 
    FROM json_to_record("Json"::json) AS U (
        id integer,
            name character varying(255)
    ) 
    WHERE U.id = t.id
;

END $function$

*/
 }
/**
 * @function set_nuts
 * @memberof general
 * @description Set nuts
 * @param {text} Properties
 * @param {text} Geometry
 * @returns {void}
 */
function set_nuts() {
/*
CREATE OR REPLACE FUNCTION general.set_nuts("Properties" text, "Geometry" text)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE p json;
BEGIN

	p := "Properties"::json;

	DELETE FROM general.nuts WHERE nuts_id = (p->'NUTS_ID')::varchar;
	INSERT INTO general.nuts (nuts_id, levl_code, cntr_code, name_latn, nuts_name, mount_type, urbn_type, coast_type, fid, geom) 
	VALUES(
		(p->>'NUTS_ID')::varchar, 
		(p->>'LEVL_CODE')::int,
		(p->>'CNTR_CODE')::VARCHAR,
		(p->>'NAME_LATN')::varchar,
		(p->>'NUTS_NAME')::VARCHAR,
		(p->>'MOUNT_TYPE')::int,
		(p->>'URBN_TYPE')::int,
		(p->>'COAST_TYPE')::int,
		(p->>'FID')::varchar,
	-- st_transform(st_multi(st_geomfromgeojson("Geometry")), 3035);	
	st_multi(st_setsrid(st_geomfromgeojson("Geometry"), 3035))
	);
RETURN;
END$function$

*/
 }
/**
 * @function general_boundary_d
 * @memberof zzglc
 * @description General boundary d
 * @param {integer} Key
 * @returns {void}
 */
function general_boundary_d() {
/*
CREATE OR REPLACE FUNCTION zzglc.general_boundary_d("Key" integer)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

    DELETE FROM general.boundary
    WHERE id = "Key";

END $function$

*/
 }
/**
 * @function data_unit_d
 * @memberof zzglc
 * @description Data unit d
 * @param {integer} Key
 * @returns {void}
 */
function data_unit_d() {
/*
CREATE OR REPLACE FUNCTION zzglc.data_unit_d("Key" integer)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

    DELETE FROM data.unit
    WHERE id = "Key";

END $function$

*/
 }
/**
 * @function get_or_create_person_id
 * @memberof auth
 * @description Get or create person id
 * @param {character_varying} Email
 * @param {character_varying} FirstName
 * @param {character_varying} LastName
 * @returns {integer}
 */
function get_or_create_person_id() {
/*
CREATE OR REPLACE FUNCTION auth.get_or_create_person_id("Email" character varying, "FirstName" character varying, "LastName" character varying)
 RETURNS integer
 LANGUAGE plpgsql
AS $function$
	DECLARE v_id INT;
BEGIN

	-- Routine body goes here...
	
		SELECT p.id INTO v_id
		FROM general.person p 
		WHERE p.user_email = "Email";
		
		IF v_id IS NULL THEN
			INSERT INTO general.person (user_email, first_name, last_name)
			VALUES ("Email", "FirstName", "LastName")
			RETURNING id INTO v_id;
		END IF;
		
	  RETURN v_id;

END $function$

*/
 }
/**
 * @function data_measurement_c
 * @memberof zzglc
 * @description Data measurement c
 * @param {character_varying} Json
 * @returns {void}
 */
function data_measurement_c() {
/*
CREATE OR REPLACE FUNCTION zzglc.data_measurement_c("Json" character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

    INSERT INTO data.measurement (
        indicator_id,
        value,
        point_id,
        lod,
        date,
        data_source_id
    )
    SELECT
        U.indicator_id,
        U.value,
        U.point_id,
        U.lod,
        U.date,
        U.data_source_id
    FROM
        json_to_record("Json"::json) U (
indicator_id integer,
            value real,
            point_id integer,
            lod character(1),
            date date,
            data_source_id integer
        ) 
;
END $function$

*/
 }
/**
 * @function role_public_history
 * @memberof auth
 * @description Role public history
 * @returns {trigger}
 */
function role_public_history() {
/*
CREATE OR REPLACE FUNCTION auth.role_public_history()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$ 
DECLARE v_person_id INT;
				v_user_id UUID; 
BEGIN

	v_person_id := auth.get_context_person_id();
  v_user_id := auth.get_context_user_id();

	IF TG_OP = 'DELETE' THEN
		INSERT INTO zzHistory.auth_role_public (
            id,
            name,
            ModifiedUserId,
            ModifiedPersonId,
            ModifiedTime,
            ModifiedLogin,
            ModifiedAction
		)
		SELECT OLD.id,
               OLD.name,
               v_user_id,
               v_person_id,
               CURRENT_TIMESTAMP,
               CURRENT_USER,
               'D';
	ELSE
		INSERT INTO zzHistory.auth_role_public (
id,
            name,
            ModifiedUserId,
            ModifiedPersonId,
            ModifiedTime,
            ModifiedLogin,
            ModifiedAction
		)
		SELECT NEW.id,
               NEW.name,
               v_user_id,
               v_person_id,
               CURRENT_TIMESTAMP,
               CURRENT_USER,
               CASE WHEN TG_OP = 'INSERT' THEN 'I' ELSE 'U' END;
	END IF;
	RETURN NULL;
END $function$

*/
 }
/**
 * @function meta_i18n_lang_c
 * @memberof zzglc
 * @description Meta i18n lang c
 * @param {character_varying} Json
 * @returns {void}
 */
function meta_i18n_lang_c() {
/*
CREATE OR REPLACE FUNCTION zzglc.meta_i18n_lang_c("Json" character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

    INSERT INTO meta.i18n_lang (
        i18n_id,
        lang_id,
        value
    )
    SELECT
        U.i18n_id,
        U.lang_id,
        U.value
    FROM
        json_to_record("Json"::json) U (
i18n_id integer,
            lang_id integer,
            value character varying(255)
        ) 
;
END $function$

*/
 }
/**
 * @function data_license_d
 * @memberof zzglc
 * @description Data license d
 * @param {integer} Key
 * @returns {void}
 */
function data_license_d() {
/*
CREATE OR REPLACE FUNCTION zzglc.data_license_d("Key" integer)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

    DELETE FROM data.license
    WHERE id = "Key";

END $function$

*/
 }
/**
 * @function data_oedce_u
 * @memberof zzglc
 * @description Data oedce u
 * @param {character_varying} Json
 * @returns {void}
 */
function data_oedce_u() {
/*
CREATE OR REPLACE FUNCTION zzglc.data_oedce_u("Json" character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE v_row_count INTEGER;
BEGIN

    UPDATE data.oedce t
    SET start_datetime = U.start_datetime,
        end_datetime = U.end_datetime,
        gsd = U.gsd,
        instruments = U.instruments,
        datetime = U.datetime,
        item_id = U.item_id,
        item_bbox = U.item_bbox,
        href = U.href,
        type = U.type,
        main = U.main,
        roles = U.roles,
        asset_id = U.asset_id,
        collection_id = U.collection_id,
        collection_title = U.collection_title,
        collection_description = U.collection_description,
        collection_providers = U.collection_providers,
        collection_keywords = U.collection_keywords,
        collection_license = U.collection_license,
        platform = U.platform,
        geom = U.geom 
    FROM json_to_record("Json"::json) AS U (
        fid integer,
            start_datetime character varying,
            end_datetime character varying,
            gsd character varying,
            instruments character varying,
            datetime character varying,
            item_id character varying,
            item_bbox character varying,
            href character varying,
            type character varying,
            main character varying,
            roles character varying,
            asset_id character varying,
            collection_id character varying,
            collection_title character varying,
            collection_description character varying,
            collection_providers character varying,
            collection_keywords character varying,
            collection_license character varying,
            platform character varying,
            geom geometry(Polygon,900914)
    ) 
    WHERE U.fid = t.fid
;

END $function$

*/
 }
/**
 * @function data_property_u
 * @memberof zzglc
 * @description Data property u
 * @param {character_varying} Json
 * @returns {void}
 */
function data_property_u() {
/*
CREATE OR REPLACE FUNCTION zzglc.data_property_u("Json" character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE v_row_count INTEGER;
BEGIN

    UPDATE data.property t
    SET name = U.name,
        indicator_id = U.indicator_id,
        unit_id = U.unit_id,
        data_type_id = U.data_type_id,
        numerical = U.numerical,
        mask = U.mask 
    FROM json_to_record("Json"::json) AS U (
        id integer,
            name character varying(255),
            indicator_id integer,
            unit_id integer,
            data_type_id integer,
            numerical boolean,
            mask character varying(255)
    ) 
    WHERE U.id = t.id
;

END $function$

*/
 }
/**
 * @function data_asset_version_c
 * @memberof zzglc
 * @description Data asset version c
 * @param {character_varying} Json
 * @returns {void}
 */
function data_asset_version_c() {
/*
CREATE OR REPLACE FUNCTION zzglc.data_asset_version_c("Json" character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

    INSERT INTO data.asset_version (
        name,
        srid
    )
    SELECT
        U.name,
        U.srid
    FROM
        json_to_record("Json"::json) U (
name character varying,
            srid character varying
        ) 
;
END $function$

*/
 }
/**
 * @function data_lc_l
 * @memberof zzgll
 * @description Data lc l
 * @param {character_varying} SearchValue
 * @param {integer} Key
 * @returns {Object}
 * @property {integer} id
 * @property {character_varying} name
 */
function data_lc_l() {
/*
CREATE OR REPLACE FUNCTION zzgll.data_lc_l("SearchValue" character varying, "Key" integer DEFAULT NULL::integer)
 RETURNS TABLE(id integer, name character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

        IF "Key" IS NOT NULL THEN
            RETURN QUERY
            SELECT t.id, t.name
            FROM data.lc t
            WHERE t.id = "Key"::integer;
        ELSE
            RETURN QUERY
           SELECT t.id, t.name
            FROM data.lc t
            WHERE t.name LIKE "SearchValue"
            ORDER BY t.name
           LIMIT 1000;
       END IF;
END $function$

*/
 }
/**
 * @function calculate_levels
 * @memberof general
 * @description Calculate levels
 * @returns {void}
 */
function calculate_levels() {
/*
CREATE OR REPLACE FUNCTION general.calculate_levels()
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

	WITH RECURSIVE rh AS (
		SELECT t.osm_id AS osm_id, 1 AS level
		FROM general.boundary t 
		WHERE t.admin_level = 2
		-- LEFT JOIN general.boundary_hierarchy h ON h.child_id = t.osm_id
		-- WHERE h.id IS NULL
		UNION ALL
		SELECT h.child_id, rh.level + 1
		FROM general.boundary_hierarchy h
		INNER JOIN rh ON h.parent_id = rh.osm_id
	)

	UPDATE general.boundary t set level = rh.level 
	FROM rh WHERE t.osm_id = rh.osm_id;
	
END $function$

*/
 }
/**
 * @function general_partner_d
 * @memberof zzglc
 * @description General partner d
 * @param {integer} Key
 * @returns {void}
 */
function general_partner_d() {
/*
CREATE OR REPLACE FUNCTION zzglc.general_partner_d("Key" integer)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

    DELETE FROM general.partner
    WHERE id = "Key";

END $function$

*/
 }
/**
 * @function get_context_lang_id
 * @memberof auth
 * @description Get context lang id
 * @returns {integer}
 */
function get_context_lang_id() {
/*
CREATE OR REPLACE FUNCTION auth.get_context_lang_id()
 RETURNS integer
 LANGUAGE plpgsql
AS $function$ 
BEGIN

	RETURN current_setting('context.lang_id', true)::INTEGER;
END $function$

*/
 }
/**
 * @function data_lu_detail_d
 * @memberof zzglc
 * @description Data lu detail d
 * @param {integer} Key
 * @returns {void}
 */
function data_lu_detail_d() {
/*
CREATE OR REPLACE FUNCTION zzglc.data_lu_detail_d("Key" integer)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

    DELETE FROM data.lu_detail
    WHERE id = "Key";

END $function$

*/
 }

/**
 * @function import_proc_from_gl
 * @memberof meta
 * @description Import proc from gl
 * @param {character_varying} SchemaName
 * @param {character_varying} ProcName
 * @returns {void}
 */
function import_proc_from_gl() {
/*
CREATE OR REPLACE PROCEDURE meta.import_proc_from_gl(IN "SchemaName" character varying, IN "ProcName" character varying)
 LANGUAGE plpgsql
AS $procedure$
	DECLARE sql VARCHAR;
BEGIN

	select definition --|| ' language ' || function_language 
	INTO sql			 
	from zzz_pg_catalog_gl.vwproc v
	where v.function_schema = "SchemaName"
	  AND v.function_name = "ProcName";
	raise notice '%', sql;
	EXECUTE sql;
END $procedure$

*/
 }
/**
 * @function data_lu_l
 * @memberof zzgll
 * @description Data lu l
 * @param {character_varying} SearchValue
 * @param {integer} Key
 * @returns {Object}
 * @property {integer} id
 * @property {character_varying} name
 */
function data_lu_l() {
/*
CREATE OR REPLACE FUNCTION zzgll.data_lu_l("SearchValue" character varying, "Key" integer DEFAULT NULL::integer)
 RETURNS TABLE(id integer, name character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

        IF "Key" IS NOT NULL THEN
            RETURN QUERY
            SELECT t.id, t.name
            FROM data.lu t
            WHERE t.id = "Key"::integer;
        ELSE
            RETURN QUERY
           SELECT t.id, t.name
            FROM data.lu t
            WHERE t.name LIKE "SearchValue"
            ORDER BY t.name
           LIMIT 1000;
       END IF;
END $function$

*/
 }
/**
 * @function data_asset_version_r
 * @memberof zzglc
 * @description Data asset version r
 * @returns {Object}
 * @property {integer} id
 * @property {character_varying} name
 * @property {character_varying} srid
 */
function data_asset_version_r() {
/*
CREATE OR REPLACE FUNCTION zzglc.data_asset_version_r()
 RETURNS TABLE(id integer, name character varying, srid character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

    RETURN QUERY
    SELECT
    t.id, t.name, t.srid
    FROM data.asset_version t
    
    ORDER BY t.name
;
END $function$

*/
 }
/**
 * @function get_locations
 * @memberof data
 * @description Get locations
 * @param {text} Params
 * @param {integer} PersonId
 * @param {integer} LangId
 * @returns {Object}
 * @property {integer} id
 * @property {character_varying} name
 * @property {character_varying} type
 * @property {boolean} public
 */
function get_locations() {
/*
CREATE OR REPLACE FUNCTION data.get_locations("Params" text, "PersonId" integer, "LangId" integer)
 RETURNS TABLE(id integer, name character varying, type character varying, public boolean)
 LANGUAGE plpgsql
AS $function$
BEGIN

	RETURN QUERY (
        SELECT f.id, f.name, gt.name, f.public --, f.time_created, f.time_modified
		FROM data.custom_geometry f
		LEFT JOIN data.geometry_type gt ON gt.id = f.geometry_type_id
		WHERE f.person_id = "PersonId"
        GROUP BY f.id, gt.name
	);
		
END 
$function$

*/
 }
/**
 * @function data_custom_geometry_d
 * @memberof zzglc
 * @description Data custom geometry d
 * @param {integer} Key
 * @returns {void}
 */
function data_custom_geometry_d() {
/*
CREATE OR REPLACE FUNCTION zzglc.data_custom_geometry_d("Key" integer)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

    DELETE FROM data.custom_geometry
    WHERE id = "Key";

END $function$

*/
 }
/**
 * @function meta_import_detail_u
 * @memberof zzglc
 * @description Meta import detail u
 * @param {character_varying} Json
 * @returns {void}
 */
function meta_import_detail_u() {
/*
CREATE OR REPLACE FUNCTION zzglc.meta_import_detail_u("Json" character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE v_row_count INTEGER;
BEGIN

    UPDATE meta.import_detail t
    SET import_master_id = U.import_master_id,
        col_name = U.col_name,
        target_schema = U.target_schema,
        target_table = U.target_table,
        target_column = U.target_column,
        col_type = U.col_type,
        is_key = U.is_key,
        is_fk = U.is_fk,
        as_row = U.as_row,
        target_column_list = U.target_column_list,
        source_column_list = U.source_column_list,
        joins = U.joins,
        split = U.split,
        ignore = U.ignore,
        name_match = U.name_match,
        order_no = U.order_no,
        ignore_in_master = U.ignore_in_master,
        constant_value = U.constant_value 
    FROM json_to_record("Json"::json) AS U (
        id integer,
            import_master_id integer,
            col_name character varying(255),
            target_schema character varying(255),
            target_table character varying(255),
            target_column character varying(255),
            col_type character varying(255),
            is_key boolean,
            is_fk boolean,
            name character varying,
            as_row boolean,
            target_column_list character varying(1024),
            source_column_list character varying(1024),
            joins character varying(8192),
            split boolean,
            ignore boolean,
            name_match character varying(255),
            order_no integer,
            ignore_in_master boolean,
            constant_value character varying(255)
    ) 
    WHERE U.id = t.id
;

END $function$

*/
 }
/**
 * @function data_attribute_description_c
 * @memberof zzglc
 * @description Data attribute description c
 * @param {character_varying} Json
 * @returns {integer}
 */
function data_attribute_description_c() {
/*
CREATE OR REPLACE FUNCTION zzglc.data_attribute_description_c("Json" character varying)
 RETURNS integer
 LANGUAGE plpgsql
AS $function$
   DECLARE v_id integer;
BEGIN

    INSERT INTO data.attribute_description (
        indicator_id,
        description_id,
        name,
        color_id,
        code
    )
    SELECT
        U.indicator_id,
        U.description_id,
        U.name,
        U.color_id,
        U.code
    FROM
        json_to_record("Json"::json) U (
indicator_id integer,
            description_id integer,
            name character varying(255),
            color_id integer,
            code character varying(255)
        ) 
    RETURNING id INTO v_id;

    RETURN v_id;
END $function$

*/
 }
/**
 * @function general_sub_region_u
 * @memberof zzglc
 * @description General sub region u
 * @param {character_varying} Json
 * @returns {void}
 */
function general_sub_region_u() {
/*
CREATE OR REPLACE FUNCTION zzglc.general_sub_region_u("Json" character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE v_row_count INTEGER;
BEGIN

    UPDATE general.sub_region t
    SET name = U.name 
    FROM json_to_record("Json"::json) AS U (
        id smallint,
            name character varying(255)
    ) 
    WHERE U.id = t.id
;

END $function$

*/
 }
/**
 * @function data_date_unit_d
 * @memberof zzglc
 * @description Data date unit d
 * @param {integer} Key
 * @returns {void}
 */
function data_date_unit_d() {
/*
CREATE OR REPLACE FUNCTION zzglc.data_date_unit_d("Key" integer)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

    DELETE FROM data.date_unit
    WHERE id = "Key";

END $function$

*/
 }
/**
 * @function get_indicator_legend
 * @memberof data
 * @description Get indicator legend
 * @param {integer} LangId
 * @param {integer} IndicatorId
 * @returns {json}
 */
function get_indicator_legend() {
/*
CREATE OR REPLACE FUNCTION data.get_indicator_legend("LangId" integer, "IndicatorId" integer)
 RETURNS json
 LANGUAGE plpgsql
AS $function$
DECLARE v_numerical BOOL;
BEGIN

	SELECT numerical INTO v_numerical FROM data.indicator WHERE id = "IndicatorId";
	IF (v_numerical) THEN
		RETURN (
			SELECT json_agg(t.*) FROM (
				SELECT '#ffffff' color_code, u.name text, -9999999 value_from
				FROM data.indicator v
				INNER JOIN data.unit u ON u.id = v.unit_id
				WHERE v.id = "IndicatorId"
				UNION
				SELECT 
				  v.color_code,
					CASE 
						WHEN value_from = -999999 THEN '&lt; ' || value_to
						WHEN value_to = 999999 THEN '> ' || value_from
						ELSE value_from || ' - ' || value_to
					END text, value_from
				FROM data.vw_indicator_color v 
				WHERE v.indicator_id = "IndicatorId" 
				ORDER BY value_from
			) t
		);
	ELSE
		RETURN (
			SELECT json_agg(t.*) FROM (
				SELECT 
				  c.code color_code, d.name text
				FROM data.attribute_description d 
				LEFT JOIN general.color c ON c.id = d.color_id
				WHERE d.indicator_id = "IndicatorId" 
				ORDER BY d.name
			) t
		);
	END IF;
END 
$function$

*/
 }
/**
 * @function get_context_tenant_id
 * @memberof auth
 * @description Get context tenant id
 * @returns {integer}
 */
function get_context_tenant_id() {
/*
CREATE OR REPLACE FUNCTION auth.get_context_tenant_id()
 RETURNS integer
 LANGUAGE plpgsql
AS $function$ 
BEGIN

	RETURN (
		SELECT tenant_id 
		FROM meta.app
		WHERE id = current_setting('context.app_id')::INTEGER
	);

END $function$

*/
 }
/**
 * @function i18n_itrig_proc
 * @memberof meta
 * @description I18n itrig proc
 * @returns {trigger}
 */
function i18n_itrig_proc() {
/*
CREATE OR REPLACE FUNCTION meta.i18n_itrig_proc()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN

	INSERT INTO meta.i18n_lang (i18n_id, lang_id, value)
	SELECT NEW.id, l.id, NEW.key
	FROM meta.lang l
	LEFT JOIN meta.i18n_lang i ON i.lang_id = l.id AND i.i18n_id = NEW.id
	WHERE i.id IS NULL;

	RETURN NEW;
	
END$function$

*/
 }
/**
 * @function data_measurement_d
 * @memberof zzglc
 * @description Data measurement d
 * @param {integer} Key
 * @returns {void}
 */
function data_measurement_d() {
/*
CREATE OR REPLACE FUNCTION zzglc.data_measurement_d("Key" integer)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

    DELETE FROM data.measurement
    WHERE id = "Key";

END $function$

*/
 }
/**
 * @function general_sub_region_l
 * @memberof zzgll
 * @description General sub region l
 * @param {character_varying} SearchValue
 * @param {smallint} Key
 * @returns {Object}
 * @property {smallint} id
 * @property {character_varying} name
 */
function general_sub_region_l() {
/*
CREATE OR REPLACE FUNCTION zzgll.general_sub_region_l("SearchValue" character varying, "Key" smallint DEFAULT NULL::smallint)
 RETURNS TABLE(id smallint, name character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

        IF "Key" IS NOT NULL THEN
            RETURN QUERY
            SELECT t.id, t.name
            FROM general.sub_region t
            WHERE t.id = "Key"::smallint;
        ELSE
            RETURN QUERY
           SELECT t.id, t.name
            FROM general.sub_region t
            WHERE t.name LIKE "SearchValue"
            ORDER BY t.name
           LIMIT 1000;
       END IF;
END $function$

*/
 }
/**
 * @function get_help
 * @memberof meta
 * @description Get help
 * @param {character_varying} Name
 * @param {integer} LangId
 * @returns {json}
 */
function get_help() {
/*
CREATE OR REPLACE FUNCTION meta.get_help("Name" character varying, "LangId" integer)
 RETURNS json
 LANGUAGE plpgsql
AS $function$
	BEGIN

	RETURN (
		SELECT json_build_object('help', COALESCE(l.value, e.value) )
		FROM meta.help h 
		LEFT JOIN meta.help_lang l ON l.lang_id = "LangId" AND l.help_id = h.id
		LEFT JOIN meta.help_lang e ON e.lang_id = 1 AND e.help_id = h.id
		WHERE h.name = "Name"
	);
END$function$

*/
 }
/**
 * @function data_attribute_description_r
 * @memberof zzglc
 * @description Data attribute description r
 * @returns {Object}
 * @property {integer} id
 * @property {integer} indicator_id
 * @property {integer} description_id
 * @property {character_varying} name
 * @property {integer} color_id
 * @property {character_varying} code
 * @property {character_varying} indicator_id_val
 * @property {character_varying} color_id_val
 */
function data_attribute_description_r() {
/*
CREATE OR REPLACE FUNCTION zzglc.data_attribute_description_r()
 RETURNS TABLE(id integer, indicator_id integer, description_id integer, name character varying, color_id integer, code character varying, indicator_id_val character varying, color_id_val character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

    RETURN QUERY
    SELECT
    t.id, t.indicator_id, t.description_id, t.name, t.color_id, t.code
    , indicator_id_t.name::VARCHAR AS indicator_id_val, color_id_t.name::VARCHAR AS color_id_val
    FROM data.attribute_description t

    LEFT JOIN data.indicator indicator_id_t ON indicator_id_t.id = t.indicator_id
    LEFT JOIN general.country color_id_t ON color_id_t.id = t.color_id
;
END $function$

*/
 }
/**
 * @function meta_trace_d
 * @memberof zzglc
 * @description Meta trace d
 * @param {integer} Key
 * @returns {void}
 */
function meta_trace_d() {
/*
CREATE OR REPLACE FUNCTION zzglc.meta_trace_d("Key" integer)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

    DELETE FROM meta.trace
    WHERE id = "Key";

END $function$

*/
 }
/**
 * @function raise_error
 * @memberof meta
 * @description Raise error
 * @param {integer} Code
 * @param {character_varying} Explanation
 * @returns {void}
 */
function raise_error() {
/*
CREATE OR REPLACE FUNCTION meta.raise_error("Code" integer, "Explanation" character varying DEFAULT ''::character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE 
	v_lang_id INTEGER;
	msg VARCHAR;
BEGIN

    v_lang_id := COALESCE (auth.get_context_lang_id (), 1);

    SELECT e.message into msg
    FROM meta.error AS e
    WHERE e.lang_id = v_lang_id
          AND e.code = "Code";
					
		IF msg IS NULL THEN
		    SELECT e.message into msg
				FROM meta.error AS e
				WHERE e.lang_id = 1
        AND e.code = "Code";
		END IF;			

    msg := COALESCE (msg, 'unknown error') || ' ' || "Explanation";
		RAISE EXCEPTION '%', msg;
END $function$

*/
 }
/**
 * @function data_date_style_r
 * @memberof zzglc
 * @description Data date style r
 * @returns {Object}
 * @property {integer} id
 * @property {character_varying} name
 */
function data_date_style_r() {
/*
CREATE OR REPLACE FUNCTION zzglc.data_date_style_r()
 RETURNS TABLE(id integer, name character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

    RETURN QUERY
    SELECT
    t.id, t.name
    FROM data.date_style t
;
END $function$

*/
 }
/**
 * @function set_color_map
 * @memberof data
 * @description Set color map
 * @param {integer} Id
 * @param {text} ColorMap
 * @returns {void}
 */
function set_color_map() {
/*
CREATE OR REPLACE FUNCTION data.set_color_map("Id" integer, "ColorMap" text)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
	BEGIN

		UPDATE data.asset SET color_map = "ColorMap" WHERE id = "Id";
	END;
$function$

*/
 }
/**
 * @function data_lc_detail_r
 * @memberof zzglc
 * @description Data lc detail r
 * @returns {Object}
 * @property {integer} id
 * @property {character_varying} name
 * @property {integer} color_id
 * @property {character} code
 * @property {character_varying} color_id_val
 * @property {character_varying} color_code
 */
function data_lc_detail_r() {
/*
CREATE OR REPLACE FUNCTION zzglc.data_lc_detail_r()
 RETURNS TABLE(id integer, name character varying, color_id integer, code character, color_id_val character varying, color_code character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

    RETURN QUERY
    SELECT
    t.id, t.name, t.color_id, t.code
    , color_id_t.name::VARCHAR AS color_id_val
		, color_id_t.code
    FROM data.lc_detail t

    LEFT JOIN general.color color_id_t ON color_id_t.id = t.color_id
    
    ORDER BY t.name
;
END $function$

*/
 }
/**
 * @function delete_all_messages
 * @memberof general
 * @description Delete all messages
 * @param {integer} PersonId
 * @returns {void}
 */
function delete_all_messages() {
/*
CREATE OR REPLACE FUNCTION general.delete_all_messages("PersonId" integer)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

	DELETE FROM general.message WHERE person_id = "PersonId";
	RETURN;
END$function$

*/
 }
/**
 * @function add_triggers
 * @memberof meta
 * @description Add triggers
 * @param {character_varying} SchemaName
 * @param {character_varying} TableName
 * @returns {void}
 */
function add_triggers() {
/*
CREATE OR REPLACE FUNCTION meta.add_triggers("SchemaName" character varying, "TableName" character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
	DECLARE
	  sql VARCHAR;
BEGIN

	IF EXISTS (SELECT 1
		FROM   pg_attribute
		WHERE  attrelid = ("SchemaName" || '.' || "TableName")::regclass  -- table name optionally schema-qualified
		AND    attnum > 0
		AND    NOT attisdropped
		AND    attname = 'time_modified') THEN
	
		IF EXISTS (SELECT 1
			FROM   pg_attribute
			WHERE  attrelid = ("SchemaName" || '.' || "TableName")::regclass  -- table name optionally schema-qualified
			AND    attnum > 0
			AND    NOT attisdropped
			AND    attname = 'user_modified') THEN
			PERFORM meta.add_update_user_and_time_modified_trigger("SchemaName", "TableName");
		ELSE
      PERFORM meta.add_update_time_modified_trigger("SchemaName", "TableName");		
	  END IF;	
	END IF;		
END $function$

*/
 }
/**
 * @function data_asset_c
 * @memberof zzglc
 * @description Data asset c
 * @param {character_varying} Json
 * @returns {void}
 */
function data_asset_c() {
/*
CREATE OR REPLACE FUNCTION zzglc.data_asset_c("Json" character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

    INSERT INTO data.asset (
        orig_id,
        ignore,
        asset_catalog_id,
        title,
        description,
        asset_theme_id,
        keywords_list,
        asset_version_id,
        doi,
        unit_id,
        scale_factor,
        person_id,
        providers_list,
        license_id,
        constellation_list,
        platform,
        instruments_list,
        gsd,
        start_date,
        end_date,
        date_step,
        date_offset,
        date_unit_id,
        date_style_id,
        ignore_29feb,
        depth_list,
        main_sld_url,
        sld_1_url,
        main_qml_url,
        main_url,
        color_map,
        no_data,
        decimals,
        indicator_id
    )
    SELECT
        U.orig_id,
        U.ignore,
        U.asset_catalog_id,
        U.title,
        U.description,
        U.asset_theme_id,
        U.keywords_list,
        U.asset_version_id,
        U.doi,
        U.unit_id,
        U.scale_factor,
        U.person_id,
        U.providers_list,
        U.license_id,
        U.constellation_list,
        U.platform,
        U.instruments_list,
        U.gsd,
        U.start_date,
        U.end_date,
        U.date_step,
        U.date_offset,
        U.date_unit_id,
        U.date_style_id,
        U.ignore_29feb,
        U.depth_list,
        U.main_sld_url,
        U.sld_1_url,
        U.main_qml_url,
        U.main_url,
        U.color_map,
        U.no_data,
        U.decimals,
        U.indicator_id
    FROM
        json_to_record("Json"::json) U (
orig_id character varying,
            ignore boolean,
            asset_catalog_id integer,
            title character varying,
            description character varying,
            asset_theme_id integer,
            keywords_list character varying,
            asset_version_id integer,
            doi character varying,
            unit_id integer,
            scale_factor character varying,
            person_id integer,
            providers_list character varying,
            license_id integer,
            constellation_list character varying,
            platform character varying,
            instruments_list character varying,
            gsd character varying,
            start_date date,
            end_date date,
            date_step integer,
            date_offset character varying,
            date_unit_id integer,
            date_style_id integer,
            ignore_29feb boolean,
            depth_list character varying,
            main_sld_url character varying,
            sld_1_url character varying,
            main_qml_url character varying,
            main_url character varying,
            color_map character varying,
            no_data integer,
            decimals integer,
            indicator_id integer
        ) 
;
END $function$

*/
 }
/**
 * @function data_attribute_description_l
 * @memberof zzgll
 * @description Data attribute description l
 * @param {character_varying} SearchValue
 * @param {integer} Key
 * @param {integer} IndicatorId
 * @returns {Object}
 * @property {integer} id
 * @property {character_varying} name
 */
function data_attribute_description_l() {
/*
CREATE OR REPLACE FUNCTION zzgll.data_attribute_description_l("SearchValue" character varying, "Key" integer DEFAULT NULL::integer, "IndicatorId" integer DEFAULT NULL::integer)
 RETURNS TABLE(id integer, name character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

        IF "Key" IS NOT NULL THEN
            RETURN QUERY
            SELECT t.id, t.name
            FROM data.attribute_description t
            WHERE t.id = "Key"::integer;
        ELSE
            RETURN QUERY
           SELECT t.id, t.name
            FROM data.attribute_description t
            WHERE t.name LIKE "SearchValue" || '%' AND t.indicator_id = "IndicatorId"
            ORDER BY t.name
           LIMIT 1000;
       END IF;
END $function$

*/
 }
/**
 * @function auth_person_role_public_c
 * @memberof zzglc
 * @description Auth person role public c
 * @param {character_varying} Json
 * @returns {integer}
 */
function auth_person_role_public_c() {
/*
CREATE OR REPLACE FUNCTION zzglc.auth_person_role_public_c("Json" character varying)
 RETURNS integer
 LANGUAGE plpgsql
AS $function$
		DECLARE v_id integer;
    DECLARE json_data json;
    BEGIN

			  json_data := "Json";
        INSERT INTO auth.person_role_public (person_id, role_public_id) 
        VALUES ((json_data->>'person_id')::integer, (json_data->>'role_public_id')::integer)
        RETURNING id INTO v_id;
        RETURN v_id;
    END $function$

*/
 }
/**
 * @function get_point_history
 * @memberof data
 * @description Get point history
 * @param {integer} PointId
 * @param {integer} IndicatorId
 * @returns {Object}
 * @property {date} date
 * @property {character_varying} depth
 * @property {real} value
 */
function get_point_history() {
/*
CREATE OR REPLACE FUNCTION data.get_point_history("PointId" integer, "IndicatorId" integer)
 RETURNS TABLE(date date, depth character varying, value real)
 LANGUAGE plpgsql
AS $function$

	BEGIN

	-- Routine body goes here...
	RETURN QUERY (
			SELECT m.date date, d.name depth, m.value 
			FROM data.measurement m
			LEFT JOIN data.depth d ON d.id = m.depth_id
			WHERE m.indicator_id = "IndicatorId" AND m.point_id = "PointId"
			ORDER BY 1, 2
	);
END
$function$

*/
 }
/**
 * @function create_user
 * @memberof auth
 * @description Create user
 * @param {integer} PersonId
 * @returns {void}
 */
function create_user() {
/*
CREATE OR REPLACE FUNCTION auth.create_user("PersonId" integer)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
	DECLARE v_user_id UUID;
BEGIN

	
	INSERT INTO auth.user (user_name, first_name, last_name, email)
	SELECT email, first_name, last_name, email
	FROM general.person 
	WHERE id = "PersonId"
	RETURNING id INTO v_user_id;
	
	UPDATE general.person SET user_id = v_user_id 
	WHERE id = "PersonId";
	
END $function$

*/
 }
/**
 * @function meta_help_d
 * @memberof zzglc
 * @description Meta help d
 * @param {integer} Key
 * @returns {void}
 */
function meta_help_d() {
/*
CREATE OR REPLACE FUNCTION zzglc.meta_help_d("Key" integer)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

    DELETE FROM meta.help
    WHERE id = "Key";

END $function$

*/
 }
/**
 * @function general_nuts_c
 * @memberof zzglc
 * @description General nuts c
 * @param {character_varying} Json
 * @returns {void}
 */
function general_nuts_c() {
/*
CREATE OR REPLACE FUNCTION zzglc.general_nuts_c("Json" character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

    INSERT INTO general.nuts (
        nuts_id,
        levl_code,
        cntr_code,
        name_latn,
        nuts_name,
        mount_type,
        urbn_type,
        coast_type,
        fid,
        geom
    )
    SELECT
        U.nuts_id,
        U.levl_code,
        U.cntr_code,
        U.name_latn,
        U.nuts_name,
        U.mount_type,
        U.urbn_type,
        U.coast_type,
        U.fid,
        U.geom
    FROM
        json_to_record("Json"::json) U (
nuts_id character varying,
            levl_code integer,
            cntr_code character(2),
            name_latn character varying(255),
            nuts_name character varying(255),
            mount_type integer,
            urbn_type integer,
            coast_type integer,
            fid character varying,
            geom geometry
        ) 
;
END $function$

*/
 }
/**
 * @function import_croatia246
 * @memberof data
 * @description Import croatia246
 * @param {text} jsonCV
 * @param {text} jsonData
 * @returns {void}
 */
function import_croatia246() {
/*
CREATE OR REPLACE FUNCTION data.import_croatia246("jsonCV" text, "jsonData" text)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

DROP TABLE IF EXISTS t;
CREATE TEMP TABLE t AS
SELECT * FROM json_to_recordset("jsonData"::json) AS J(
"y" varchar, "x" varchar, "pH" varchar, "EC (dS/m) " varchar, "EC (mS/m)" varchar, "Clay" varchar, "CEC" varchar, "Point_key" varchar);

WITH x AS (SELECT DISTINCT t."y", t."x", t."Point_key" FROM  t)
INSERT INTO data.point(y, x, point_key, data_source_id)
SELECT meta.clean_value(x."y", 'double precision')::double precision, meta.clean_value(x."x", 'double precision')::double precision, meta.clean_value(x."Point_key", 'varchar')::varchar, 4 FROM x
LEFT JOIN data.point point ON point.point_key= x."Point_key"
WHERE point.id IS NULL;

INSERT INTO data.measurement(point_id, indicator_id, value, date, data_source_id)
SELECT x.id, i.id, meta.clean_value(t."pH", 'double precision')::double precision, '2011-12-31'::date, 4 FROM t
LEFT JOIN data.point x ON x.point_key = t."Point_key"
 left join data.indicator i on i.name_match = 'pHe' left join data.measurement y on y.point_id = x.id and y.indicator_id = i.id and y.date = '2011-12-31'::date
WHERE y.id IS NULL AND meta.clean_value(t."pH", 'double precision')::double precision IS NOT NULL ;

INSERT INTO data.measurement(point_id, indicator_id, value, date, data_source_id)
SELECT x.id, i.id, meta.clean_value(t."EC (mS/m)", 'double precision')::double precision, '2011-12-31'::date, 4 FROM t
LEFT JOIN data.point x ON x.point_key = t."Point_key"
 left join data.indicator i on i.name_match = 'ECe' left join data.measurement y on y.point_id = x.id and y.indicator_id = i.id and y.date = '2011-12-31'::date
WHERE y.id IS NULL AND meta.clean_value(t."EC (mS/m)", 'double precision')::double precision IS NOT NULL ;

INSERT INTO data.measurement(point_id, indicator_id, value, date, data_source_id)
SELECT x.id, i.id, meta.clean_value(t."Clay", 'double precision')::double precision, '2011-12-31'::date, 4 FROM t
LEFT JOIN data.point x ON x.point_key = t."Point_key"
 left join data.indicator i on i.name_match = 'Clay' left join data.measurement y on y.point_id = x.id and y.indicator_id = i.id and y.date = '2011-12-31'::date
WHERE y.id IS NULL AND meta.clean_value(t."Clay", 'double precision')::double precision IS NOT NULL ;

INSERT INTO data.measurement(point_id, indicator_id, value, date, data_source_id)
SELECT x.id, i.id, meta.clean_value(t."CEC", 'double precision')::double precision, '2011-12-31'::date, 4 FROM t
LEFT JOIN data.point x ON x.point_key = t."Point_key"
 left join data.indicator i on i.name_match = 'CEC' left join data.measurement y on y.point_id = x.id and y.indicator_id = i.id and y.date = '2011-12-31'::date
WHERE y.id IS NULL AND meta.clean_value(t."CEC", 'double precision')::double precision IS NOT NULL ;

END $function$

*/
 }
/**
 * @function translate
 * @memberof meta
 * @description Translate
 * @param {character_varying} Locale
 * @param {character_varying} TableName
 * @param {character_varying} KeyName
 * @param {character_varying} KeyValue
 * @param {character_varying} ParentKeyName
 * @param {character_varying} ParentKeyValue
 * @param {character_varying} FieldName
 * @param {character_varying} FieldValue
 * @returns {void}
 */
function translate() {
/*
CREATE OR REPLACE FUNCTION meta.translate("Locale" character varying, "TableName" character varying, "KeyName" character varying, "KeyValue" character varying, "ParentKeyName" character varying, "ParentKeyValue" character varying, "FieldName" character varying, "FieldValue" character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE v_sql varchar;
DECLARE v_row_count int;
DECLARE v_lang_id int;
BEGIN

  SELECT l.id INTO v_lang_id FROM meta.lang l WHERE l.short_tag = "Locale";
	
	RAISE NOTICE '%', v_lang_id;
  
  v_sql := format ('UPDATE %s SET %s = ''%s'' WHERE lang_id = %s and %s = %s', "TableName", "FieldName", "FieldValue", v_lang_id, "KeyName", "KeyValue"); 
  EXECUTE v_sql;
	RAISE NOTICE '%', v_sql;
  GET DIAGNOSTICS v_row_count = ROW_COUNT;			 
  IF v_row_count = 0 THEN
  	v_sql := format ('INSERT INTO %s (lang_id, %s, %s) VALUES (%s, %s, ''%s'')', "TableName", "ParentKeyName", "FieldName", v_lang_id, "ParentKeyValue", "FieldValue");  
  	EXECUTE v_sql;  
		RAISE NOTICE '%', v_sql;
  END IF;
END
$function$

*/
 }
/**
 * @function meta_table_ref_col_c
 * @memberof zzglc
 * @description Meta table ref col c
 * @param {character_varying} Json
 * @returns {void}
 */
function meta_table_ref_col_c() {
/*
CREATE OR REPLACE FUNCTION zzglc.meta_table_ref_col_c("Json" character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

    INSERT INTO meta.table_ref_col (
        schema_name,
        table_name,
        ref_col
    )
    SELECT
        U.schema_name,
        U.table_name,
        U.ref_col
    FROM
        json_to_record("Json"::json) U (
            schema_name character varying,
            table_name character varying,
            ref_col character varying
        ) 
;
END $function$

*/
 }
/**
 * @function meta_i18n_u
 * @memberof zzglc
 * @description Meta i18n u
 * @param {character_varying} Json
 * @returns {void}
 */
function meta_i18n_u() {
/*
CREATE OR REPLACE FUNCTION zzglc.meta_i18n_u("Json" character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE v_row_count INTEGER;
BEGIN

    UPDATE meta.i18n t
    SET key = U.key 
    FROM json_to_record("Json"::json) AS U (
        id integer,
            key character varying(255)
    ) 
    WHERE U.id = t.id
;

END $function$

*/
 }
/**
 * @function general_sub_region_r
 * @memberof zzglc
 * @description General sub region r
 * @returns {Object}
 * @property {smallint} id
 * @property {character_varying} name
 */
function general_sub_region_r() {
/*
CREATE OR REPLACE FUNCTION zzglc.general_sub_region_r()
 RETURNS TABLE(id smallint, name character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

    RETURN QUERY
    SELECT
    t.id, t.name
    FROM general.sub_region t
;
END $function$

*/
 }
/**
 * @function data_date_style_d
 * @memberof zzglc
 * @description Data date style d
 * @param {integer} Key
 * @returns {void}
 */
function data_date_style_d() {
/*
CREATE OR REPLACE FUNCTION zzglc.data_date_style_d("Key" integer)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

    DELETE FROM data.date_style
    WHERE id = "Key";

END $function$

*/
 }
/**
 * @function route_role_public_history
 * @memberof auth
 * @description Route role public history
 * @returns {trigger}
 */
function route_role_public_history() {
/*
CREATE OR REPLACE FUNCTION auth.route_role_public_history()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$ 
DECLARE v_person_id INT;
        v_user_id UUID; 
BEGIN

	v_person_id := auth.get_context_person_id();
    v_user_id := auth.get_context_user_id();

	IF TG_OP = 'DELETE' THEN
		INSERT INTO zzHistory.auth_route_role_public (
            id,
            route_id,
            role_public_id,
            ModifiedUserId,
            ModifiedPersonId,
            ModifiedTime,
            ModifiedLogin,
            ModifiedAction
		)
		SELECT OLD.id,
               OLD.route_id,
               OLD.role_public_id,
               v_user_id,
               v_person_id,
               CURRENT_TIMESTAMP,
               CURRENT_USER,
               'D';
	ELSE
		INSERT INTO zzHistory.auth_route_role_public (
id,
            route_id,
            role_public_id,
            ModifiedUserId,
            ModifiedPersonId,
            ModifiedTime,
            ModifiedLogin,
            ModifiedAction
		)
		SELECT NEW.id,
               NEW.route_id,
               NEW.role_public_id,
               v_user_id,
               v_person_id,
               CURRENT_TIMESTAMP,
               CURRENT_USER,
               CASE WHEN TG_OP = 'INSERT' THEN 'I' ELSE 'U' END;
	END IF;
    RETURN NULL;
END $function$

*/
 }
/**
 * @function save_file
 * @memberof data
 * @description Save file
 * @param {integer} PersonId
 * @param {integer} CustomGeometryId
 * @param {character_varying} FileName
 * @param {character_varying} Extension
 * @param {character_varying} MimeType
 * @param {integer} Compass
 * @param {double_precision} Lat
 * @param {double_precision} Lon
 * @returns {integer}
 */
function save_file() {
/*
CREATE OR REPLACE FUNCTION data.save_file("PersonId" integer, "CustomGeometryId" integer, "FileName" character varying, "Extension" character varying, "MimeType" character varying, "Compass" integer, "Lat" double precision, "Lon" double precision)
 RETURNS integer
 LANGUAGE plpgsql
AS $function$ 
	DECLARE v_id INT;
	DECLARE v_geom GEOMETRY;
BEGIN

	
	IF "Compass" IS NULL THEN
		"Compass" := 0;
	END IF;
	
	IF "Lat" IS NULL THEN
		SELECT st_centroid(geometry) INTO v_geom FROM data.custom_geometry WHERE id = "CustomGeometryId";
	ELSE
		v_geom = st_setsrid(st_makepoint("Lon", "Lat"), 4326);
	END IF;
	
	INSERT INTO data.custom_geometry_file (custom_geometry_id, name, extension, mime_type, compass, geometry)
	VALUES ("CustomGeometryId", "FileName", "Extension", "MimeType", "Compass", v_geom)				
	RETURNING id INTO v_id;
	
	RETURN v_id;
	
END$function$

*/
 }
/**
 * @function meta_route_l
 * @memberof zzgll
 * @description Meta route l
 * @param {character_varying} SearchValue
 * @param {integer} Key
 * @returns {Object}
 * @property {integer} id
 * @property {character_varying} name
 */
function meta_route_l() {
/*
CREATE OR REPLACE FUNCTION zzgll.meta_route_l("SearchValue" character varying, "Key" integer DEFAULT NULL::integer)
 RETURNS TABLE(id integer, name character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

        IF "Key" IS NOT NULL THEN
            RETURN QUERY
            SELECT t.id, t.name
            FROM meta.route t
            WHERE t.id = "Key"::integer;
        ELSE
            RETURN QUERY
           SELECT t.id, t.name
            FROM meta.route t
            WHERE t.name LIKE "SearchValue"
            ORDER BY t.name
           LIMIT 1000;
       END IF;
END $function$

*/
 }
/**
 * @function data_indicator_d
 * @memberof zzglc
 * @description Data indicator d
 * @param {integer} Key
 * @returns {void}
 */
function data_indicator_d() {
/*
CREATE OR REPLACE FUNCTION zzglc.data_indicator_d("Key" integer)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

    DELETE FROM data.indicator
    WHERE id = "Key";

END $function$

*/
 }
/**
 * @function data_depth_r
 * @memberof zzglc
 * @description Data depth r
 * @returns {Object}
 * @property {integer} id
 * @property {character_varying} name
 * @property {integer} color_id
 * @property {character_varying} color_id_val
 * @property {character_varying} color_code
 */
function data_depth_r() {
/*
CREATE OR REPLACE FUNCTION zzglc.data_depth_r()
 RETURNS TABLE(id integer, name character varying, color_id integer, color_id_val character varying, color_code character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

    RETURN QUERY
    SELECT
    t.id, t.name, t.color_id
    , color_id_t.name::VARCHAR AS color_id_val
	, color_id_t.code
    FROM data.depth t

    LEFT JOIN general.color color_id_t ON color_id_t.id = t.color_id
    
    ORDER BY t.name
;
END 
$function$

*/
 }
/**
 * @function general_ai_model_r
 * @memberof zzglc
 * @description General ai model r
 * @returns {Object}
 * @property {integer} id
 * @property {character_varying} name
 */
function general_ai_model_r() {
/*
CREATE OR REPLACE FUNCTION zzglc.general_ai_model_r()
 RETURNS TABLE(id integer, name character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

    RETURN QUERY
    SELECT
    t.id, t.name
    FROM general.ai_model t
;
END $function$

*/
 }
/**
 * @function set_help
 * @memberof meta
 * @description Set help
 * @param {character_varying} Name
 * @param {integer} LangId
 * @param {text} Help
 * @returns {void}
 */
function set_help() {
/*
CREATE OR REPLACE FUNCTION meta.set_help("Name" character varying, "LangId" integer, "Help" text)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
	DECLARE v_help_id INT;
	DECLARE v_row_count INT;
	BEGIN

		SELECT id INTO v_help_id FROM meta.help WHERE name = "Name";
		IF v_help_id IS NULL THEN
			INSERT INTO meta.help (name) VALUES ("Name")
			RETURNING id INTO v_help_id;
		END IF;
		UPDATE meta.help_lang SET value = "Help" WHERE help_id = v_help_id AND lang_id = "LangId";
		GET DIAGNOSTICS v_row_count = ROW_COUNT;
		IF v_row_count = 0 THEN
			INSERT INTO meta.help_lang (help_id, lang_id, value) VALUES (v_help_id, "LangId", "Help");
		END IF;
		
END$function$

*/
 }
/**
 * @function data_oedce_d
 * @memberof zzglc
 * @description Data oedce d
 * @param {integer} Key
 * @returns {void}
 */
function data_oedce_d() {
/*
CREATE OR REPLACE FUNCTION zzglc.data_oedce_d("Key" integer)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

    DELETE FROM data.oedce
    WHERE fid = "Key";

END $function$

*/
 }
/**
 * @function get_messages
 * @memberof general
 * @description Get messages
 * @param {integer} PersonId
 * @returns {Object}
 * @property {integer} id
 * @property {integer} parent_id
 * @property {text} message
 * @property {timestamp_without_time_zone} time_modified
 */
function get_messages() {
/*
CREATE OR REPLACE FUNCTION general.get_messages("PersonId" integer)
 RETURNS TABLE(id integer, parent_id integer, message text, time_modified timestamp without time zone)
 LANGUAGE plpgsql
AS $function$
BEGIN

	RETURN QUERY (
		SELECT m.id, m.parent_id, m.message, m.time_modified 
		FROM general.message m
		WHERE m.person_id = "PersonId" 
		ORDER BY time_modified
	);

	RETURN;
END$function$

*/
 }

/**
 * @function update_parent_distance
 * @memberof general
 * @description Update parent distance
 * @returns {void}
 */
function update_parent_distance() {
/*
CREATE OR REPLACE PROCEDURE general.update_parent_distance()
 LANGUAGE plpgsql
AS $procedure$
BEGIN

-- obsolete, required if all children are listed ih hierarchy
UPDATE general.boundary_hierarchy h SET parent_distance = t.d FROM
(
	SELECT h.id hid, p.id, p.name, c.id, c.name, row_number() over (partition by c.id order by p.admin_level desc) d
	FROM general.boundary_hierarchy h
	INNER JOIN general.boundary p ON p.osm_id = h.parent_id
	INNER JOIN general.boundary c ON c.osm_id = h.child_id
) t where t.hid = h.id;
END$procedure$

*/
 }
/**
 * @function auth_log_d
 * @memberof zzglc
 * @description Auth log d
 * @param {integer} Key
 * @returns {void}
 */
function auth_log_d() {
/*
CREATE OR REPLACE FUNCTION zzglc.auth_log_d("Key" integer)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

    DELETE FROM auth.log
    WHERE id = "Key";

END $function$

*/
 }
/**
 * @function general_country_u
 * @memberof zzglc
 * @description General country u
 * @param {character_varying} Json
 * @returns {void}
 */
function general_country_u() {
/*
CREATE OR REPLACE FUNCTION zzglc.general_country_u("Json" character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE v_row_count INTEGER;
BEGIN

    UPDATE general.country t
    SET name = U.name,
        code = U.code,
        region_id = U.region_id,
        sub_region_id = U.sub_region_id,
        osm_id = U.osm_id 
    FROM json_to_record("Json"::json) AS U (
        id smallint,
            name character varying(255),
            code character(2),
            region_id integer,
            sub_region_id integer,
            osm_id integer
    ) 
    WHERE U.id = t.id
;

END $function$

*/
 }
/**
 * @function auth_log_r
 * @memberof zzglc
 * @description Auth log r
 * @returns {Object}
 * @property {integer} id
 * @property {integer} person_id
 * @property {character_varying} ip
 * @property {timestamp_without_time_zone} time_modified
 * @property {character_varying} person_id_val
 */
function auth_log_r() {
/*
CREATE OR REPLACE FUNCTION zzglc.auth_log_r()
 RETURNS TABLE(id integer, person_id integer, ip character varying, time_modified timestamp without time zone, person_id_val character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

    RETURN QUERY
    SELECT
    t.id, t.person_id, t.ip, t.time_modified
    , person_id_t.name::VARCHAR AS person_id_val
    FROM auth.log t

    LEFT JOIN general.person person_id_t ON person_id_t.id = t.person_id
    
    ORDER BY t.id desc
;
END $function$

*/
 }
/**
 * @function data_lc_main_l
 * @memberof zzgll
 * @description Data lc main l
 * @param {character_varying} SearchValue
 * @param {integer} Key
 * @returns {Object}
 * @property {integer} id
 * @property {character_varying} name
 */
function data_lc_main_l() {
/*
CREATE OR REPLACE FUNCTION zzgll.data_lc_main_l("SearchValue" character varying, "Key" integer DEFAULT NULL::integer)
 RETURNS TABLE(id integer, name character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

        IF "Key" IS NOT NULL THEN
            RETURN QUERY
            SELECT t.id, t.name
            FROM data.lc_main t
            WHERE t.id = "Key"::integer;
        ELSE
            RETURN QUERY
           SELECT t.id, t.name
            FROM data.lc_main t
            WHERE t.name LIKE "SearchValue"
            ORDER BY t.name
           LIMIT 1000;
       END IF;
END $function$

*/
 }
/**
 * @function meta_import_master_r
 * @memberof zzglc
 * @description Meta import master r
 * @returns {Object}
 * @property {integer} id
 * @property {character_varying} schema_name
 * @property {character_varying} table_name
 * @property {character_varying} file_name
 * @property {character_varying} sheet
 * @property {character_varying} name
 * @property {character_varying} import_name
 * @property {character_varying} data_date
 * @property {character_varying} constant_value
 */
function meta_import_master_r() {
/*
CREATE OR REPLACE FUNCTION zzglc.meta_import_master_r()
 RETURNS TABLE(id integer, schema_name character varying, table_name character varying, file_name character varying, sheet character varying, name character varying, import_name character varying, data_date character varying, constant_value character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

    RETURN QUERY
    SELECT
    t.id, t.schema_name, t.table_name, t.file_name, t.sheet, t.name, t.import_name, t.data_date, t.constant_value
    FROM meta.import_master t
    
    ORDER BY t.import_name
;
END $function$

*/
 }
/**
 * @function data_indicator_r
 * @memberof zzglc
 * @description Data indicator r
 * @returns {Object}
 * @property {integer} id
 * @property {character_varying} name
 * @property {integer} unit_id
 * @property {character_varying} lod
 * @property {character_varying} name_match
 * @property {integer} decimals_for_stats
 * @property {integer} decimals_for_display
 * @property {boolean} numerical
 * @property {real} value_from
 * @property {real} value_to
 * @property {character_varying} unit_id_val
 */
function data_indicator_r() {
/*
CREATE OR REPLACE FUNCTION zzglc.data_indicator_r()
 RETURNS TABLE(id integer, name character varying, unit_id integer, lod character varying, name_match character varying, decimals_for_stats integer, decimals_for_display integer, numerical boolean, value_from real, value_to real, unit_id_val character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

    RETURN QUERY
    SELECT
    t.id, t.name, t.unit_id, t.lod, t.name_match, t.decimals_for_stats, t.decimals_for_display, t.numerical, t.value_from, t.value_to
    , unit_id_t.name::VARCHAR AS unit_id_val
    FROM data.indicator t

    LEFT JOIN data.unit unit_id_t ON unit_id_t.id = t.unit_id
    
    ORDER BY t.name
;
END $function$

*/
 }
/**
 * @function add_i18n_keys
 * @memberof meta
 * @description Add i18n keys
 * @param {character_varying} Keys
 * @returns {void}
 */
function add_i18n_keys() {
/*
CREATE OR REPLACE FUNCTION meta.add_i18n_keys("Keys" character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

	INSERT INTO meta.i18n (key)
	SELECT REPLACE(key::VARCHAR, '"', '') FROM json_array_elements("Keys"::json) key
	ON CONFLICT(key) DO NOTHING;
END $function$

*/
 }
/**
 * @function add_update_user_and_time_modified_trigger
 * @memberof meta
 * @description Add update user and time modified trigger
 * @param {character_varying} SchemaName
 * @param {character_varying} TableName
 * @returns {void}
 */
function add_update_user_and_time_modified_trigger() {
/*
CREATE OR REPLACE FUNCTION meta.add_update_user_and_time_modified_trigger("SchemaName" character varying, "TableName" character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

	EXECUTE '
	CREATE OR REPLACE TRIGGER ' || "TableName" || '_ttrig
	BEFORE INSERT OR UPDATE
	ON ' || "SchemaName" || '.' || "TableName" || '
	FOR EACH ROW
		EXECUTE PROCEDURE meta.update_user_and_time_modified()
	';
END $function$

*/
 }
/**
 * @function data_geometry_type_d
 * @memberof zzglc
 * @description Data geometry type d
 * @param {integer} Key
 * @returns {void}
 */
function data_geometry_type_d() {
/*
CREATE OR REPLACE FUNCTION zzglc.data_geometry_type_d("Key" integer)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

    DELETE FROM data.geometry_type
    WHERE id = "Key";

END $function$

*/
 }
/**
 * @function data_shape_l
 * @memberof zzgll
 * @description Data shape l
 * @param {character_varying} SearchValue
 * @param {integer} Key
 * @returns {Object}
 * @property {integer} id
 * @property {integer} data_source_id
 */
function data_shape_l() {
/*
CREATE OR REPLACE FUNCTION zzgll.data_shape_l("SearchValue" character varying, "Key" integer DEFAULT NULL::integer)
 RETURNS TABLE(id integer, data_source_id integer)
 LANGUAGE plpgsql
AS $function$
BEGIN

        IF "Key" IS NOT NULL THEN
            RETURN QUERY
            SELECT t.id, t.data_source_id
            FROM data.shape t
            WHERE t.id = "Key"::integer;
        ELSE
            RETURN QUERY
           SELECT t.id, t.data_source_id
            FROM data.shape t
            WHERE t.data_source_id LIKE "SearchValue"
            ORDER BY t.data_source_id
           LIMIT 1000;
       END IF;
END $function$

*/
 }
/**
 * @function auth_user_role_d
 * @memberof zzglc
 * @description Auth user role d
 * @param {uuid} Key
 * @returns {void}
 */
function auth_user_role_d() {
/*
CREATE OR REPLACE FUNCTION zzglc.auth_user_role_d("Key" uuid)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

    DELETE FROM auth.user_role
    WHERE id = "Key";

END $function$

*/
 }
/**
 * @function data_date_style_l
 * @memberof zzgll
 * @description Data date style l
 * @param {character_varying} SearchValue
 * @param {integer} Key
 * @returns {Object}
 * @property {integer} id
 * @property {character_varying} name
 */
function data_date_style_l() {
/*
CREATE OR REPLACE FUNCTION zzgll.data_date_style_l("SearchValue" character varying, "Key" integer DEFAULT NULL::integer)
 RETURNS TABLE(id integer, name character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

        IF "Key" IS NOT NULL THEN
            RETURN QUERY
            SELECT t.id, t.name
            FROM data.date_style t
            WHERE t.id = "Key"::integer;
        ELSE
            RETURN QUERY
           SELECT t.id, t.name
            FROM data.date_style t
            WHERE t.name LIKE "SearchValue"
            ORDER BY t.name
           LIMIT 1000;
       END IF;
END $function$

*/
 }
/**
 * @function data_date_unit_r
 * @memberof zzglc
 * @description Data date unit r
 * @returns {Object}
 * @property {integer} id
 * @property {character_varying} name
 * @property {character_varying} format
 */
function data_date_unit_r() {
/*
CREATE OR REPLACE FUNCTION zzglc.data_date_unit_r()
 RETURNS TABLE(id integer, name character varying, format character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

    RETURN QUERY
    SELECT
    t.id, t.name, t.format
    FROM data.date_unit t
;
END $function$

*/
 }
/**
 * @function data_indicator_l
 * @memberof zzgll
 * @description Data indicator l
 * @param {character_varying} SearchValue
 * @param {integer} Key
 * @returns {Object}
 * @property {integer} id
 * @property {character_varying} name
 */
function data_indicator_l() {
/*
CREATE OR REPLACE FUNCTION zzgll.data_indicator_l("SearchValue" character varying, "Key" integer DEFAULT NULL::integer)
 RETURNS TABLE(id integer, name character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

        IF "Key" IS NOT NULL THEN
            RETURN QUERY
            SELECT t.id, t.name
            FROM data.indicator t
            WHERE t.id = "Key"::integer;
        ELSE
            RETURN QUERY
           SELECT t.id, t.name
            FROM data.indicator t
            WHERE LOWER(t.name) LIKE LOWER("SearchValue")
            ORDER BY t.name
           LIMIT 1000;
       END IF;
END $function$

*/
 }
/**
 * @function data_depth_u
 * @memberof zzglc
 * @description Data depth u
 * @param {character_varying} Json
 * @returns {void}
 */
function data_depth_u() {
/*
CREATE OR REPLACE FUNCTION zzglc.data_depth_u("Json" character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE v_row_count INTEGER;
BEGIN

    UPDATE data.depth t
    SET name = U.name,
        color_id = U.color_id 
    FROM json_to_record("Json"::json) AS U (
        id integer,
            name character varying,
            color_id integer
    ) 
    WHERE U.id = t.id
;

END $function$

*/
 }
/**
 * @function clean_value
 * @memberof meta
 * @description Clean value
 * @param {character_varying} v
 * @param {character_varying} t
 * @returns {character_varying}
 */
function clean_value() {
/*
CREATE OR REPLACE FUNCTION meta.clean_value(v character varying, t character varying)
 RETURNS character varying
 LANGUAGE plpgsql
AS $function$
BEGIN

	IF v = '' OR v = 'NA' THEN
		RETURN null;
	END IF;
	IF v = '&lt; LOD' OR v = '&lt;  LOD' THEN
		RETURN '-999999';
	END IF;
	IF v = '&lt;0.0' THEN
		RETURN '-888888';
	END IF;
	IF t = 'date' THEN
		IF POSITION('/' IN v) > 0 THEN
		  RETURN to_date(v,'MM/DD/YYYY')::VARCHAR;
		ELSE 
			RETURN to_date(v,'YYYY-MM-DD')::VARCHAR;
		END IF;
	END IF;
	RETURN v;
END $function$

*/
 }
/**
 * @function data_geometry_type_property_c
 * @memberof zzglc
 * @description Data geometry type property c
 * @param {character_varying} Json
 * @returns {void}
 */
function data_geometry_type_property_c() {
/*
CREATE OR REPLACE FUNCTION zzglc.data_geometry_type_property_c("Json" character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

    INSERT INTO data.geometry_type_property (
        geometry_type_id,
        order_no,
        property_id
    )
    SELECT
        U.geometry_type_id,
        U.order_no,
        U.property_id
    FROM
        json_to_record("Json"::json) U (
geometry_type_id integer,
            order_no integer,
            property_id integer
        ) 
;
END $function$

*/
 }
/**
 * @function data_license_u
 * @memberof zzglc
 * @description Data license u
 * @param {character_varying} Json
 * @returns {void}
 */
function data_license_u() {
/*
CREATE OR REPLACE FUNCTION zzglc.data_license_u("Json" character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE v_row_count INTEGER;
BEGIN

    UPDATE data.license t
    SET name = U.name 
    FROM json_to_record("Json"::json) AS U (
        id integer,
            name character varying
    ) 
    WHERE U.id = t.id
;

END $function$

*/
 }
/**
 * @function update_time_modified
 * @memberof meta
 * @description Update time modified
 * @returns {trigger}
 */
function update_time_modified() {
/*
CREATE OR REPLACE FUNCTION meta.update_time_modified()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN

	NEW.time_modified = CURRENT_TIMESTAMP;
	RETURN NEW;
END $function$

*/
 }
/**
 * @function meta_news_lang_r
 * @memberof zzglc
 * @description Meta news lang r
 * @returns {Object}
 * @property {integer} id
 * @property {integer} lang_id
 * @property {character_varying} text
 * @property {character_varying} extended_text
 * @property {timestamp_without_time_zone} time_modified
 * @property {integer} user_modified
 * @property {timestamp_without_time_zone} time_created
 * @property {boolean} active
 * @property {character_varying} title
 * @property {integer} news_id
 * @property {character_varying} lang_id_val
 * @property {character_varying} user_modified_val
 * @property {character_varying} news_id_val
 */
function meta_news_lang_r() {
/*
CREATE OR REPLACE FUNCTION zzglc.meta_news_lang_r()
 RETURNS TABLE(id integer, lang_id integer, text character varying, extended_text character varying, time_modified timestamp without time zone, user_modified integer, time_created timestamp without time zone, active boolean, title character varying, news_id integer, lang_id_val character varying, user_modified_val character varying, news_id_val character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

    RETURN QUERY
    SELECT
    t.id, t.lang_id, t.text, t.extended_text, t.time_modified, t.user_modified, t.time_created, t.active, t.title, t.news_id
    , lang_id_t.name::VARCHAR AS lang_id_val, user_modified_t.name::VARCHAR AS user_modified_val, news_id_t.name::VARCHAR AS news_id_val
    FROM meta.news_lang t

    LEFT JOIN meta.lang lang_id_t ON lang_id_t.id = t.lang_id
    LEFT JOIN general.person user_modified_t ON user_modified_t.id = t.user_modified
    LEFT JOIN meta.news news_id_t ON news_id_t.id = t.news_id
    
    ORDER BY t.lang_id
;
END $function$

*/
 }
/**
 * @function data_point_l
 * @memberof zzgll
 * @description Data point l
 * @param {character_varying} SearchValue
 * @param {integer} Key
 * @returns {Object}
 * @property {integer} id
 * @property {character_varying} point_key
 */
function data_point_l() {
/*
CREATE OR REPLACE FUNCTION zzgll.data_point_l("SearchValue" character varying, "Key" integer DEFAULT NULL::integer)
 RETURNS TABLE(id integer, point_key character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

        IF "Key" IS NOT NULL THEN
            RETURN QUERY
            SELECT t.id, t.point_key
            FROM data.point t
            WHERE t.id = "Key"::integer;
        ELSE
            RETURN QUERY
           SELECT t.id, t.point_key
            FROM data.point t
            WHERE t.point_key LIKE "SearchValue"
            ORDER BY t.point_key
           LIMIT 1000;
       END IF;
END $function$

*/
 }
/**
 * @function get_boundary
 * @memberof general
 * @description Get boundary
 * @param {integer} OsmId
 * @param {integer} Srid
 * @returns {json}
 */
function get_boundary() {
/*
CREATE OR REPLACE FUNCTION general.get_boundary("OsmId" integer, "Srid" integer)
 RETURNS json
 LANGUAGE plpgsql
AS $function$
BEGIN

	RETURN (
		SELECT jsonb_build_object (
				'type',       'FeatureCollection',
				'features', json_agg(st_asgeojson(t.*)::json)
    )
		FROM (
			SELECT b.id, b.name, b.osm_id, st_transform(geom, "Srid") geom
			FROM general.boundary b 
			WHERE b.osm_id = "OsmId"
		) t	
	);
END$function$

*/
 }
/**
 * @function auth_role_public_r
 * @memberof zzglc
 * @description Auth role public r
 * @returns {Object}
 * @property {integer} id
 * @property {character_varying} name
 */
function auth_role_public_r() {
/*
CREATE OR REPLACE FUNCTION zzglc.auth_role_public_r()
 RETURNS TABLE(id integer, name character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

    RETURN QUERY
    SELECT
    t.id, t.name
    FROM auth.role_public t
    
    ORDER BY t.name
;
END $function$

*/
 }
/**
 * @function get_observations
 * @memberof data
 * @description Get observations
 * @param {text} Params
 * @param {integer} PersonId
 * @param {integer} LangId
 * @returns {Object}
 * @property {integer} id
 * @property {character_varying} name
 * @property {character_varying} type
 * @property {boolean} public
 * @property {timestamp_with_time_zone} time_created
 * @property {timestamp_with_time_zone} time_modified
 */
function get_observations() {
/*
CREATE OR REPLACE FUNCTION data.get_observations("Params" text, "PersonId" integer, "LangId" integer)
 RETURNS TABLE(id integer, name character varying, type character varying, public boolean, time_created timestamp with time zone, time_modified timestamp with time zone)
 LANGUAGE plpgsql
AS $function$
BEGIN

	RETURN QUERY (
        SELECT f.id, f.name, gt.name, f.public, f.time_created, f.time_modified
		FROM data.custom_geometry f
		LEFT JOIN data.geometry_type gt ON gt.id = f.geometry_type_id
		WHERE f.person_id = "PersonId"
        GROUP BY f.id, gt.name
	);
		
END 
$function$

*/
 }
/**
 * @function general_region_u
 * @memberof zzglc
 * @description General region u
 * @param {character_varying} Json
 * @returns {void}
 */
function general_region_u() {
/*
CREATE OR REPLACE FUNCTION zzglc.general_region_u("Json" character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE v_row_count INTEGER;
BEGIN

    UPDATE general.region t
    SET name = U.name 
    FROM json_to_record("Json"::json) AS U (
        id smallint,
            name character varying(255)
    ) 
    WHERE U.id = t.id
;

END $function$

*/
 }
/**
 * @function general_nuts_d
 * @memberof zzglc
 * @description General nuts d
 * @param {integer} Key
 * @returns {void}
 */
function general_nuts_d() {
/*
CREATE OR REPLACE FUNCTION zzglc.general_nuts_d("Key" integer)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

    DELETE FROM general.nuts
    WHERE id = "Key";

END $function$

*/
 }
/**
 * @function general_message_u
 * @memberof zzglc
 * @description General message u
 * @param {character_varying} Json
 * @returns {void}
 */
function general_message_u() {
/*
CREATE OR REPLACE FUNCTION zzglc.general_message_u("Json" character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE v_row_count INTEGER;
BEGIN

    UPDATE general.message t
    SET person_id = U.person_id,
        message = U.message,
        message = U.message,
        parent_id = U.parent_id 
    FROM json_to_record("Json"::json) AS U (
        id integer,
            person_id integer,
            message text,
            time_modified timestamp without time zone,
            parent_id integer
    ) 
    WHERE U.id = t.id
    AND t.time_modified = U.time_modified;
    GET DIAGNOSTICS v_row_count = ROW_COUNT;
    IF v_row_count = 0 THEN
      SELECT meta.raise_error(2);
    END IF
;

END $function$

*/
 }
/**
 * @function general_person_c
 * @memberof zzglc
 * @description General person c
 * @param {character_varying} Json
 * @returns {void}
 */
function general_person_c() {
/*
CREATE OR REPLACE FUNCTION zzglc.general_person_c("Json" character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

    INSERT INTO general.person (
        first_name,
        last_name,
        partner_id,
        email,
        name1,
        user_email
    )
    SELECT
        U.first_name,
        U.last_name,
        U.partner_id,
        U.email,
        U.name1,
        U.user_email
    FROM
        json_to_record("Json"::json) U (
first_name character varying(255),
            last_name character varying(255),
            partner_id integer,
            email character varying(255),
            name1 character varying(255),
            user_email character varying(255)
        ) 
;
END $function$

*/
 }
/**
 * @function data_attribute_c
 * @memberof zzglc
 * @description Data attribute c
 * @param {character_varying} Json
 * @returns {integer}
 */
function data_attribute_c() {
/*
CREATE OR REPLACE FUNCTION zzglc.data_attribute_c("Json" character varying)
 RETURNS integer
 LANGUAGE plpgsql
AS $function$
   DECLARE v_id integer;
BEGIN

    INSERT INTO data.attribute (
        point_id,
        indicator_id,
        description_id,
        data_source_id,
        date,
        attribute_description_id
    )
    SELECT
        U.point_id,
        U.indicator_id,
        U.description_id,
        U.data_source_id,
        U.date,
        U.attribute_description_id
    FROM
        json_to_record("Json"::json) U (
point_id integer,
            indicator_id integer,
            description_id integer,
            data_source_id integer,
            date date,
            attribute_description_id integer
        ) 
    RETURNING id INTO v_id;

    RETURN v_id;
END $function$

*/
 }
/**
 * @function meta_data_type_l
 * @memberof zzgll
 * @description Meta data type l
 * @param {character_varying} SearchValue
 * @param {integer} Key
 * @returns {Object}
 * @property {integer} id
 * @property {character_varying} name
 */
function meta_data_type_l() {
/*
CREATE OR REPLACE FUNCTION zzgll.meta_data_type_l("SearchValue" character varying, "Key" integer DEFAULT NULL::integer)
 RETURNS TABLE(id integer, name character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

        IF "Key" IS NOT NULL THEN
            RETURN QUERY
            SELECT t.id, t.name
            FROM meta.data_type t
            WHERE t.id = "Key"::integer;
        ELSE
            RETURN QUERY
           SELECT t.id, t.name
            FROM meta.data_type t
            WHERE t.name LIKE "SearchValue"
            ORDER BY t.name
           LIMIT 1000;
       END IF;
END $function$

*/
 }
/**
 * @function get_context_user_id_for_data
 * @memberof auth
 * @description Get context user id for data
 * @returns {uuid}
 */
function get_context_user_id_for_data() {
/*
CREATE OR REPLACE FUNCTION auth.get_context_user_id_for_data()
 RETURNS uuid
 LANGUAGE plpgsql
AS $function$ 
	DECLARE v_id TEXT;
	BEGIN

		v_id := current_setting('context.impersonated_user_id');
		IF v_id = '' THEN
			RETURN null::UUID;
		ELSE
			RETURN v_id::UUID;
		END IF;
	END $function$

*/
 }
/**
 * @function data_shape_r
 * @memberof zzglc
 * @description Data shape r
 * @returns {Object}
 * @property {integer} id
 * @property {integer} data_source_id
 * @property {character_varying} name
 * @property {character_varying} data_source_id_val
 */
function data_shape_r() {
/*
CREATE OR REPLACE FUNCTION zzglc.data_shape_r()
 RETURNS TABLE(id integer, data_source_id integer, name character varying, data_source_id_val character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

    RETURN QUERY
    SELECT
    t.id, t.data_source_id, t.name
    , data_source_id_t.name::VARCHAR AS data_source_id_val
    FROM data.shape t

    LEFT JOIN data.data_source data_source_id_t ON data_source_id_t.id = t.data_source_id
    
    ORDER BY data_source_id_t.name, t.name
;
END $function$

*/
 }
/**
 * @function get_boundaries
 * @memberof general
 * @description Get boundaries
 * @param {integer} Level
 * @param {integer} Srid
 * @param {integer} Zoom
 * @param {double_precision} MinX
 * @param {double_precision} MinY
 * @param {double_precision} MaxX
 * @param {double_precision} MaxY
 * @param {integer} IndicatorId
 * @returns {json}
 */
function get_boundaries() {
/*
CREATE OR REPLACE FUNCTION general.get_boundaries("Level" integer, "Srid" integer, "Zoom" integer, "MinX" double precision, "MinY" double precision, "MaxX" double precision, "MaxY" double precision, "IndicatorId" integer)
 RETURNS json
 LANGUAGE plpgsql
AS $function$
DECLARE bb geometry;
				simplify float;
BEGIN

  bb := st_makeenvelope ("MinX", "MinY", "MaxX", "MaxY", "Srid");
	bb := st_transform(bb, 3857);
	
	RAISE NOTICE '%', bb;
	
	IF ("Zoom" &lt;= 6) THEN
		simplify := 5000;
	ELSIF ("Zoom" &lt;= 7) THEN
		simplify := 2000;
	ELSIF ("Zoom" &lt;= 8) THEN
		simplify := 1000;
	ELSIF ("Zoom" &lt;= 9) THEN
		simplify := 500;		
	ELSIF ("Zoom" &lt;= 10) THEN 
		simplify := 200;
	ELSIF ("Zoom" &lt;= 11) THEN 
		simplify := 100;
	ELSIF ("Zoom" &lt;= 12) THEN 
		simplify := 50;
	ELSIF ("Zoom" &lt;= 13) THEN 
		simplify := 20;
	ELSIF ("Zoom" &lt;= 14) THEN 
		simplify := 10;
	ELSE
		simplify := 1;
	END IF;
	
	DROP TABLE IF EXISTS c;
	
	CREATE TEMP TABLE c AS
		SELECT c.osm_id, v.value, ic.color_code
		FROM general.country c
		LEFT JOIN data.vw_avg_indicator_values_by_nuts0 v  
		ON v.nuts_name = c.lucas_code AND v.indicator_id = "IndicatorId"
		LEFT JOIN data.vw_indicator_color ic 
		ON ic.indicator_id = v.indicator_id AND ic.value_from &lt; v.value AND ic.value_to >= v.value
		WHERE c.region_id = 2;	
	
	RETURN (
		SELECT jsonb_build_object (
				'type',       'FeatureCollection',
				'features', json_agg(st_asgeojson(t.*)::json)
    )
		FROM (
		  WITH RECURSIVE rh AS (
				SELECT b.osm_id
				FROM general.boundary b 
				INNER JOIN c ON c.osm_id = b.osm_id
				WHERE level = 1 
				AND st_intersects(b.geom, bb)
				UNION ALL
				SELECT bh.child_id
				FROM general.boundary_hierarchy bh
				INNER JOIN rh ON bh.parent_id = rh.osm_id
				INNER JOIN general.boundary b 
				ON b.osm_id = bh.child_id 
				AND b.level BETWEEN 2 AND "Level"
			)
			SELECT b.id, b.name, b.osm_id, c.value, c.color_code, st_transform(st_simplify(b.geom,simplify, true), "Srid")
			FROM rh
			INNER JOIN general.boundary b ON b.osm_id = rh.osm_id
			INNER JOIN c ON c.osm_id = b.osm_id 
		) t	
	);
END$function$

*/
 }
/**
 * @function data_geometry_type_property_u
 * @memberof zzglc
 * @description Data geometry type property u
 * @param {character_varying} Json
 * @returns {void}
 */
function data_geometry_type_property_u() {
/*
CREATE OR REPLACE FUNCTION zzglc.data_geometry_type_property_u("Json" character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE v_row_count INTEGER;
BEGIN

    UPDATE data.geometry_type_property t
    SET geometry_type_id = U.geometry_type_id,
        order_no = U.order_no,
        property_id = U.property_id 
    FROM json_to_record("Json"::json) AS U (
        id integer,
            geometry_type_id integer,
            order_no integer,
            property_id integer
    ) 
    WHERE U.id = t.id
;

END $function$

*/
 }
/**
 * @function update_user_and_time_modified
 * @memberof meta
 * @description Update user and time modified
 * @returns {trigger}
 */
function update_user_and_time_modified() {
/*
CREATE OR REPLACE FUNCTION meta.update_user_and_time_modified()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN

	NEW.time_modified = CURRENT_TIMESTAMP;
	NEW.user_modified = auth.get_context_person_id();
	RETURN NEW;
END $function$

*/
 }
/**
 * @function auth_person_role_public_u
 * @memberof zzglc
 * @description Auth person role public u
 * @param {character_varying} Json
 * @returns {void}
 */
function auth_person_role_public_u() {
/*
CREATE OR REPLACE FUNCTION zzglc.auth_person_role_public_u("Json" character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
    DECLARE json_data json;
    BEGIN

			 json_data := "Json";
        UPDATE auth.person_role_public SET
        person_id = (json_data->>'person_id')::integer, 
        role_public_id = (json_data->>'role_public_id')::integer
        WHERE id = (json_data->>'id')::integer; 
    END $function$

*/
 }
/**
 * @function meta_lang_r
 * @memberof zzglc
 * @description Meta lang r
 * @returns {Object}
 * @property {integer} id
 * @property {character_varying} name
 * @property {character_varying} tag
 * @property {timestamp_without_time_zone} time_modified
 * @property {character} short_tag
 */
function meta_lang_r() {
/*
CREATE OR REPLACE FUNCTION zzglc.meta_lang_r()
 RETURNS TABLE(id integer, name character varying, tag character varying, time_modified timestamp without time zone, short_tag character)
 LANGUAGE plpgsql
AS $function$
BEGIN

    RETURN QUERY
    SELECT
    t.id, t.name, t.tag, t.time_modified, t.short_tag
    FROM meta.lang t
    
    ORDER BY t.name
;
END $function$

*/
 }
/**
 * @function get_db_schema
 * @memberof meta
 * @description Get db schema
 * @returns {json}
 */
function get_db_schema() {
/*
CREATE OR REPLACE FUNCTION meta.get_db_schema()
 RETURNS json
 LANGUAGE plpgsql
AS $function$

DECLARE v_schema VARCHAR;
DECLARE v_table VARCHAR;
DECLARE j_schemas JSON;
DECLARE j_tables JSON;
BEGIN

	SELECT json_agg(t.*) INTO j_schemas FROM (
		SELECT nsp.nspname AS schema_name, d.description
		FROM pg_catalog.pg_namespace nsp
			   LEFT JOIN pg_catalog.pg_description d ON d.objoid = nsp.oid
		WHERE nsp.nspname IN ('auth', 'data', 'general', 'log', 'meta', 'osm', 'utils', 'zzglc', 'zzgll', 'zzhistory')
	) t;

	DROP TABLE IF EXISTS tmp; 
	CREATE TEMP TABLE tmp AS
			SELECT * FROM meta.get_table_cols('auth', 'log');
	DELETE FROM tmp;

	FOR v_schema, v_table IN 
	SELECT table_schema, table_name 
	FROM information_schema.tables
	WHERE table_catalog = 'ai4soilhealth' and table_schema in ('auth', 'data', 'general', 'log', 'meta', 'osm', 'utils', 'zzglc', 'zzgll', 'zzhistory')
	LOOP
			INSERT INTO tmp
			SELECT * FROM meta.get_table_cols(v_schema, v_table);
	END LOOP;

	WITH
	a AS (
		SELECT table_schema, table_name, 
		json_build_object('column_name', column_name, 'data_type', data_type, 'column_comment', column_comment, 'referenced_schema_name', referenced_schema_name, 'referenced_table_name', referenced_table_name, 'referenced_column_name', referenced_column_name) column 
		FROM (
			SELECT t.*, ac.description column_comment
			FROM tmp t
			LEFT JOIN pg_attribute a 
				ON a.attrelid = (table_schema || '.' || table_name)::regclass AND a.attname = t.column_name 
			LEFT JOIN pg_description ac 
				ON ac.objoid = a.attrelid and ac.objsubid = a.attnum
		) t
	),
	b AS (
		SELECT a.table_schema, a.table_name, tc.description table_comment, json_agg(a.column) columns
		FROM a 
		LEFT JOIN pg_description tc 
				ON tc.objoid = (table_schema || '.' || table_name)::regclass and tc.objsubid = 0
		GROUP BY a.table_schema, a.table_name, tc.description
		ORDER BY 1, 2
	) 
	SELECT json_agg(c.*) INTO j_tables FROM (
		SELECT * FROM b
	) c;

	RETURN json_build_object('schemas', j_schemas, 'tables', j_tables);

END 
$function$

*/
 }
/**
 * @function data_file_dataset_l
 * @memberof zzgll
 * @description Data file dataset l
 * @param {character_varying} SearchValue
 * @param {integer} Key
 * @returns {Object}
 * @property {integer} id
 * @property {character_varying} name
 */
function data_file_dataset_l() {
/*
CREATE OR REPLACE FUNCTION zzgll.data_file_dataset_l("SearchValue" character varying, "Key" integer DEFAULT NULL::integer)
 RETURNS TABLE(id integer, name character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

        IF "Key" IS NOT NULL THEN
            RETURN QUERY
            SELECT t.id, t.name
            FROM data.file_dataset t
            WHERE t.id = "Key"::integer;
        ELSE
            RETURN QUERY
           SELECT t.id, t.name
            FROM data.file_dataset t
            WHERE t.name LIKE "SearchValue"
            ORDER BY t.name
           LIMIT 1000;
       END IF;
END $function$

*/
 }
/**
 * @function data_date_unit_l
 * @memberof zzgll
 * @description Data date unit l
 * @param {character_varying} SearchValue
 * @param {integer} Key
 * @returns {Object}
 * @property {integer} id
 * @property {character_varying} name
 */
function data_date_unit_l() {
/*
CREATE OR REPLACE FUNCTION zzgll.data_date_unit_l("SearchValue" character varying, "Key" integer DEFAULT NULL::integer)
 RETURNS TABLE(id integer, name character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

        IF "Key" IS NOT NULL THEN
            RETURN QUERY
            SELECT t.id, t.name
            FROM data.date_unit t
            WHERE t.id = "Key"::integer;
        ELSE
            RETURN QUERY
           SELECT t.id, t.name
            FROM data.date_unit t
            WHERE t.name LIKE "SearchValue"
            ORDER BY t.name
           LIMIT 1000;
       END IF;
END $function$

*/
 }
/**
 * @function update_preview_href
 * @memberof data
 * @description Update preview href
 * @returns {void}
 */
function update_preview_href() {
/*
CREATE OR REPLACE FUNCTION data.update_preview_href()
 RETURNS void
 LANGUAGE plpgsql
AS $function$

BEGIN

 
UPDATE oedce1 SET preview_href = 
	(SELECT href FROM pv WHERE pv.file = oedce1.file LIMIT 1)
WHERE type = 'image/tiff; application=geotiff' ;
END $function$

*/
 }
/**
 * @function general_ai_model_c
 * @memberof zzglc
 * @description General ai model c
 * @param {character_varying} Json
 * @returns {void}
 */
function general_ai_model_c() {
/*
CREATE OR REPLACE FUNCTION zzglc.general_ai_model_c("Json" character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

    INSERT INTO general.ai_model (
        name
    )
    SELECT
        U.name
    FROM
        json_to_record("Json"::json) U (
name character varying(255)
        ) 
;
END $function$

*/
 }
/**
 * @function meta_import_master_l
 * @memberof zzgll
 * @description Meta import master l
 * @param {character_varying} SearchValue
 * @param {integer} Key
 * @returns {Object}
 * @property {integer} id
 * @property {character_varying} schema_name
 */
function meta_import_master_l() {
/*
CREATE OR REPLACE FUNCTION zzgll.meta_import_master_l("SearchValue" character varying, "Key" integer DEFAULT NULL::integer)
 RETURNS TABLE(id integer, schema_name character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

        IF "Key" IS NOT NULL THEN
            RETURN QUERY
            SELECT t.id, t.schema_name
            FROM meta.import_master t
            WHERE t.id = "Key"::integer;
        ELSE
            RETURN QUERY
           SELECT t.id, t.schema_name
            FROM meta.import_master t
            WHERE t.schema_name LIKE "SearchValue"
            ORDER BY t.schema_name
           LIMIT 1000;
       END IF;
END $function$

*/
 }
/**
 * @function data_date_unit_u
 * @memberof zzglc
 * @description Data date unit u
 * @param {character_varying} Json
 * @returns {void}
 */
function data_date_unit_u() {
/*
CREATE OR REPLACE FUNCTION zzglc.data_date_unit_u("Json" character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE v_row_count INTEGER;
BEGIN

    UPDATE data.date_unit t
    SET name = U.name,
        format = U.format 
    FROM json_to_record("Json"::json) AS U (
        id integer,
            name character varying,
            format character varying
    ) 
    WHERE U.id = t.id
;

END $function$

*/
 }
/**
 * @function data_asset_theme_c
 * @memberof zzglc
 * @description Data asset theme c
 * @param {character_varying} Json
 * @returns {void}
 */
function data_asset_theme_c() {
/*
CREATE OR REPLACE FUNCTION zzglc.data_asset_theme_c("Json" character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

    INSERT INTO data.asset_theme (
        name
    )
    SELECT
        U.name
    FROM
        json_to_record("Json"::json) U (
name character varying
        ) 
;
END $function$

*/
 }
/**
 * @function data_indicator_lang_c
 * @memberof zzglc
 * @description Data indicator lang c
 * @param {character_varying} Json
 * @returns {void}
 */
function data_indicator_lang_c() {
/*
CREATE OR REPLACE FUNCTION zzglc.data_indicator_lang_c("Json" character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

    INSERT INTO data.indicator_lang (
        indicator_id,
        lang_id,
        value
    )
    SELECT
        U.indicator_id,
        U.lang_id,
        U.value
    FROM
        json_to_record("Json"::json) U (
indicator_id integer,
            lang_id integer,
            value character varying(255)
        ) 
;
END $function$

*/
 }
/**
 * @function set_children_geometry
 * @memberof general
 * @description Set children geometry
 * @param {text} Properties
 * @param {text} Geometry
 * @returns {void}
 */
function set_children_geometry() {
/*
CREATE OR REPLACE FUNCTION general.set_children_geometry("Properties" text, "Geometry" text)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE p json;
DECLARE parents VARCHAR;
BEGIN

	p := "Properties"::json;

	parents := replace((p->'parents')::varchar, '"', '');

	DELETE FROM general.boundary_hierarchy WHERE child_id = abs((p->'osm_id')::varchar::int);
	DELETE FROM general.boundary WHERE osm_id = abs((p->'osm_id')::varchar::int);

  IF (p->'admin_level')::varchar != 'null' THEN

		INSERT INTO general.boundary (osm_id, admin_level, name, local_name, geom)
		SELECT abs((p->'osm_id')::varchar::int), 
		(p->'admin_level')::varchar::int, 
		REPLACE ((p->'name')::varchar, '"', ''), 
		REPLACE ((p->'local_name')::varchar, '"', ''),
		st_transform(st_multi(st_geomfromgeojson("Geometry")), 3035);
		
		IF parents IS NOT null AND parents != 'null' THEN	
			INSERT INTO general.boundary_hierarchy (parent_id, child_id) 
			SELECT abs(x::int), abs(y::int) FROM (
				SELECT unnest(string_to_array(parents, ',')) x, (p->'osm_id')::varchar y
			) t;
		END IF;
	
	END IF;
	--INSERT INTO meta.trace (text)
	--VALUES (abs((p->'osm_id')::varchar::int)::VARCHAR);
	
RETURN;
END$function$

*/
 }
/**
 * @function meta_help_l
 * @memberof zzgll
 * @description Meta help l
 * @param {character_varying} SearchValue
 * @param {integer} Key
 * @returns {Object}
 * @property {integer} id
 * @property {character_varying} name
 */
function meta_help_l() {
/*
CREATE OR REPLACE FUNCTION zzgll.meta_help_l("SearchValue" character varying, "Key" integer DEFAULT NULL::integer)
 RETURNS TABLE(id integer, name character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

        IF "Key" IS NOT NULL THEN
            RETURN QUERY
            SELECT t.id, t.name
            FROM meta.help t
            WHERE t.id = "Key"::integer;
        ELSE
            RETURN QUERY
           SELECT t.id, t.name
            FROM meta.help t
            WHERE t.name LIKE "SearchValue"
            ORDER BY t.name
           LIMIT 1000;
       END IF;
END $function$

*/
 }
/**
 * @function data_custom_geometry_u
 * @memberof zzglc
 * @description Data custom geometry u
 * @param {character_varying} Json
 * @returns {void}
 */
function data_custom_geometry_u() {
/*
CREATE OR REPLACE FUNCTION zzglc.data_custom_geometry_u("Json" character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE v_row_count INTEGER;
BEGIN

    UPDATE data.custom_geometry t
    SET geometry_type_id = U.geometry_type_id,
        person_id = U.person_id,
        route_key = U.route_key,
        geometry = U.geometry,
        name = U.name,
        public = U.public,
        time_created = U.time_created 
    FROM json_to_record("Json"::json) AS U (
        id integer,
            geometry_type_id integer,
            person_id integer,
            route_key character varying,
            geometry geometry,
            name character varying(255),
            public boolean,
            time_modified timestamp with time zone,
            time_created timestamp with time zone
    ) 
    WHERE U.id = t.id
    AND t.time_modified = U.time_modified;
    GET DIAGNOSTICS v_row_count = ROW_COUNT;
    IF v_row_count = 0 THEN
      SELECT meta.raise_error(2);
    END IF
;

END $function$

*/
 }
/**
 * @function meta_news_r
 * @memberof zzglc
 * @description Meta news r
 * @returns {Object}
 * @property {integer} id
 * @property {character_varying} name
 * @property {boolean} active
 * @property {timestamp_without_time_zone} time_modified
 * @property {integer} user_modified
 * @property {timestamp_without_time_zone} time_created
 * @property {character_varying} user_modified_val
 */
function meta_news_r() {
/*
CREATE OR REPLACE FUNCTION zzglc.meta_news_r()
 RETURNS TABLE(id integer, name character varying, active boolean, time_modified timestamp without time zone, user_modified integer, time_created timestamp without time zone, user_modified_val character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

    RETURN QUERY
    SELECT
    t.id, t.name, t.active, t.time_modified, t.user_modified, t.time_created
    , user_modified_t.name::VARCHAR AS user_modified_val
    FROM meta.news t

    LEFT JOIN general.person user_modified_t ON user_modified_t.id = t.user_modified
;
END $function$

*/
 }
/**
 * @function data_attribute_description_u
 * @memberof zzglc
 * @description Data attribute description u
 * @param {character_varying} Json
 * @returns {void}
 */
function data_attribute_description_u() {
/*
CREATE OR REPLACE FUNCTION zzglc.data_attribute_description_u("Json" character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE v_row_count INTEGER;
BEGIN

    UPDATE data.attribute_description t
    SET indicator_id = U.indicator_id,
        description_id = U.description_id,
        name = U.name,
        color_id = U.color_id,
        code = U.code 
    FROM json_to_record("Json"::json) AS U (
        id integer,
            indicator_id integer,
            description_id integer,
            name character varying(255),
            color_id integer,
            code character varying(255)
    ) 
    WHERE U.id = t.id
;

END $function$

*/
 }
/**
 * @function auth_route_role_public_r
 * @memberof zzglc
 * @description Auth route role public r
 * @returns {Object}
 * @property {integer} id
 * @property {integer} route_id
 * @property {integer} role_public_id
 * @property {character_varying} route_id_val
 * @property {character_varying} role_public_id_val
 */
function auth_route_role_public_r() {
/*
CREATE OR REPLACE FUNCTION zzglc.auth_route_role_public_r()
 RETURNS TABLE(id integer, route_id integer, role_public_id integer, route_id_val character varying, role_public_id_val character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

    RETURN QUERY
    SELECT
    t.id, t.route_id, t.role_public_id
    , route_id_t.name::VARCHAR AS route_id_val, role_public_id_t.name::VARCHAR AS role_public_id_val
    FROM auth.route_role_public t

    LEFT JOIN meta.route route_id_t ON route_id_t.id = t.route_id
    LEFT JOIN auth.role_public role_public_id_t ON role_public_id_t.id = t.role_public_id
;
END $function$

*/
 }
/**
 * @function auth_user_role_r
 * @memberof zzglc
 * @description Auth user role r
 * @returns {Object}
 * @property {uuid} id
 * @property {uuid} user_id
 * @property {uuid} role_id
 * @property {timestamp_without_time_zone} time_modified
 */
function auth_user_role_r() {
/*
CREATE OR REPLACE FUNCTION zzglc.auth_user_role_r()
 RETURNS TABLE(id uuid, user_id uuid, role_id uuid, time_modified timestamp without time zone)
 LANGUAGE plpgsql
AS $function$
BEGIN

    RETURN QUERY
    SELECT
    t.id, t.user_id, t.role_id, t.time_modified
     FROM auth.user_role t
     
     ORDER BY t.user_id
;
END $function$

*/
 }
/**
 * @function prepare_joins
 * @memberof meta
 * @description Prepare joins
 * @param {integer} Id
 * @returns {void}
 */
function prepare_joins() {
/*
CREATE OR REPLACE FUNCTION meta.prepare_joins("Id" integer)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE 
	v_data_date VARCHAR;
	v_constant_value VARCHAR;
BEGIN

	
	SELECT data_date, constant_value
	INTO v_data_date, v_constant_value
	FROM meta.import_master WHERE id = "Id";
	
	RAISE NOTICE '%', v_data_date;
	
	IF EXISTS (SELECT 1 FROM meta.import_detail WHERE import_master_id = "Id" AND col_name = 'depth') THEN
	
			UPDATE meta.import_detail t SET
			source_column_list = 'x.id, i.id, d.id, col_name, ' || v_data_date || ', ' || v_constant_value,
			target_column_list = 'point_id, indicator_id, depth_id, value, date, data_source_id',
			joins = 
				' left join data.indicator i on i.name_match = ''' || t.name_match || '''' ||
				' left join data.measurement y on y.point_id = x.id and y.indicator_id = i.id and y.date = ' || v_data_date ||
				' left join data.depth d on d.name = t.depth'
			WHERE t.target_table = 'measurement' AND t.import_master_id = "Id"; --AND t.source_column_list IS NULL;
	ELSE
			UPDATE meta.import_detail t SET
			source_column_list = 'x.id, i.id, col_name, ' || v_data_date || ', ' || v_constant_value,
			target_column_list = 'point_id, indicator_id, value, date, data_source_id',
			joins = 
				' left join data.indicator i on i.name_match = ''' || t.name_match || '''' ||
				' left join data.measurement y on y.point_id = x.id and y.indicator_id = i.id and y.date = ' || v_data_date 
			WHERE t.target_table = 'measurement' AND t.import_master_id = "Id"; --AND t.source_column_list IS NULL;	
	END IF;
	
END $function$

*/
 }
/**
 * @function data_file_category_l
 * @memberof zzgll
 * @description Data file category l
 * @param {character_varying} SearchValue
 * @param {integer} Key
 * @returns {Object}
 * @property {integer} id
 * @property {character_varying} name
 */
function data_file_category_l() {
/*
CREATE OR REPLACE FUNCTION zzgll.data_file_category_l("SearchValue" character varying, "Key" integer DEFAULT NULL::integer)
 RETURNS TABLE(id integer, name character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

        IF "Key" IS NOT NULL THEN
            RETURN QUERY
            SELECT t.id, t.name
            FROM data.file_category t
            WHERE t.id = "Key"::integer;
        ELSE
            RETURN QUERY
           SELECT t.id, t.name
            FROM data.file_category t
            WHERE t.name LIKE "SearchValue"
            ORDER BY t.name
           LIMIT 1000;
       END IF;
END $function$

*/
 }
/**
 * @function meta_news_l
 * @memberof zzgll
 * @description Meta news l
 * @param {character_varying} SearchValue
 * @param {integer} Key
 * @returns {Object}
 * @property {integer} id
 * @property {character_varying} name
 */
function meta_news_l() {
/*
CREATE OR REPLACE FUNCTION zzgll.meta_news_l("SearchValue" character varying, "Key" integer DEFAULT NULL::integer)
 RETURNS TABLE(id integer, name character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

        IF "Key" IS NOT NULL THEN
            RETURN QUERY
            SELECT t.id, t.name
            FROM meta.news t
            WHERE t.id = "Key"::integer;
        ELSE
            RETURN QUERY
           SELECT t.id, t.name
            FROM meta.news t
            WHERE t.name LIKE "SearchValue"
            ORDER BY t.name
           LIMIT 1000;
       END IF;
END $function$

*/
 }
/**
 * @function data_file_metadata_import_excel
 * @memberof data
 * @description Data file metadata import excel
 * @param {text} jsonCV
 * @param {text} jsonData
 * @returns {void}
 */
function data_file_metadata_import_excel() {
/*
CREATE OR REPLACE FUNCTION data.data_file_metadata_import_excel("jsonCV" text, "jsonData" text)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

DROP TABLE IF EXISTS t;
CREATE TEMP TABLE t AS
SELECT * FROM json_to_recordset("jsonData"::json) AS J(
"id" varchar, "filename_pattern" varchar, "uncertainty" varchar, "gs_name" varchar, "code" varchar, "title" varchar, "style" varchar, "type" varchar, "category" varchar, "description" varchar, "theme" varchar, "theme_number" varchar, "range" varchar, "range_wasabi" varchar, "fourd_range" varchar, "scale" varchar, "unit" varchar, "has_points" varchar, "sd_type" varchar, "scale_factor" varchar, "gn_url" varchar, "wasabi_link" varchar, "gn_uuid" varchar, "gn_author" varchar, "gn_resolution" varchar, "gn_author_email" varchar, "pub_date" varchar, "dataset_id" varchar, "stac_url" varchar);

WITH x AS (SELECT DISTINCT t."category" FROM  t)
INSERT INTO data.file_category(name)
SELECT meta.clean_value(x."category", 'varchar')::varchar FROM x
LEFT JOIN data.file_category file_category ON file_category.name= x."category"
WHERE file_category.id IS NULL;

WITH x AS (SELECT DISTINCT t."dataset_id" FROM  t)
INSERT INTO data.file_dataset(name)
SELECT meta.clean_value(x."dataset_id", 'varchar')::varchar FROM x
LEFT JOIN data.file_dataset file_dataset ON file_dataset.name= x."dataset_id"
WHERE file_dataset.id IS NULL;

WITH x AS (SELECT DISTINCT t."gn_resolution" FROM  t)
INSERT INTO data.file_resolution(name)
SELECT meta.clean_value(x."gn_resolution", 'varchar')::varchar FROM x
LEFT JOIN data.file_resolution file_resolution ON file_resolution.name= x."gn_resolution"
WHERE file_resolution.id IS NULL;

WITH x AS (SELECT DISTINCT t."scale" FROM  t)
INSERT INTO data.file_scale(name)
SELECT meta.clean_value(x."scale", 'varchar')::varchar FROM x
LEFT JOIN data.file_scale file_scale ON file_scale.name= x."scale"
WHERE file_scale.id IS NULL;

WITH x AS (SELECT DISTINCT t."sd_type" FROM  t)
INSERT INTO data.file_sd_type(name)
SELECT meta.clean_value(x."sd_type", 'varchar')::varchar FROM x
LEFT JOIN data.file_sd_type file_sd_type ON file_sd_type.name= x."sd_type"
WHERE file_sd_type.id IS NULL;

WITH x AS (SELECT DISTINCT t."theme" FROM  t)
INSERT INTO data.file_theme(name)
SELECT meta.clean_value(x."theme", 'varchar')::varchar FROM x
LEFT JOIN data.file_theme file_theme ON file_theme.name= x."theme"
WHERE file_theme.id IS NULL;

WITH x AS (SELECT DISTINCT t."type" FROM  t)
INSERT INTO data.file_type(name)
SELECT meta.clean_value(x."type", 'varchar')::varchar FROM x
LEFT JOIN data.file_type file_type ON file_type.name= x."type"
WHERE file_type.id IS NULL;

CREATE TEMP TABLE temp_person AS
SELECT "id", TRIM(s) gn_author FROM t
CROSS JOIN LATERAL string_to_table("gn_author", ',') s;

WITH x AS (SELECT DISTINCT t."gn_author" FROM temp_person t)
INSERT INTO general.person(name1)
SELECT meta.clean_value(x."gn_author", 'varchar')::varchar FROM x
LEFT JOIN general.person person ON person.name1= x."gn_author"
WHERE person.id IS NULL;

WITH x AS (SELECT DISTINCT t."unit" FROM  t)
INSERT INTO general.unit(name)
SELECT meta.clean_value(x."unit", 'varchar')::varchar FROM x
LEFT JOIN general.unit unit ON unit.name= x."unit"
WHERE unit.id IS NULL;

WITH x AS (SELECT DISTINCT t."id", t."filename_pattern", t."uncertainty", t."gs_name", t."code", t."title", t."style", t."type", t."category", t."description", t."theme", t."theme_number", t."range", t."range_wasabi", t."fourd_range", t."scale", t."unit", t."has_points", t."sd_type", t."scale_factor", t."gn_url", t."wasabi_link", t."gn_uuid", t."gn_resolution", t."pub_date", t."dataset_id", t."stac_url" FROM  t)
INSERT INTO data.file_metadata(orig_id, filename_pattern, uncertainty, gs_name, code, title, style, file_type_id, file_category_id, description, file_theme_id, theme_number, range, range_wasabi, fourd_range, file_scale_id, unit_id, has_points, file_sd_type_id, scale_factor, gn_url, wasabi_link, gn_uuid, file_resolution_id, pub_date, file_dataset_id, stac_url)
SELECT meta.clean_value(x."id", 'varchar')::varchar, meta.clean_value(x."filename_pattern", 'varchar')::varchar, meta.clean_value(x."uncertainty", 'boolean')::boolean, meta.clean_value(x."gs_name", 'varchar')::varchar, meta.clean_value(x."code", 'text')::text, meta.clean_value(x."title", 'varchar')::varchar, meta.clean_value(x."style", 'varchar')::varchar, file_type.id, file_category.id, meta.clean_value(x."description", 'varchar')::varchar, file_theme.id, meta.clean_value(x."theme_number", 'double precision')::double precision, meta.clean_value(x."range", 'varchar')::varchar, meta.clean_value(x."range_wasabi", 'varchar')::varchar, meta.clean_value(x."fourd_range", 'varchar')::varchar, file_scale.id, unit.id, meta.clean_value(x."has_points", 'boolean')::boolean, file_sd_type.id, meta.clean_value(x."scale_factor", 'varchar')::varchar, meta.clean_value(x."gn_url", 'varchar')::varchar, meta.clean_value(x."wasabi_link", 'varchar')::varchar, meta.clean_value(x."gn_uuid", 'varchar')::varchar, file_resolution.id, meta.clean_value(x."pub_date", 'timestamp')::timestamp, file_dataset.id, meta.clean_value(x."stac_url", 'varchar')::varchar FROM x
LEFT JOIN data.file_metadata file_metadata ON file_metadata.orig_id= x."id"
LEFT JOIN data.file_type file_type ON file_type.name = x."type"
LEFT JOIN data.file_category file_category ON file_category.name = x."category"
LEFT JOIN data.file_theme file_theme ON file_theme.name = x."theme"
LEFT JOIN data.file_scale file_scale ON file_scale.name = x."scale"
LEFT JOIN general.unit unit ON unit.name = x."unit"
LEFT JOIN data.file_sd_type file_sd_type ON file_sd_type.name = x."sd_type"
LEFT JOIN data.file_resolution file_resolution ON file_resolution.name = x."gn_resolution"
LEFT JOIN data.file_dataset file_dataset ON file_dataset.name = x."dataset_id"
WHERE file_metadata.id IS NULL;

INSERT INTO data.file_metadata_person (file_metadata_id, person_id )
SELECT m.id, d.id FROM temp_person x
INNER JOIN data.file_metadata m ON m."orig_id" = x."id"
INNER JOIN general.person d ON d.name1 = x."gn_author"
LEFT JOIN data.file_metadata_person l ON l.file_metadata_id = m.id AND l.person_id = d.id
WHERE l.id IS NULL;

END $function$

*/
 }
/**
 * @function general_message_c
 * @memberof zzglc
 * @description General message c
 * @param {character_varying} Json
 * @returns {void}
 */
function general_message_c() {
/*
CREATE OR REPLACE FUNCTION zzglc.general_message_c("Json" character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

    INSERT INTO general.message (
        person_id,
        message,
        parent_id
    )
    SELECT
        U.person_id,
        U.message,
        U.message,
        U.parent_id
    FROM
        json_to_record("Json"::json) U (
person_id integer,
            message text,
            parent_id integer
        ) 
;
END $function$

*/
 }
/**
 * @function general_region_d
 * @memberof zzglc
 * @description General region d
 * @param {smallint} Key
 * @returns {void}
 */
function general_region_d() {
/*
CREATE OR REPLACE FUNCTION zzglc.general_region_d("Key" smallint)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

    DELETE FROM general.region
    WHERE id = "Key";

END $function$

*/
 }
/**
 * @function extract_file_name
 * @memberof data
 * @description Extract file name
 * @param {character_varying} s
 * @returns {character_varying}
 */
function extract_file_name() {
/*
CREATE OR REPLACE FUNCTION data.extract_file_name(s character varying)
 RETURNS character varying
 LANGUAGE plpgsql
AS $function$BEGIN

	-- Routine body goes here...

	RETURN REPLACE(REPLACE (substring(
    s,
    length(s) - position('/' in reverse(s)) + 2
  ), '.tif', ''), '.png', '');
END$function$

*/
 }
/**
 * @function get_titles
 * @memberof data
 * @description Get titles
 * @returns {json}
 */
function get_titles() {
/*
CREATE OR REPLACE FUNCTION data.get_titles()
 RETURNS json
 LANGUAGE plpgsql
AS $function$

BEGIN

	-- Routine body goes here...
		RETURN (
			SELECT json_agg(t.*)
			FROM (
				SELECT a.id value, title label, main_sld_url sld, color_map, scale_factor, no_data, depth_list, decimals, av.srid
					FROM data.asset a
					LEFT JOIN data.asset_version av ON av.id = a.asset_version_id
					WHERE main_url IS NOT NULL
					ORDER BY 2
			) t
		);
END

$function$

*/
 }
/**
 * @function set_custom_geometry
 * @memberof data
 * @description Set custom geometry
 * @param {integer} PersonId
 * @param {integer} Id
 * @param {integer} GeometryTypeId
 * @param {character_varying} Name
 * @param {boolean} Public
 * @returns {integer}
 */
function set_custom_geometry() {
/*
CREATE OR REPLACE FUNCTION data.set_custom_geometry("PersonId" integer, "Id" integer, "GeometryTypeId" integer, "Name" character varying, "Public" boolean)
 RETURNS integer
 LANGUAGE plpgsql
AS $function$		
DECLARE v_id INT;	
BEGIN

	
	IF "Id" IS NULL THEN
		INSERT INTO data.custom_geometry (person_id, geometry_type_id, name, public)
		VALUES ("PersonId", "GeometryTypeId", "Name", "Public")
		RETURNING id INTO v_id;
	ELSE
		v_id := "Id";
		UPDATE data.custom_geometry 
		SET geometry_type_id = "GeometryTypeId", name = "Name", public = "Public"
		WHERE id = "Id" AND person_id = "PersonId";
	END IF;
	RETURN v_id;
	
END 
$function$

*/
 }
/**
 * @function meta_route_u
 * @memberof zzglc
 * @description Meta route u
 * @param {character_varying} Json
 * @returns {void}
 */
function meta_route_u() {
/*
CREATE OR REPLACE FUNCTION zzglc.meta_route_u("Json" character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE v_row_count INTEGER;
BEGIN

    UPDATE meta.route t
    SET name = U.name,
        order_no = U.order_no,
        path = U.path,
        component_name = U.component_name,
        icon = U.icon,
        parent = U.parent,
        props = U.props,
        offline = U.offline,
        public = U.public,
        active = U.active 
    FROM json_to_record("Json"::json) AS U (
        id integer,
            name character varying(255),
            order_no integer,
            path character varying(255),
            component_name character varying(255),
            icon character varying(255),
            parent character varying(255),
            props json,
            offline boolean,
            public boolean,
            active boolean
    ) 
    WHERE U.id = t.id
;

END $function$

*/
 }
/**
 * @function auth_person_role_public_d
 * @memberof zzglc
 * @description Auth person role public d
 * @param {integer} Key
 * @returns {void}
 */
function auth_person_role_public_d() {
/*
CREATE OR REPLACE FUNCTION zzglc.auth_person_role_public_d("Key" integer)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
    BEGIN

        DELETE FROM auth.person_role_public WHERE id = "Key"; 
    END;
    $function$

*/
 }
/**
 * @function data_lc_main_d
 * @memberof zzglc
 * @description Data lc main d
 * @param {integer} Key
 * @returns {void}
 */
function data_lc_main_d() {
/*
CREATE OR REPLACE FUNCTION zzglc.data_lc_main_d("Key" integer)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

    DELETE FROM data.lc_main
    WHERE id = "Key";

END $function$

*/
 }
/**
 * @function person_role_public_history
 * @memberof auth
 * @description Person role public history
 * @returns {trigger}
 */
function person_role_public_history() {
/*
CREATE OR REPLACE FUNCTION auth.person_role_public_history()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$ 
DECLARE v_person_id INT;
        v_user_id UUID; 
BEGIN

	v_person_id := auth.get_context_person_id();
    v_user_id := auth.get_context_user_id();

	IF TG_OP = 'DELETE' THEN
		INSERT INTO zzHistory.auth_person_role_public (
            id,
            person_id,
            role_public_id,
            ModifiedUserId,
            ModifiedPersonId,
            ModifiedTime,
            ModifiedLogin,
            ModifiedAction
		)
		SELECT OLD.id,
               OLD.person_id,
               OLD.role_public_id,
               v_user_id,
               v_person_id,
               CURRENT_TIMESTAMP,
               CURRENT_USER,
               'D';
	ELSE
		INSERT INTO zzHistory.auth_person_role_public (
id,
            person_id,
            role_public_id,
            ModifiedUserId,
            ModifiedPersonId,
            ModifiedTime,
            ModifiedLogin,
            ModifiedAction
		)
		SELECT NEW.id,
               NEW.person_id,
               NEW.role_public_id,
               v_user_id,
               v_person_id,
               CURRENT_TIMESTAMP,
               CURRENT_USER,
               CASE WHEN TG_OP = 'INSERT' THEN 'I' ELSE 'U' END;
	END IF;
    RETURN NULL;
END $function$

*/
 }
/**
 * @function route_itrig_proc
 * @memberof meta
 * @description Route itrig proc
 * @returns {trigger}
 */
function route_itrig_proc() {
/*
CREATE OR REPLACE FUNCTION meta.route_itrig_proc()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN

	IF NOT EXISTS (
		SELECT 1 FROM meta.i18n i WHERE i.key = NEW.name
	) THEN
		INSERT INTO meta.i18n (key)
		VALUES (NEW.name);
	END IF;

	RETURN NEW;
	
END$function$

*/
 }
/**
 * @function auth_user_role_u
 * @memberof zzglc
 * @description Auth user role u
 * @param {character_varying} Json
 * @returns {void}
 */
function auth_user_role_u() {
/*
CREATE OR REPLACE FUNCTION zzglc.auth_user_role_u("Json" character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE v_row_count INTEGER;
BEGIN

    UPDATE auth.user_role t
    SET user_id = U.user_id,
        role_id = U.role_id 
    FROM json_to_record("Json"::json) AS U (
        id uuid,
            user_id uuid,
            role_id uuid,
            time_modified timestamp without time zone
    ) 
    WHERE U.id = t.id
    AND t.time_modified = U.time_modified;
    GET DIAGNOSTICS v_row_count = ROW_COUNT;
    IF v_row_count = 0 THEN
      SELECT meta.raise_error(2);
    END IF
;

END $function$

*/
 }
/**
 * @function meta_route_d
 * @memberof zzglc
 * @description Meta route d
 * @param {integer} Key
 * @returns {void}
 */
function meta_route_d() {
/*
CREATE OR REPLACE FUNCTION zzglc.meta_route_d("Key" integer)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

    DELETE FROM meta.route
    WHERE id = "Key";

END $function$

*/
 }
/**
 * @function data_indicator_lang_u
 * @memberof zzglc
 * @description Data indicator lang u
 * @param {character_varying} Json
 * @returns {void}
 */
function data_indicator_lang_u() {
/*
CREATE OR REPLACE FUNCTION zzglc.data_indicator_lang_u("Json" character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE v_row_count INTEGER;
BEGIN

	CREATE TEMP TABLE j AS 
	SELECT * FROM json_to_record("Json"::json) AS U (
        id integer,
            indicator_id integer,
            lang_id integer,
            value character varying(255)
	);

    UPDATE data.indicator_lang t
    SET indicator_id = U.indicator_id,
        lang_id = U.lang_id,
        value = U.value 
    FROM json_to_record("Json"::json) AS U (
        id integer,
            indicator_id integer,
            lang_id integer,
            value character varying(255)
    ) 
    WHERE U.id = t.id;
		
    INSERT INTO data.indicator_lang (indicator_id, lang_id, value)	
	SELECT indicator_id, lang_id, value FROM j WHERE id &lt; 0;
	
	DROP TABLE j;

END $function$

*/
 }
/**
 * @function general_region_c
 * @memberof zzglc
 * @description General region c
 * @param {character_varying} Json
 * @returns {void}
 */
function general_region_c() {
/*
CREATE OR REPLACE FUNCTION zzglc.general_region_c("Json" character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

    INSERT INTO general.region (
        name
    )
    SELECT
        U.name
    FROM
        json_to_record("Json"::json) U (
            name character varying
        ) 
;
END $function$

*/
 }
/**
 * @function get_data_source_data
 * @memberof data
 * @description Get data source data
 * @param {text} Params
 * @param {integer} PersonId
 * @param {integer} LangId
 * @returns {json}
 */
function get_data_source_data() {
/*
CREATE OR REPLACE FUNCTION data.get_data_source_data("Params" text, "PersonId" integer, "LangId" integer)
 RETURNS json
 LANGUAGE plpgsql
AS $function$

DECLARE v_data_source_id INT;
		v_sql VARCHAR;
		v_part VARCHAR;
		v_a1 VARCHAR;
		v_a2 VARCHAR;
		r TEXT;
BEGIN

  v_data_source_id := ("Params"::json)->'data_source_id';
  
  DROP TABLE IF EXISTS ind;
  CREATE TEMP TABLE ind AS 
  SELECT DISTINCT i.id, i.name
  FROM data.measurement m
  INNER JOIN data.indicator i ON i.id = m.indicator_id
  WHERE m.data_source_id = v_data_source_id
  ORDER BY 2;
  
  v_sql := E'SELECT json_agg(t.*) FROM (\n SELECT p.point_key, ids[2]::int elev, d.name depth, ids[4]::date date, ';
  
  SELECT string_agg('t."' || ind.name || '"', ', ') INTO v_part
  FROM ind ORDER BY 1;
  RAISE NOTICE 'v_part %', v_part;
	
  v_a1 := 'SELECT ARRAY[p.id::varchar, p.elev::varchar, m.depth_id::varchar, m.date::varchar], i.name, m.value ' ||
	 	 'FROM data.measurement m ' ||
		 'INNER JOIN data.indicator i on i.id = m.indicator_id ' ||
		 'INNER JOIN data.point p on p.id = m.point_id WHERE m.data_source_id = ' || v_data_source_id || ' ORDER BY 1';
  
  RAISE NOTICE 'a1 %', v_a1;
  
  -- v_a2 := 'SELECT DISTINCT i.name FROM data.indicator i inner join data.measurement m on m.indicator_id = i.id AND m.data_source_id = ' || v_data_source_id;
  v_a2 := 'SELECT name FROM ind ORDER BY 1';
   
  RAISE NOTICE 'a2 %', v_a2;
  
  v_sql := v_sql || v_part || E' FROM ( SELECT * FROM crosstab (\n''' ||
	v_a1 || E''' , \n''' || v_a2 || 
	''') AS ct (ids varchar[], ';

  RAISE NOTICE 'sql %', v_sql;
  
  SELECT string_agg('"' || name || '" float', ', ') INTO v_part
  FROM ind;														     
  
  RAISE NOTICE 'part %', v_part;  
  
  v_sql := v_sql || v_part || ')) t ' ||
    'INNER JOIN data.point p ON p.id = ids[1]::int ' ||
	'LEFT JOIN data.depth d ON d.id = ids[3]::int ORDER BY 1, 2, 3, 4 ) t;';
	
  RAISE NOTICE 'final sql %', v_sql;
															   
  EXECUTE v_sql INTO r;
  
  RETURN r;
  
END 
$function$

*/
 }
/**
 * @function data_lu_detail_r
 * @memberof zzglc
 * @description Data lu detail r
 * @returns {Object}
 * @property {integer} id
 * @property {character_varying} name
 * @property {character_varying} code
 * @property {integer} color_id
 * @property {character_varying} color_id_val
 * @property {character_varying} color_code
 */
function data_lu_detail_r() {
/*
CREATE OR REPLACE FUNCTION zzglc.data_lu_detail_r()
 RETURNS TABLE(id integer, name character varying, code character varying, color_id integer, color_id_val character varying, color_code character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

    RETURN QUERY
    SELECT
    t.id, t.name, t.code::VARCHAR, t.color_id
    , color_id_t.name::VARCHAR AS color_id_val
		, color_id_t.code
    FROM data.lu_detail t

    LEFT JOIN general.color color_id_t ON color_id_t.id = t.color_id
    
    ORDER BY t.name
;
END $function$

*/
 }
/**
 * @function get_event_dates
 * @memberof auth
 * @description Get event dates
 * @param {integer} TenantId
 * @param {integer} PeriodId
 * @param {integer} AppId
 * @returns {Object}
 * @property {uuid} event_id
 * @property {timestamp_without_time_zone} datetime
 */
function get_event_dates() {
/*
CREATE OR REPLACE FUNCTION auth.get_event_dates("TenantId" integer DEFAULT NULL::integer, "PeriodId" integer DEFAULT NULL::integer, "AppId" integer DEFAULT NULL::integer)
 RETURNS TABLE(event_id uuid, datetime timestamp without time zone)
 LANGUAGE plpgsql
AS $function$
BEGIN

	RETURN QUERY
    SELECT DISTINCT ed.event_id, ed.datetime
    FROM auth.event_date AS ed
		JOIN auth.event e ON e.id = ed.event_id
		WHERE (e.tenant_id = "TenantId" OR "TenantId" IS NULL) 
			AND ed.period_id = "PeriodId" AND e.app_id = "AppId";
END $function$

*/
 }
/**
 * @function data_unit_r
 * @memberof zzglc
 * @description Data unit r
 * @returns {Object}
 * @property {integer} id
 * @property {character_varying} name
 */
function data_unit_r() {
/*
CREATE OR REPLACE FUNCTION zzglc.data_unit_r()
 RETURNS TABLE(id integer, name character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

    RETURN QUERY
    SELECT
    t.id, t.name
    FROM data.unit t
    
    ORDER BY t.name
;
END $function$

*/
 }
/**
 * @function get_children_boundaries
 * @memberof general
 * @description Get children boundaries
 * @param {integer} OsmId
 * @param {integer} Srid
 * @returns {json}
 */
function get_children_boundaries() {
/*
CREATE OR REPLACE FUNCTION general.get_children_boundaries("OsmId" integer, "Srid" integer)
 RETURNS json
 LANGUAGE plpgsql
AS $function$
BEGIN

	RETURN (
		SELECT jsonb_build_object (
				'type',       'FeatureCollection',
				'features', json_agg(st_asgeojson(t.*)::json)
    )
		FROM (
			SELECT b.id, name, osm_id, st_transform(geom, "Srid")
			FROM general.boundary_hierarchy h
			INNER JOIN general.boundary b ON b.osm_id = h.child_id
			WHERE parent_id = "OsmId" -- AND parent_distance = 1
		) t	
	);
END$function$

*/
 }
/**
 * @function auth_role_public_u
 * @memberof zzglc
 * @description Auth role public u
 * @param {character_varying} Json
 * @returns {void}
 */
function auth_role_public_u() {
/*
CREATE OR REPLACE FUNCTION zzglc.auth_role_public_u("Json" character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE v_row_count INTEGER;
BEGIN

    UPDATE auth.role_public t
    SET name = U.name 
    FROM json_to_record("Json"::json) AS U (
        id integer,
            name character varying(255)
    ) 
    WHERE U.id = t.id
;

END $function$

*/
 }
/**
 * @function data_depth_l
 * @memberof zzgll
 * @description Data depth l
 * @param {character_varying} SearchValue
 * @param {integer} Key
 * @returns {Object}
 * @property {integer} id
 * @property {character_varying} name
 */
function data_depth_l() {
/*
CREATE OR REPLACE FUNCTION zzgll.data_depth_l("SearchValue" character varying, "Key" integer DEFAULT NULL::integer)
 RETURNS TABLE(id integer, name character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

        IF "Key" IS NOT NULL THEN
            RETURN QUERY
            SELECT t.id, t.name
            FROM data.depth t
            WHERE t.id = "Key"::integer;
        ELSE
            RETURN QUERY
           SELECT t.id, t.name
            FROM data.depth t
            WHERE t.name LIKE "SearchValue"
            ORDER BY t.name
           LIMIT 1000;
       END IF;
END $function$

*/
 }
/**
 * @function update_i18n_lang
 * @memberof meta
 * @description Update i18n lang
 * @returns {void}
 */
function update_i18n_lang() {
/*
CREATE OR REPLACE FUNCTION meta.update_i18n_lang()
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

	INSERT INTO meta.i18n_lang (i18n_id, lang_id, value)
	SELECT i.id, l.id, i.key
	FROM meta.lang l
	INNER JOIN meta.i18n i ON 1=1
	LEFT JOIN meta.i18n_lang il ON il.lang_id = l.id AND il.i18n_id = i.id
	WHERE il.id IS NULL;
	
END$function$

*/
 }
/**
 * @function meta_import_detail_r
 * @memberof zzglc
 * @description Meta import detail r
 * @param {integer} MasterId
 * @returns {Object}
 * @property {integer} id
 * @property {integer} import_master_id
 * @property {character_varying} col_name
 * @property {character_varying} target_schema
 * @property {character_varying} target_table
 * @property {character_varying} target_column
 * @property {character_varying} col_type
 * @property {boolean} is_key
 * @property {boolean} is_fk
 * @property {character_varying} name
 * @property {boolean} as_row
 * @property {character_varying} target_column_list
 * @property {character_varying} source_column_list
 * @property {character_varying} joins
 * @property {boolean} split
 * @property {boolean} ignore
 * @property {character_varying} name_match
 * @property {integer} order_no
 * @property {boolean} ignore_in_master
 * @property {character_varying} constant_value
 * @property {character_varying} import_master_id_val
 */
function meta_import_detail_r() {
/*
CREATE OR REPLACE FUNCTION zzglc.meta_import_detail_r("MasterId" integer)
 RETURNS TABLE(id integer, import_master_id integer, col_name character varying, target_schema character varying, target_table character varying, target_column character varying, col_type character varying, is_key boolean, is_fk boolean, name character varying, as_row boolean, target_column_list character varying, source_column_list character varying, joins character varying, split boolean, ignore boolean, name_match character varying, order_no integer, ignore_in_master boolean, constant_value character varying, import_master_id_val character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

    RETURN QUERY
    SELECT
    t.id, t.import_master_id, t.col_name, t.target_schema, t.target_table, t.target_column, t.col_type, t.is_key, t.is_fk, t.name, t.as_row, t.target_column_list, t.source_column_list, t.joins, t.split, t.ignore, t.name_match, t.order_no, t.ignore_in_master, t.constant_value
    , import_master_id_t.schema_name::VARCHAR AS import_master_id_val
    FROM meta.import_detail t

    LEFT JOIN meta.import_master import_master_id_t ON import_master_id_t.id = t.import_master_id
    
    WHERE t.import_master_id = "MasterId" or "MasterId" is null
    
    ORDER BY t.order_no
;
END $function$

*/
 }
/**
 * @function data_nuts_3_l
 * @memberof zzgll
 * @description Data nuts 3 l
 * @param {character_varying} SearchValue
 * @param {integer} Key
 * @returns {Object}
 * @property {integer} id
 * @property {character_varying} name
 */
function data_nuts_3_l() {
/*
CREATE OR REPLACE FUNCTION zzgll.data_nuts_3_l("SearchValue" character varying, "Key" integer DEFAULT NULL::integer)
 RETURNS TABLE(id integer, name character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

        IF "Key" IS NOT NULL THEN
            RETURN QUERY
            SELECT t.id, t.name
            FROM data.nuts_3 t
            WHERE t.id = "Key"::integer;
        ELSE
            RETURN QUERY
           SELECT t.id, t.name
            FROM data.nuts_3 t
            WHERE t.name LIKE "SearchValue"
            ORDER BY t.name
           LIMIT 1000;
       END IF;
END $function$

*/
 }
/**
 * @function meta_help_lang_r
 * @memberof zzglc
 * @description Meta help lang r
 * @param {integer} LangId
 * @returns {Object}
 * @property {integer} id
 * @property {integer} help_id
 * @property {integer} lang_id
 * @property {character_varying} value
 * @property {character_varying} meta_help_id_val
 * @property {character_varying} meta_lang_id_val
 */
function meta_help_lang_r() {
/*
CREATE OR REPLACE FUNCTION zzglc.meta_help_lang_r("LangId" integer)
 RETURNS TABLE(id integer, help_id integer, lang_id integer, value character varying, meta_help_id_val character varying, meta_lang_id_val character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

    RETURN QUERY
    SELECT
    COALESCE (t.id, -row_number() over (order by help_id_t.name))::int id
		, help_id_t.id help_id
		, "LangId" lang_id
		, COALESCE(t.value, t1.value)
    , help_id_t.name::VARCHAR AS help_id_val
		, lang_id_t.name::VARCHAR AS lang_id_val
		--, (t.id is not null) translated
    FROM meta.help help_id_t
    LEFT JOIN meta.help_lang t ON help_id_t.id = t.help_id AND t.lang_id = "LangId"
   	LEFT JOIN meta.lang lang_id_t ON lang_id_t.id = t.lang_id
		LEFT JOIN meta.help_lang t1 ON t1.lang_id = 1 AND t1.help_id = help_id_t.id    
    ORDER BY help_id_t.name
;
END 
$function$

*/
 }
/**
 * @function lookup
 * @memberof meta
 * @description Lookup
 * @param {character_varying} schema_name
 * @param {character_varying} table_name
 * @param {character_varying} referenced_column_display_name
 * @param {character_varying} referenced_column_type
 * @returns {void}
 */
function lookup() {
/*
CREATE OR REPLACE FUNCTION meta.lookup(schema_name character varying, table_name character varying, referenced_column_display_name character varying, referenced_column_type character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
DECLARE sql VARCHAR;
BEGIN

	IF meta.function_exists('zzglc', "schema_name" || '_' || "table_name" || '_l') THEN
		RETURN;
	END IF;
	sql := 'DROP FUNCTION IF EXISTS zzgll.' || schema_name || '_' || table_name || '_l;
CREATE OR REPLACE FUNCTION zzgll.' || schema_name || '_' || table_name || '_l("SearchValue" varchar, "Key" ' || referenced_column_type || '=NULL::' || referenced_column_type || ')
  RETURNS TABLE(id ' || referenced_column_type || ', ' || referenced_column_display_name || ' varchar) AS $f$
BEGIN
        IF "Key" IS NOT NULL THEN
            RETURN QUERY
            SELECT t.id, t.' || referenced_column_display_name || '
            FROM ' || schema_name || '.' || table_name || ' t
            WHERE t.id = "Key"::' || referenced_column_type || ';
        ELSE
            RETURN QUERY
            SELECT t.id, t.' || referenced_column_display_name || '
            FROM ' || schema_name || '.' || table_name || ' t
            WHERE t.' || referenced_column_display_name || ' LIKE "SearchValue"
            ORDER BY t.' || referenced_column_display_name || '
            LIMIT 1000;
       END IF;
END $f$
  LANGUAGE plpgsql ';
	--RAISE NOTICE '%', sql;
	EXECUTE sql;
END $function$

*/
 }
/**
 * @function login
 * @memberof auth
 * @description Login
 * @param {integer} PersonId
 * @param {character_varying} IP
 * @returns {json}
 */
function login() {
/*
CREATE OR REPLACE FUNCTION auth.login("PersonId" integer, "IP" character varying)
 RETURNS json
 LANGUAGE plpgsql
AS $function$
BEGIN

	INSERT INTO auth.log(person_id, ip)
	VALUES ("PersonId", "IP");
	
	RETURN (
		SELECT json_agg(t.*) FROM (
			SELECT t.*, EXISTS(SELECT 1 FROM auth.person_role_public r WHERE r.person_id = t.id AND r.role_public_id = 1) is_admin
			FROM general.person t
			WHERE id = "PersonId"
		) t
	);

END $function$

*/
 }
/**
 * @function meta_help_lang_u
 * @memberof zzglc
 * @description Meta help lang u
 * @param {character_varying} Json
 * @returns {void}
 */
function meta_help_lang_u() {
/*
CREATE OR REPLACE FUNCTION zzglc.meta_help_lang_u("Json" character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

	CREATE TEMP TABLE j AS 
	SELECT * FROM json_to_record("Json"::json) AS U (
        id integer,
        help_id integer,
        lang_id integer,
        value character varying(255)
	);

	UPDATE meta.help_lang t
	SET help_id = U.help_id,
			lang_id = U.lang_id,
			value = U.value 
	FROM json_to_record("Json"::json) AS U (
			id integer,
					help_id integer,
					lang_id integer,
					value character varying(255)
	) 
	WHERE U.id = t.id;
	
	INSERT INTO meta.help_lang (help_id, lang_id, value)	
	SELECT help_id, lang_id, value FROM j WHERE id &lt; 0;
	
	DROP TABLE j;

END 
$function$

*/
 }
/**
 * @function data_shape_c
 * @memberof zzglc
 * @description Data shape c
 * @param {character_varying} Json
 * @returns {void}
 */
function data_shape_c() {
/*
CREATE OR REPLACE FUNCTION zzglc.data_shape_c("Json" character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

    INSERT INTO data.shape (
        data_source_id,
        name
    )
    SELECT
        U.data_source_id,
        U.name
    FROM
        json_to_record("Json"::json) U (
data_source_id integer,
            name character varying(255)
        ) 
;
END $function$

*/
 }
/**
 * @function meta_i18n_lang_r
 * @memberof zzglc
 * @description Meta i18n lang r
 * @param {integer} LangId
 * @returns {Object}
 * @property {integer} id
 * @property {integer} i18n_id
 * @property {integer} lang_id
 * @property {character_varying} value
 * @property {character_varying} i18n_id_val
 * @property {character_varying} lang_id_val
 */
function meta_i18n_lang_r() {
/*
CREATE OR REPLACE FUNCTION zzglc.meta_i18n_lang_r("LangId" integer)
 RETURNS TABLE(id integer, i18n_id integer, lang_id integer, value character varying, i18n_id_val character varying, lang_id_val character varying)
 LANGUAGE plpgsql
AS $function$
BEGIN

    RETURN QUERY
    SELECT
    COALESCE (t.id, -row_number() over (order by i18n_id_t.key))::int id
		, i18n_id_t.id i18n_id
		, "LangId" lang_id
		, COALESCE(t.value, t1.value)
    , i18n_id_t.key::VARCHAR AS i18n_id_val
		, lang_id_t.name::VARCHAR AS lang_id_val
		--, (t.id is not null) translated
    FROM meta.i18n i18n_id_t
    LEFT JOIN meta.i18n_lang t ON i18n_id_t.id = t.i18n_id AND t.lang_id = "LangId"
   	LEFT JOIN meta.lang lang_id_t ON lang_id_t.id = t.lang_id
		LEFT JOIN meta.i18n_lang t1 ON t1.lang_id = 1 AND t1.i18n_id = i18n_id_t.id    
    ORDER BY i18n_id_t.key
;
END 
$function$

*/
 }
/**
 * @function meta_news_lang_c
 * @memberof zzglc
 * @description Meta news lang c
 * @param {character_varying} Json
 * @returns {void}
 */
function meta_news_lang_c() {
/*
CREATE OR REPLACE FUNCTION zzglc.meta_news_lang_c("Json" character varying)
 RETURNS void
 LANGUAGE plpgsql
AS $function$
BEGIN

    INSERT INTO meta.news_lang (
        lang_id,
        text,
        extended_text,
        user_modified,
        time_created,
        active,
        title,
        news_id
    )
    SELECT
        U.lang_id,
        U.text,
        U.extended_text,
        U.user_modified,
        U.time_created,
        U.active,
        U.title,
        U.news_id
    FROM
        json_to_record("Json"::json) U (
lang_id integer,
            text character varying(65535),
            extended_text character varying(65535),
            user_modified integer,
            time_created timestamp without time zone,
            active boolean,
            title character varying(255),
            news_id integer
        ) 
;
END $function$

*/
 }
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Schemas</h3><ul><li><a href="auth.html">auth</a></li><li><a href="data.html">data</a></li><li><a href="general.html">general</a></li><li><a href="log.html">log</a></li><li><a href="meta.html">meta</a></li><li><a href="osm.html">osm</a></li><li><a href="utils.html">utils</a></li><li><a href="zzglc.html">zzglc</a></li><li><a href="zzgll.html">zzgll</a></li><li><a href="zzhistory.html">zzhistory</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.2</a> on Tue Apr 09 2024 13:50:23 GMT+0200 (Central European Summer Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
